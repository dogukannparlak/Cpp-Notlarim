# Pointerlar

## İçindekiler
1. [Pointer Nedir?](#pointer-nedir)
2. [Pointer Bildirimi ve Tanımlama](#pointer-bildirimi-ve-tanımlama)
3. [Temel Pointer İşlemleri](#temel-pointer-işlemleri)
4. [Pointer Aritmetiği](#pointer-aritmetiği)
5. [Diziler ve Pointerlar](#diziler-ve-pointerlar)
6. [Fonksiyonlar ve Pointerlar](#fonksiyonlar-ve-pointerlar)
7. [Çok Boyutlu Pointerlar](#çok-boyutlu-pointerlar)
8. [Dinamik Bellek Yönetimi](#dinamik-bellek-yönetimi)
9. [Pointer'lar Arası Karşılaştırma](#pointerlar-arası-karşılaştırma)
10. [İyi Uygulamalar ve Güvenlik](#iyi-uygulamalar-ve-güvenlik)

---

## Pointer Nedir?

**Pointer**, başka bir değişkenin bellek adresini saklayan özel bir değişken türüdür. Pointerlar, C++'ın en güçlü ve aynı zamanda en dikkatli kullanılması gereken özelliklerinden biridir.

### Neden Pointerlar Kullanırız?

```cpp
#include <iostream>
using namespace std;

// 1. Büyük veri yapılarını kopyalamak yerine adresini geçmek
struct BuyukVeri {
    int dizi[1000000];
    double matrix[1000][1000];
};

// Kötü yaklaşım - kopyalama
void islemYapKotu(BuyukVeri veri) {
    // 1 milyonluk dizi kopyalanır - çok yavaş!
    cout << "İşlem yapılıyor..." << endl;
}

// İyi yaklaşım - pointer kullanımı
void islemYapIyi(BuyukVeri* veri) {
    // Sadece adres geçilir - çok hızlı!
    cout << "İşlem yapılıyor: " << veri->dizi[0] << endl;
}

int main() {
    BuyukVeri veriler;
    veriler.dizi[0] = 42;
    
    // islemYapKotu(veriler);  // Yavaş
    islemYapIyi(&veriler);     // Hızlı
    
    return 0;
}
```

### Pointer'ların Avantajları

```cpp
#include <iostream>
#include <memory>
using namespace std;

// 1. Dinamik bellek yönetimi
void dinamikBellekOrnegi() {
    cout << "=== Dinamik Bellek Yönetimi ===" << endl;
    
    // Çalışma zamanında boyut belirleme
    int boyut;
    cout << "Dizi boyutunu girin: ";
    cin >> boyut;
    
    int* dinamikDizi = new int[boyut];
    
    for(int i = 0; i < boyut; i++) {
        dinamikDizi[i] = i * 10;
    }
    
    cout << "Dinamik dizi: ";
    for(int i = 0; i < boyut; i++) {
        cout << dinamikDizi[i] << " ";
    }
    cout << endl;
    
    delete[] dinamikDizi; // Belleği serbest bırak
}

// 2. Polimorfizm ve sanal fonksiyonlar
class Hayvan {
public:
    virtual void sesCikar() = 0;
    virtual ~Hayvan() = default;
};

class Kedi : public Hayvan {
public:
    void sesCikar() override {
        cout << "Miyav!" << endl;
    }
};

class Kopek : public Hayvan {
public:
    void sesCikar() override {
        cout << "Hav hav!" << endl;
    }
};

void polimorfizmOrnegi() {
    cout << "\n=== Polimorfizm Örneği ===" << endl;
    
    Hayvan* hayvanlar[] = {
        new Kedi(),
        new Kopek(),
        new Kedi()
    };
    
    for(int i = 0; i < 3; i++) {
        hayvanlar[i]->sesCikar(); // Dinamik bağlama
        delete hayvanlar[i];
    }
}

int main() {
    dinamikBellekOrnegi();
    polimorfizmOrnegi();
    return 0;
}
```

---

## Pointer Bildirimi ve Tanımlama

### Temel Pointer Syntax'ı

```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "=== Pointer Bildirimi ===" << endl;
    
    // 1. Temel pointer bildirimi
    int sayi = 42;
    int* ptr;           // int türünde pointer bildirimi
    ptr = &sayi;        // sayi'nın adresini ptr'ye ata
    
    // 2. Bildirimi ve atamayı birlikte yapma
    int deger = 100;
    int* ptr2 = &deger;
    
    // 3. Farklı türlerde pointerlar
    double ondalik = 3.14;
    double* doublePtr = &ondalik;
    
    char karakter = 'A';
    char* charPtr = &karakter;
    
    // 4. Pointer değerlerini yazdırma
    cout << "sayi değeri: " << sayi << endl;
    cout << "sayi adresi: " << &sayi << endl;
    cout << "ptr değeri (adres): " << ptr << endl;
    cout << "ptr'nin işaret ettiği değer: " << *ptr << endl;
    
    // 5. Pointer boyutları
    cout << "\n=== Pointer Boyutları ===" << endl;
    cout << "int* boyutu: " << sizeof(int*) << " byte" << endl;
    cout << "double* boyutu: " << sizeof(double*) << " byte" << endl;
    cout << "char* boyutu: " << sizeof(char*) << " byte" << endl;
    
    return 0;
}
```

### Null Pointerlar

```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "=== Null Pointerlar ===" << endl;
    
    // 1. Null pointer tanımlama yöntemleri
    int* ptr1 = nullptr;    // Modern C++ (önerilen)
    int* ptr2 = NULL;       // C tarzı (eski)
    int* ptr3 = 0;          // Sayısal sıfır (kullanılmamalı)
    
    // 2. Null pointer kontrolü
    if (ptr1 == nullptr) {
        cout << "ptr1 null pointer" << endl;
    }
    
    // 3. Güvenli pointer kullanımı
    int sayi = 50;
    int* guvenliPtr = &sayi;
    
    if (guvenliPtr != nullptr) {
        cout << "Güvenli değer: " << *guvenliPtr << endl;
    }
    
    // 4. Null pointer hatası önleme
    auto guvenliErisim = [](int* ptr) {
        if (ptr != nullptr) {
            return *ptr;
        } else {
            cout << "Hata: Null pointer erişimi!" << endl;
            return -1;
        }
    };
    
    cout << "Güvenli erişim: " << guvenliErisim(guvenliPtr) << endl;
    cout << "Null erişim: " << guvenliErisim(nullptr) << endl;
    
    return 0;
}
```

---

## Temel Pointer İşlemleri

### Adres ve Değer İşlemleri

```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "=== Temel Pointer İşlemleri ===" << endl;
    
    int a = 10, b = 20, c = 30;
    
    // 1. Adres alma operatörü (&)
    cout << "a'nın adresi: " << &a << endl;
    cout << "b'nin adresi: " << &b << endl;
    cout << "c'nin adresi: " << &c << endl;
    
    // 2. Pointer tanımlama ve dereference (*)
    int* ptr = &a;
    cout << "\nptr'nin değeri (adres): " << ptr << endl;
    cout << "ptr'nin işaret ettiği değer: " << *ptr << endl;
    
    // 3. Pointer ile değer değiştirme
    *ptr = 100;
    cout << "a'nın yeni değeri: " << a << endl;
    
    // 4. Pointer'ı farklı değişkene yönlendirme
    ptr = &b;
    cout << "ptr şimdi b'yi işaret ediyor: " << *ptr << endl;
    
    // 5. Değer swap işlemi
    int x = 5, y = 15;
    int* ptrX = &x;
    int* ptrY = &y;
    
    cout << "\nSwap öncesi - x: " << x << ", y: " << y << endl;
    
    // Swap işlemi
    int temp = *ptrX;
    *ptrX = *ptrY;
    *ptrY = temp;
    
    cout << "Swap sonrası - x: " << x << ", y: " << y << endl;
    
    return 0;
}
```

### Const Pointerlar

```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "=== Const Pointerlar ===" << endl;
    
    int a = 10, b = 20;
    
    // 1. Const değere pointer (pointer değiştirilebilir, değer değiştirilemez)
    const int* ptr1 = &a;
    cout << "Const değer: " << *ptr1 << endl;
    // *ptr1 = 30;  // HATA! Değer değiştirilemez
    ptr1 = &b;      // OK! Pointer değiştirilebilir
    cout << "Yeni const değer: " << *ptr1 << endl;
    
    // 2. Const pointer (pointer değiştirilemez, değer değiştirilebilir)
    int* const ptr2 = &a;
    *ptr2 = 50;     // OK! Değer değiştirilebilir
    cout << "Değiştirilmiş değer: " << *ptr2 << endl;
    // ptr2 = &b;   // HATA! Pointer değiştirilemez
    
    // 3. Const pointer to const (ne pointer ne de değer değiştirilebilir)
    const int* const ptr3 = &a;
    cout << "Const pointer to const: " << *ptr3 << endl;
    // *ptr3 = 60;  // HATA! Değer değiştirilemez
    // ptr3 = &b;   // HATA! Pointer değiştirilemez
    
    // 4. Pratik örnek: Fonksiyon parametreleri
    auto yazdirSadece = [](const int* ptr) {
        cout << "Salt okunur değer: " << *ptr << endl;
        // *ptr = 100; // HATA! Değer değiştirilemez
    };
    
    auto degistirSadece = [](int* const ptr) {
        *ptr = 200; // OK! Değer değiştirilebilir
        cout << "Değiştirilmiş değer: " << *ptr << endl;
        // ptr = nullptr; // HATA! Pointer değiştirilemez
    };
    
    int deger = 75;
    yazdirSadece(&deger);
    degistirSadece(&deger);
    
    return 0;
}
```

---

## Pointer Aritmetiği

### Temel Aritmetik İşlemler

```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "=== Pointer Aritmetiği ===" << endl;
    
    int dizi[] = {10, 20, 30, 40, 50};
    int* ptr = dizi; // İlk elemana işaret et
    
    cout << "Başlangıç durumu:" << endl;
    cout << "ptr adresi: " << ptr << endl;
    cout << "ptr değeri: " << *ptr << endl;
    
    // 1. Pointer artırma (++)
    cout << "\n=== Pointer Artırma ===" << endl;
    ptr++;
    cout << "ptr++ sonrası adres: " << ptr << endl;
    cout << "ptr++ sonrası değer: " << *ptr << endl;
    
    // 2. Pointer azaltma (--)
    cout << "\n=== Pointer Azaltma ===" << endl;
    ptr--;
    cout << "ptr-- sonrası adres: " << ptr << endl;
    cout << "ptr-- sonrası değer: " << *ptr << endl;
    
    // 3. Pointer'a sayı ekleme/çıkarma
    cout << "\n=== Pointer + Sayı ===" << endl;
    cout << "ptr + 2 adresi: " << (ptr + 2) << endl;
    cout << "ptr + 2 değeri: " << *(ptr + 2) << endl;
    cout << "ptr + 4 değeri: " << *(ptr + 4) << endl;
    
    // 4. Farklı türlerde pointer aritmetiği
    cout << "\n=== Farklı Türlerde Adres Farkları ===" << endl;
    
    int intDizi[3] = {1, 2, 3};
    double doubleDizi[3] = {1.1, 2.2, 3.3};
    char charDizi[3] = {'A', 'B', 'C'};
    
    int* intPtr = intDizi;
    double* doublePtr = doubleDizi;
    char* charPtr = charDizi;
    
    cout << "int pointer farkı: " << (intPtr + 1) - intPtr << " eleman" << endl;
    cout << "int pointer adres farkı: " << (char*)(intPtr + 1) - (char*)intPtr << " byte" << endl;
    
    cout << "double pointer farkı: " << (doublePtr + 1) - doublePtr << " eleman" << endl;
    cout << "double pointer adres farkı: " << (char*)(doublePtr + 1) - (char*)doublePtr << " byte" << endl;
    
    cout << "char pointer farkı: " << (charPtr + 1) - charPtr << " eleman" << endl;
    cout << "char pointer adres farkı: " << (charPtr + 1) - charPtr << " byte" << endl;
    
    return 0;
}
```

### Dizi Traversal ile Pointer Aritmetiği

```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "=== Dizi Traversal ===" << endl;
    
    int sayilar[] = {5, 15, 25, 35, 45, 55};
    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);
    
    // 1. Normal indeks ile
    cout << "Normal indeks ile:" << endl;
    for(int i = 0; i < boyut; i++) {
        cout << "sayilar[" << i << "] = " << sayilar[i] << endl;
    }
    
    // 2. Pointer aritmetiği ile
    cout << "\nPointer aritmetiği ile:" << endl;
    int* ptr = sayilar;
    for(int i = 0; i < boyut; i++) {
        cout << "*(ptr + " << i << ") = " << *(ptr + i) << endl;
    }
    
    // 3. Pointer artırma ile
    cout << "\nPointer artırma ile:" << endl;
    ptr = sayilar; // Başa dön
    for(int i = 0; i < boyut; i++) {
        cout << "*ptr = " << *ptr << ", adres: " << ptr << endl;
        ptr++;
    }
    
    // 4. While döngüsü ile
    cout << "\nWhile döngüsü ile:" << endl;
    ptr = sayilar;
    int* son = sayilar + boyut;
    while(ptr < son) {
        cout << "*ptr = " << *ptr << endl;
        ptr++;
    }
    
    // 5. Range-based for ile (Modern C++)
    cout << "\nRange-based for ile:" << endl;
    for(const auto& eleman : sayilar) {
        cout << "eleman = " << eleman << endl;
    }
    
    return 0;
}
```

---

## Diziler ve Pointerlar

### Dizi-Pointer İlişkisi

```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "=== Dizi-Pointer İlişkisi ===" << endl;
    
    int dizi[] = {100, 200, 300, 400, 500};
    
    // 1. Dizi adı bir pointer gibi davranır
    cout << "dizi adresi: " << dizi << endl;
    cout << "&dizi[0] adresi: " << &dizi[0] << endl;
    cout << "Bu iki adres aynı mı? " << (dizi == &dizi[0] ? "Evet" : "Hayır") << endl;
    
    // 2. Dizi elemanlarına erişim yöntemleri
    cout << "\n=== Erişim Yöntemleri ===" << endl;
    cout << "dizi[2] = " << dizi[2] << endl;
    cout << "*(dizi + 2) = " << *(dizi + 2) << endl;
    cout << "2[dizi] = " << 2[dizi] << endl; // İlginç C++ özelliği!
    
    // 3. Pointer ile dizi manipülasyonu
    int* ptr = dizi;
    cout << "\n=== Pointer ile Manipülasyon ===" << endl;
    for(int i = 0; i < 5; i++) {
        cout << "ptr[" << i << "] = " << ptr[i] << endl;
    }
    
    // 4. Multi-dimensional diziler
    cout << "\n=== 2D Diziler ===" << endl;
    int matrix[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    
    int (*matrixPtr)[4] = matrix; // 4 elemanlı int dizisine pointer
    
    cout << "Matrix[1][2] = " << matrix[1][2] << endl;
    cout << "*(*(matrixPtr + 1) + 2) = " << *(*(matrixPtr + 1) + 2) << endl;
    cout << "matrixPtr[1][2] = " << matrixPtr[1][2] << endl;
    
    return 0;
}
```

### Dinamik Diziler

```cpp
#include <iostream>
#include <memory>
using namespace std;

// Dinamik dizi sınıfı örneği
class DinamikDizi {
private:
    int* veriler;
    size_t boyut;
    size_t kapasite;

public:
    DinamikDizi(size_t baslangicKapasitesi = 10) 
        : boyut(0), kapasite(baslangicKapasitesi) {
        veriler = new int[kapasite];
        cout << "DinamikDizi oluşturuldu, kapasite: " << kapasite << endl;
    }
    
    ~DinamikDizi() {
        delete[] veriler;
        cout << "DinamikDizi yok edildi" << endl;
    }
    
    void ekle(int deger) {
        if(boyut >= kapasite) {
            yeniden_boyutlandir();
        }
        veriler[boyut++] = deger;
    }
    
    int& operator[](size_t indeks) {
        if(indeks >= boyut) {
            throw out_of_range("Geçersiz indeks");
        }
        return veriler[indeks];
    }
    
    size_t getBoyut() const { return boyut; }
    size_t getKapasite() const { return kapasite; }
    
    void yazdir() const {
        cout << "Dizi: ";
        for(size_t i = 0; i < boyut; i++) {
            cout << veriler[i] << " ";
        }
        cout << "(boyut: " << boyut << ", kapasite: " << kapasite << ")" << endl;
    }

private:
    void yeniden_boyutlandir() {
        size_t yeniKapasite = kapasite * 2;
        int* yeniVeriler = new int[yeniKapasite];
        
        // Eski verileri kopyala
        for(size_t i = 0; i < boyut; i++) {
            yeniVeriler[i] = veriler[i];
        }
        
        delete[] veriler;
        veriler = yeniVeriler;
        kapasite = yeniKapasite;
        
        cout << "Dizi yeniden boyutlandırıldı, yeni kapasite: " << kapasite << endl;
    }
};

int main() {
    cout << "=== Dinamik Dizi Örneği ===" << endl;
    
    DinamikDizi dizi(3);
    
    // Elemanlar ekle
    for(int i = 1; i <= 10; i++) {
        dizi.ekle(i * 10);
        dizi.yazdir();
    }
    
    // Elemanlara erişim
    cout << "\n=== Eleman Erişimi ===" << endl;
    cout << "3. eleman: " << dizi[2] << endl;
    dizi[2] = 999;
    cout << "Değiştirilen 3. eleman: " << dizi[2] << endl;
    
    dizi.yazdir();
    
    return 0;
}
```

---

## Fonksiyonlar ve Pointerlar

### Fonksiyon Parametreleri

```cpp
#include <iostream>
using namespace std;

// 1. Değere göre geçiş (by value)
void degereGoreGecis(int sayi) {
    sayi = 100;
    cout << "Fonksiyon içinde sayi: " << sayi << endl;
}

// 2. Pointer ile geçiş (by pointer)
void pointerIleGecis(int* sayi) {
    *sayi = 200;
    cout << "Fonksiyon içinde *sayi: " << *sayi << endl;
}

// 3. Referans ile geçiş (by reference)
void referansIleGecis(int& sayi) {
    sayi = 300;
    cout << "Fonksiyon içinde sayi: " << sayi << endl;
}

// 4. Dizi parametreleri
void diziYazdir(int dizi[], int boyut) {
    cout << "Dizi elemanları: ";
    for(int i = 0; i < boyut; i++) {
        cout << dizi[i] << " ";
    }
    cout << endl;
}

void diziPointerYazdir(int* dizi, int boyut) {
    cout << "Pointer ile dizi: ";
    for(int i = 0; i < boyut; i++) {
        cout << *(dizi + i) << " ";
    }
    cout << endl;
}

// 5. Çok boyutlu dizi parametreleri
void matrixYazdir(int matrix[][3], int satirSayisi) {
    cout << "Matrix:" << endl;
    for(int i = 0; i < satirSayisi; i++) {
        for(int j = 0; j < 3; j++) {
            cout << matrix[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    cout << "=== Fonksiyon Parametreleri ===" << endl;
    
    int deger = 50;
    cout << "Başlangıç değeri: " << deger << endl;
    
    // Değere göre geçiş
    degereGoreGecis(deger);
    cout << "Değere göre geçiş sonrası: " << deger << endl;
    
    // Pointer ile geçiş
    pointerIleGecis(&deger);
    cout << "Pointer ile geçiş sonrası: " << deger << endl;
    
    // Referans ile geçiş
    referansIleGecis(deger);
    cout << "Referans ile geçiş sonrası: " << deger << endl;
    
    // Dizi örnekleri
    cout << "\n=== Dizi Parametreleri ===" << endl;
    int sayilar[] = {10, 20, 30, 40, 50};
    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);
    
    diziYazdir(sayilar, boyut);
    diziPointerYazdir(sayilar, boyut);
    
    // Matrix örneği
    cout << "\n=== Matrix Parametreleri ===" << endl;
    int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};
    matrixYazdir(matrix, 2);
    
    return 0;
}
```

### Fonksiyon Pointerları

```cpp
#include <iostream>
using namespace std;

// Matematiksel işlem fonksiyonları
int topla(int a, int b) {
    cout << a << " + " << b << " = ";
    return a + b;
}

int carp(int a, int b) {
    cout << a << " * " << b << " = ";
    return a * b;
}

int cıkar(int a, int b) {
    cout << a << " - " << b << " = ";
    return a - b;
}

// Callback fonksiyon örneği
void hesaplaVeYazdir(int x, int y, int (*islem)(int, int)) {
    int sonuc = islem(x, y);
    cout << sonuc << endl;
}

// Fonksiyon pointer dizisi
enum IslemTipi { TOPLAMA, CARPMA, CIKARMA };

int main() {
    cout << "=== Fonksiyon Pointerları ===" << endl;
    
    // 1. Temel fonksiyon pointer kullanımı
    int (*islemPtr)(int, int);
    
    islemPtr = topla;
    cout << "Toplama: ";
    cout << islemPtr(5, 3) << endl;
    
    islemPtr = carp;
    cout << "Çarpma: ";
    cout << islemPtr(5, 3) << endl;
    
    // 2. Fonksiyon pointer ile callback
    cout << "\n=== Callback Fonksiyonlar ===" << endl;
    hesaplaVeYazdir(10, 4, topla);
    hesaplaVeYazdir(10, 4, carp);
    hesaplaVeYazdir(10, 4, cıkar);
    
    // 3. Fonksiyon pointer dizisi
    cout << "\n=== Fonksiyon Pointer Dizisi ===" << endl;
    int (*islemler[])(int, int) = {topla, carp, cıkar};
    const char* islemAdlari[] = {"Toplama", "Çarpma", "Çıkarma"};
    
    for(int i = 0; i < 3; i++) {
        cout << islemAdlari[i] << ": ";
        cout << islemler[i](8, 2) << endl;
    }
    
    // 4. Lambda fonksiyonları ile modern yaklaşım
    cout << "\n=== Lambda Fonksiyonları ===" << endl;
    auto bol = [](int a, int b) -> int {
        cout << a << " / " << b << " = ";
        return b != 0 ? a / b : 0;
    };
    
    auto mod = [](int a, int b) -> int {
        cout << a << " % " << b << " = ";
        return b != 0 ? a % b : 0;
    };
    
    hesaplaVeYazdir(15, 4, bol);
    hesaplaVeYazdir(15, 4, mod);
    
    // 5. std::function kullanımı (C++11)
    #include <functional>
    function<int(int, int)> islevPtr = topla;
    cout << "\nstd::function ile: ";
    cout << islevPtr(7, 3) << endl;
    
    return 0;
}
```

---

## Çok Boyutlu Pointerlar

### Pointer to Pointer

```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "=== Pointer to Pointer ===" << endl;
    
    int sayi = 42;
    int* ptr = &sayi;
    int** ptrPtr = &ptr;
    int*** ptrPtrPtr = &ptrPtr;
    
    cout << "Değer zinciri:" << endl;
    cout << "sayi = " << sayi << endl;
    cout << "*ptr = " << *ptr << endl;
    cout << "**ptrPtr = " << **ptrPtr << endl;
    cout << "***ptrPtrPtr = " << ***ptrPtrPtr << endl;
    
    cout << "\nAdres zinciri:" << endl;
    cout << "&sayi = " << &sayi << endl;
    cout << "ptr = " << ptr << endl;
    cout << "*ptrPtr = " << *ptrPtr << endl;
    cout << "**ptrPtrPtr = " << **ptrPtrPtr << endl;
    
    // Pointer to pointer ile değer değiştirme
    **ptrPtr = 100;
    cout << "\n**ptrPtr = 100 sonrası:" << endl;
    cout << "sayi = " << sayi << endl;
    
    // Pratik örnek: Dinamik 2D dizi
    cout << "\n=== Dinamik 2D Dizi ===" << endl;
    
    int satirSayisi = 3;
    int sutunSayisi = 4;
    
    // Satır pointerları için yer ayır
    int** matrix = new int*[satirSayisi];
    
    // Her satır için yer ayır
    for(int i = 0; i < satirSayisi; i++) {
        matrix[i] = new int[sutunSayisi];
    }
    
    // Matrix'i doldur
    int deger = 1;
    for(int i = 0; i < satirSayisi; i++) {
        for(int j = 0; j < sutunSayisi; j++) {
            matrix[i][j] = deger++;
        }
    }
    
    // Matrix'i yazdır
    cout << "Dinamik 2D dizi:" << endl;
    for(int i = 0; i < satirSayisi; i++) {
        for(int j = 0; j < sutunSayisi; j++) {
            cout << matrix[i][j] << "\t";
        }
        cout << endl;
    }
    
    // Belleği temizle
    for(int i = 0; i < satirSayisi; i++) {
        delete[] matrix[i];
    }
    delete[] matrix;
    
    return 0;
}
```

### Çok Boyutlu Dizi Pointerları

```cpp
#include <iostream>
using namespace std;

// Çeşitli matrix işlemleri
void matrixTopla(int (*a)[3], int (*b)[3], int (*sonuc)[3], int satir) {
    for(int i = 0; i < satir; i++) {
        for(int j = 0; j < 3; j++) {
            sonuc[i][j] = a[i][j] + b[i][j];
        }
    }
}

void matrixYazdir(int (*matrix)[3], int satir, const string& isim) {
    cout << isim << ":" << endl;
    for(int i = 0; i < satir; i++) {
        for(int j = 0; j < 3; j++) {
            cout << matrix[i][j] << "\t";
        }
        cout << endl;
    }
    cout << endl;
}

int main() {
    cout << "=== Çok Boyutlu Dizi Pointerları ===" << endl;
    
    // 3x3 matrixler
    int matrixA[2][3] = {{1, 2, 3}, {4, 5, 6}};
    int matrixB[2][3] = {{7, 8, 9}, {10, 11, 12}};
    int sonuc[2][3];
    
    matrixYazdir(matrixA, 2, "Matrix A");
    matrixYazdir(matrixB, 2, "Matrix B");
    
    matrixTopla(matrixA, matrixB, sonuc, 2);
    matrixYazdir(sonuc, 2, "A + B");
    
    // 3D dizi örneği
    cout << "=== 3D Dizi Örneği ===" << endl;
    int dizi3D[2][3][4];
    
    // 3D diziyi doldur
    int sayac = 1;
    for(int i = 0; i < 2; i++) {
        for(int j = 0; j < 3; j++) {
            for(int k = 0; k < 4; k++) {
                dizi3D[i][j][k] = sayac++;
            }
        }
    }
    
    // 3D diziyi yazdır
    cout << "3D dizi içeriği:" << endl;
    for(int i = 0; i < 2; i++) {
        cout << "Katman " << i << ":" << endl;
        for(int j = 0; j < 3; j++) {
            for(int k = 0; k < 4; k++) {
                cout << dizi3D[i][j][k] << "\t";
            }
            cout << endl;
        }
        cout << endl;
    }
    
    // Pointer ile 3D dizi erişimi
    int (*ptr3D)[3][4] = dizi3D;
    cout << "Pointer ile erişim - ptr3D[1][2][3] = " << ptr3D[1][2][3] << endl;
    
    return 0;
}
```

---

## Dinamik Bellek Yönetimi

### new ve delete Operatörleri

```cpp
#include <iostream>
#include <memory>
using namespace std;

// Bellek sızıntısı tespit etme yardımcı sınıfı
class BellekTakipci {
private:
    static int ayrilmisBlokSayisi;
    static size_t toplamBoyut;

public:
    static void* operator new(size_t boyut) {
        ayrilmisBlokSayisi++;
        toplamBoyut += boyut;
        void* ptr = malloc(boyut);
        cout << "Bellek ayrıldı: " << boyut << " byte, adres: " << ptr << endl;
        return ptr;
    }
    
    static void operator delete(void* ptr) {
        ayrilmisBlokSayisi--;
        cout << "Bellek serbest bırakıldı, adres: " << ptr << endl;
        free(ptr);
    }
    
    static void durumYazdir() {
        cout << "Ayrılmış blok sayısı: " << ayrilmisBlokSayisi << endl;
        cout << "Toplam boyut: " << toplamBoyut << " byte" << endl;
    }
};

int BellekTakipci::ayrilmisBlokSayisi = 0;
size_t BellekTakipci::toplamBoyut = 0;

class TestSinifi : public BellekTakipci {
private:
    int deger;
    string isim;

public:
    TestSinifi(int d, const string& i) : deger(d), isim(i) {
        cout << "TestSinifi oluşturuldu: " << isim << " = " << deger << endl;
    }
    
    ~TestSinifi() {
        cout << "TestSinifi yok edildi: " << isim << endl;
    }
    
    void bilgiYazdir() const {
        cout << isim << ": " << deger << endl;
    }
};

int main() {
    cout << "=== Dinamik Bellek Yönetimi ===" << endl;
    
    // 1. Tekil nesne oluşturma
    cout << "\n--- Tekil Nesne ---" << endl;
    TestSinifi* nesne1 = new TestSinifi(42, "Nesne1");
    nesne1->bilgiYazdir();
    BellekTakipci::durumYazdir();
    
    delete nesne1;
    BellekTakipci::durumYazdir();
    
    // 2. Dizi oluşturma
    cout << "\n--- Dinamik Dizi ---" << endl;
    int boyut = 5;
    int* dinamikDizi = new int[boyut];
    
    for(int i = 0; i < boyut; i++) {
        dinamikDizi[i] = (i + 1) * 10;
    }
    
    cout << "Dinamik dizi: ";
    for(int i = 0; i < boyut; i++) {
        cout << dinamikDizi[i] << " ";
    }
    cout << endl;
    
    delete[] dinamikDizi; // Dikkat: delete[] kullanımı!
    
    // 3. Nesne dizisi
    cout << "\n--- Nesne Dizisi ---" << endl;
    TestSinifi* nesneDizisi = new TestSinifi[3] {
        TestSinifi(10, "Eleman0"),
        TestSinifi(20, "Eleman1"),
        TestSinifi(30, "Eleman2")
    };
    
    for(int i = 0; i < 3; i++) {
        nesneDizisi[i].bilgiYazdir();
    }
    
    delete[] nesneDizisi;
    BellekTakipci::durumYazdir();
    
    // 4. Placement new örneği
    cout << "\n--- Placement New ---" << endl;
    char buffer[sizeof(TestSinifi)];
    TestSinifi* placementNesne = new(buffer) TestSinifi(99, "PlacementNesne");
    placementNesne->bilgiYazdir();
    placementNesne->~TestSinifi(); // Manuel destructor çağrısı
    
    return 0;
}
```

### Smart Pointerlar ile Modern C++

```cpp
#include <iostream>
#include <memory>
#include <vector>
using namespace std;

class Kaynak {
private:
    string isim;
    static int sayac;

public:
    Kaynak(const string& i) : isim(i) {
        cout << "Kaynak oluşturuldu: " << isim << " (ID: " << ++sayac << ")" << endl;
    }
    
    ~Kaynak() {
        cout << "Kaynak yok edildi: " << isim << endl;
    }
    
    void kullan() const {
        cout << "Kaynak kullanılıyor: " << isim << endl;
    }
    
    string getIsim() const { return isim; }
};

int Kaynak::sayac = 0;

int main() {
    cout << "=== Smart Pointerlar ===" << endl;
    
    // 1. unique_ptr - Tekil sahiplik
    cout << "\n--- unique_ptr ---" << endl;
    {
        unique_ptr<Kaynak> uniquePtr = make_unique<Kaynak>("UniqueKaynak");
        uniquePtr->kullan();
        
        // Sahiplik transferi
        unique_ptr<Kaynak> digerPtr = move(uniquePtr);
        if (!uniquePtr) {
            cout << "uniquePtr artık nullptr" << endl;
        }
        digerPtr->kullan();
    } // digerPtr otomatik olarak yok edilir
    
    // 2. shared_ptr - Paylaşımlı sahiplik
    cout << "\n--- shared_ptr ---" << endl;
    shared_ptr<Kaynak> sharedPtr1;
    {
        shared_ptr<Kaynak> sharedPtr2 = make_shared<Kaynak>("SharedKaynak");
        cout << "Reference count: " << sharedPtr2.use_count() << endl;
        
        sharedPtr1 = sharedPtr2; // Sahipliği paylaş
        cout << "Reference count: " << sharedPtr2.use_count() << endl;
        sharedPtr2->kullan();
    } // sharedPtr2 scope'dan çıkar ama nesne hâlâ yaşıyor
    
    cout << "Reference count: " << sharedPtr1.use_count() << endl;
    sharedPtr1->kullan();
    sharedPtr1.reset(); // Manuel olarak serbest bırak
    
    // 3. weak_ptr - Döngüsel referans problemi çözümü
    cout << "\n--- weak_ptr ---" << endl;
    shared_ptr<Kaynak> strongPtr = make_shared<Kaynak>("WeakKaynak");
    weak_ptr<Kaynak> weakPtr = strongPtr;
    
    cout << "Strong ref count: " << strongPtr.use_count() << endl;
    cout << "Weak ref expired: " << (weakPtr.expired() ? "Evet" : "Hayır") << endl;
    
    if (auto lockedPtr = weakPtr.lock()) {
        lockedPtr->kullan();
    }
    
    strongPtr.reset();
    cout << "Strong ptr reset sonrası - Weak ref expired: " << (weakPtr.expired() ? "Evet" : "Hayır") << endl;
    
    // 4. Smart pointer dizisi
    cout << "\n--- Smart Pointer Dizisi ---" << endl;
    vector<unique_ptr<Kaynak>> kaynaklar;
    
    for(int i = 0; i < 3; i++) {
        kaynaklar.push_back(make_unique<Kaynak>("Kaynak" + to_string(i)));
    }
    
    for(const auto& kaynak : kaynaklar) {
        kaynak->kullan();
    }
    
    cout << "Scope sonunda tüm kaynaklar otomatik olarak temizlenecek..." << endl;
    
    return 0;
}
```

---

## Pointerlar Arası Karşılaştırma

### Karşılaştırma Operatörleri

```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "=== Pointer Karşılaştırmaları ===" << endl;
    
    int dizi[] = {10, 20, 30, 40, 50};
    int* ptr1 = &dizi[0];
    int* ptr2 = &dizi[2];
    int* ptr3 = &dizi[0];
    
    // 1. Eşitlik karşılaştırması
    cout << "=== Eşitlik Karşılaştırması ===" << endl;
    cout << "ptr1 == ptr3: " << (ptr1 == ptr3 ? "true" : "false") << endl;
    cout << "ptr1 == ptr2: " << (ptr1 == ptr2 ? "true" : "false") << endl;
    cout << "ptr1 != ptr2: " << (ptr1 != ptr2 ? "true" : "false") << endl;
    
    // 2. Büyüklük karşılaştırması (aynı dizi içinde)
    cout << "\n=== Büyüklük Karşılaştırması ===" << endl;
    cout << "ptr1 < ptr2: " << (ptr1 < ptr2 ? "true" : "false") << endl;
    cout << "ptr2 > ptr1: " << (ptr2 > ptr1 ? "true" : "false") << endl;
    cout << "ptr1 <= ptr3: " << (ptr1 <= ptr3 ? "true" : "false") << endl;
    
    // 3. Pointer aritmetiği ile karşılaştırma
    cout << "\n=== Pointer Aritmetiği ile Karşılaştırma ===" << endl;
    cout << "ptr2 - ptr1 = " << (ptr2 - ptr1) << " eleman" << endl;
    cout << "ptr1 + 2 == ptr2: " << ((ptr1 + 2) == ptr2 ? "true" : "false") << endl;
    
    // 4. nullptr karşılaştırması
    cout << "\n=== nullptr Karşılaştırması ===" << endl;
    int* nullPtr = nullptr;
    cout << "nullPtr == nullptr: " << (nullPtr == nullptr ? "true" : "false") << endl;
    cout << "ptr1 != nullptr: " << (ptr1 != nullptr ? "true" : "false") << endl;
    
    // 5. Pratik örnek: Dizi sınırları kontrolü
    cout << "\n=== Dizi Sınırları Kontrolü ===" << endl;
    int* baslangic = dizi;
    int* son = dizi + 5; // Son elementten bir sonrası
    
    auto guvenliErisim = [baslangic, son](int* ptr) {
        if (ptr >= baslangic && ptr < son) {
            cout << "Güvenli erişim: *ptr = " << *ptr << endl;
        } else {
            cout << "Güvensiz erişim! Pointer dizi sınırları dışında." << endl;
        }
    };
    
    guvenliErisim(ptr1);        // Güvenli
    guvenliErisim(ptr2);        // Güvenli
    guvenliErisim(dizi + 10);   // Güvensiz
    
    return 0;
}
```

### Pointer Sıralama ve Arama

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

struct Kisi {
    string isim;
    int yas;
    double maas;
    
    Kisi(const string& i, int y, double m) : isim(i), yas(y), maas(m) {}
    
    void yazdir() const {
        cout << isim << " (Yaş: " << yas << ", Maaş: " << maas << ")" << endl;
    }
};

int main() {
    cout << "=== Pointer Sıralama ve Arama ===" << endl;
    
    // Kişi nesneleri oluştur
    vector<Kisi> kisiler = {
        Kisi("Ali", 25, 5000),
        Kisi("Ayşe", 30, 7000),
        Kisi("Mehmet", 22, 4500),
        Kisi("Fatma", 35, 8500),
        Kisi("Can", 28, 6000)
    };
    
    // Pointer vektörü oluştur
    vector<Kisi*> kisiPtrleri;
    for(auto& kisi : kisiler) {
        kisiPtrleri.push_back(&kisi);
    }
    
    cout << "Orijinal sıra:" << endl;
    for(const auto& kisiPtr : kisiPtrleri) {
        kisiPtr->yazdir();
    }
    
    // 1. Yaşa göre sıralama
    cout << "\n=== Yaşa Göre Sıralama ===" << endl;
    sort(kisiPtrleri.begin(), kisiPtrleri.end(), 
         [](const Kisi* a, const Kisi* b) {
             return a->yas < b->yas;
         });
    
    for(const auto& kisiPtr : kisiPtrleri) {
        kisiPtr->yazdir();
    }
    
    // 2. Maaşa göre sıralama (büyükten küçüğe)
    cout << "\n=== Maaşa Göre Sıralama (Büyükten Küçüğe) ===" << endl;
    sort(kisiPtrleri.begin(), kisiPtrleri.end(),
         [](const Kisi* a, const Kisi* b) {
             return a->maas > b->maas;
         });
    
    for(const auto& kisiPtr : kisiPtrleri) {
        kisiPtr->yazdir();
    }
    
    // 3. İsme göre arama
    cout << "\n=== İsme Göre Arama ===" << endl;
    string arananIsim = "Ayşe";
    auto bulunan = find_if(kisiPtrleri.begin(), kisiPtrleri.end(),
                          [&arananIsim](const Kisi* kisi) {
                              return kisi->isim == arananIsim;
                          });
    
    if (bulunan != kisiPtrleri.end()) {
        cout << "Bulunan kişi: ";
        (*bulunan)->yazdir();
    } else {
        cout << arananIsim << " bulunamadı." << endl;
    }
    
    // 4. Belirli maaş aralığındaki kişiler
    cout << "\n=== 5000-7000 Arası Maaş ===" << endl;
    vector<Kisi*> filtrelenmis;
    copy_if(kisiPtrleri.begin(), kisiPtrleri.end(),
            back_inserter(filtrelenmis),
            [](const Kisi* kisi) {
                return kisi->maas >= 5000 && kisi->maas <= 7000;
            });
    
    for(const auto& kisiPtr : filtrelenmis) {
        kisiPtr->yazdir();
    }
    
    return 0;
}
```

---

## İyi Uygulamalar ve Güvenlik

### Güvenli Pointer Kullanımı

```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <stdexcept>
using namespace std;

// RAII prensibini uygulayan güvenli pointer wrapper
template<typename T>
class GuvenliPtr {
private:
    T* ptr;
    bool sahiplik;

public:
    // Constructor
    explicit GuvenliPtr(T* p = nullptr, bool sahip = true) 
        : ptr(p), sahiplik(sahip) {}
    
    // Copy constructor (disabled)
    GuvenliPtr(const GuvenliPtr&) = delete;
    
    // Move constructor
    GuvenliPtr(GuvenliPtr&& other) noexcept 
        : ptr(other.ptr), sahiplik(other.sahiplik) {
        other.ptr = nullptr;
        other.sahiplik = false;
    }
    
    // Destructor
    ~GuvenliPtr() {
        if (sahiplik && ptr) {
            delete ptr;
        }
    }
    
    // Assignment operators
    GuvenliPtr& operator=(const GuvenliPtr&) = delete;
    GuvenliPtr& operator=(GuvenliPtr&& other) noexcept {
        if (this != &other) {
            if (sahiplik && ptr) {
                delete ptr;
            }
            ptr = other.ptr;
            sahiplik = other.sahiplik;
            other.ptr = nullptr;
            other.sahiplik = false;
        }
        return *this;
    }
    
    // Pointer operations
    T* operator->() const {
        if (!ptr) {
            throw runtime_error("Null pointer erişimi!");
        }
        return ptr;
    }
    
    T& operator*() const {
        if (!ptr) {
            throw runtime_error("Null pointer dereference!");
        }
        return *ptr;
    }
    
    // Utility functions
    T* get() const { return ptr; }
    bool isNull() const { return ptr == nullptr; }
    void reset(T* newPtr = nullptr) {
        if (sahiplik && ptr) {
            delete ptr;
        }
        ptr = newPtr;
    }
    
    T* release() {
        T* temp = ptr;
        ptr = nullptr;
        sahiplik = false;
        return temp;
    }
};

// Test sınıfı
class TestSinifi {
private:
    int deger;
    string isim;

public:
    TestSinifi(int d, const string& i) : deger(d), isim(i) {
        cout << "TestSinifi oluşturuldu: " << isim << endl;
    }
    
    ~TestSinifi() {
        cout << "TestSinifi yok edildi: " << isim << endl;
    }
    
    void goster() const {
        cout << isim << ": " << deger << endl;
    }
    
    int getDeger() const { return deger; }
};

// Güvenlik kontrolleri
class PointerGuvenlik {
public:
    // 1. Null pointer kontrolü
    template<typename T>
    static bool nullKontrol(T* ptr, const string& mesaj = "") {
        if (ptr == nullptr) {
            cout << "HATA: Null pointer! " << mesaj << endl;
            return false;
        }
        return true;
    }
    
    // 2. Dizi sınırları kontrolü
    template<typename T>
    static bool sinirKontrol(T* ptr, T* baslangic, T* son, const string& mesaj = "") {
        if (ptr < baslangic || ptr >= son) {
            cout << "HATA: Dizi sınırları dışında erişim! " << mesaj << endl;
            return false;
        }
        return true;
    }
    
    // 3. Güvenli dizi erişimi
    template<typename T>
    static T* guvenliErisim(T* dizi, size_t indeks, size_t boyut) {
        if (dizi == nullptr) {
            cout << "HATA: Null dizi!" << endl;
            return nullptr;
        }
        if (indeks >= boyut) {
            cout << "HATA: İndeks sınır dışı! İndeks: " << indeks 
                 << ", Boyut: " << boyut << endl;
            return nullptr;
        }
        return &dizi[indeks];
    }
};

int main() {
    cout << "=== Güvenli Pointer Kullanımı ===" << endl;
    
    // 1. GuvenliPtr kullanımı
    cout << "\n--- GuvenliPtr Örneği ---" << endl;
    try {
        GuvenliPtr<TestSinifi> guvenliPtr(new TestSinifi(42, "GuvenliNesne"));
        guvenliPtr->goster();
        
        // Move semantics
        GuvenliPtr<TestSinifi> digerPtr = move(guvenliPtr);
        if (guvenliPtr.isNull()) {
            cout << "Orijinal pointer artık null" << endl;
        }
        digerPtr->goster();
        
        // Null erişim testi
        GuvenliPtr<TestSinifi> nullPtr;
        try {
            nullPtr->goster(); // Exception fırlatılacak
        } catch (const exception& e) {
            cout << "Yakalanan hata: " << e.what() << endl;
        }
        
    } catch (const exception& e) {
        cout << "Genel hata: " << e.what() << endl;
    }
    
    // 2. Güvenlik kontrolleri
    cout << "\n--- Güvenlik Kontrolleri ---" << endl;
    int dizi[] = {1, 2, 3, 4, 5};
    int* ptr = dizi;
    
    // Null kontrol
    PointerGuvenlik::nullKontrol(ptr, "ptr kontrolü");
    PointerGuvenlik::nullKontrol<int>(nullptr, "null ptr kontrolü");
    
    // Sınır kontrol
    PointerGuvenlik::sinirKontrol(ptr + 2, dizi, dizi + 5, "Geçerli erişim");
    PointerGuvenlik::sinirKontrol(ptr + 10, dizi, dizi + 5, "Geçersiz erişim");
    
    // Güvenli dizi erişimi
    int* guvenliEleman = PointerGuvenlik::guvenliErisim(dizi, 2, 5);
    if (guvenliEleman) {
        cout << "Güvenli erişim sonucu: " << *guvenliEleman << endl;
    }
    
    PointerGuvenlik::guvenliErisim(dizi, 10, 5); // Hata verecek
    
    // 3. Modern C++ smart pointers
    cout << "\n--- Modern Smart Pointers ---" << endl;
    
    // unique_ptr ile güvenli kaynak yönetimi
    auto uniqueNesne = make_unique<TestSinifi>(100, "UniqueNesne");
    uniqueNesne->goster();
    
    // shared_ptr ile paylaşımlı sahiplik
    auto sharedNesne = make_shared<TestSinifi>(200, "SharedNesne");
    {
        auto kopyaPtr = sharedNesne;
        cout << "Reference count: " << sharedNesne.use_count() << endl;
    }
    cout << "Scope sonrası reference count: " << sharedNesne.use_count() << endl;
    
    cout << "\n--- Program Sonu ---" << endl;
    
    return 0;
}
```

### Performans Optimizasyonu

```cpp
#include <iostream>
#include <vector>
#include <chrono>
#include <algorithm>
#include <memory>
using namespace std;
using namespace chrono;

// Performans ölçüm yardımcısı
class PerformansOlcucu {
private:
    high_resolution_clock::time_point baslangic;
    string islem;

public:
    PerformansOlcucu(const string& islemAdi) : islem(islemAdi) {
        baslangic = high_resolution_clock::now();
    }
    
    ~PerformansOlcucu() {
        auto bitis = high_resolution_clock::now();
        auto sure = duration_cast<microseconds>(bitis - baslangic);
        cout << islem << " süresi: " << sure.count() << " mikrosaniye" << endl;
    }
};

// Test verileri
struct BuyukVeri {
    int id;
    double deger;
    string isim;
    int dizi[100];
    
    BuyukVeri(int i = 0) : id(i), deger(i * 3.14), isim("Veri" + to_string(i)) {
        for(int j = 0; j < 100; j++) {
            dizi[j] = i + j;
        }
    }
    
    // Copy constructor (yavaş)
    BuyukVeri(const BuyukVeri& other) 
        : id(other.id), deger(other.deger), isim(other.isim) {
        for(int i = 0; i < 100; i++) {
            dizi[i] = other.dizi[i];
        }
    }
};

int main() {
    cout << "=== Pointer Performans Optimizasyonu ===" << endl;
    
    const int ELEMAN_SAYISI = 10000;
    
    // Test verileri oluştur
    vector<BuyukVeri> veriler;
    veriler.reserve(ELEMAN_SAYISI);
    for(int i = 0; i < ELEMAN_SAYISI; i++) {
        veriler.emplace_back(i);
    }
    
    // 1. Değere göre kopyalama (yavaş)
    cout << "\n--- Değere Göre Kopyalama ---" << endl;
    {
        PerformansOlcucu olcucu("Değere göre kopyalama");
        vector<BuyukVeri> kopyalar;
        kopyalar.reserve(ELEMAN_SAYISI);
        
        for(const auto& veri : veriler) {
            kopyalar.push_back(veri); // Tam kopyalama
        }
    }
    
    // 2. Pointer kullanımı (hızlı)
    cout << "\n--- Pointer Kullanımı ---" << endl;
    {
        PerformansOlcucu olcucu("Pointer kullanımı");
        vector<BuyukVeri*> pointerlar;
        pointerlar.reserve(ELEMAN_SAYISI);
        
        for(auto& veri : veriler) {
            pointerlar.push_back(&veri); // Sadece adres kopyalama
        }
    }
    
    // 3. Sıralama performansı karşılaştırması
    cout << "\n--- Sıralama Performansı ---" << endl;
    
    // Değer ile sıralama
    {
        PerformansOlcucu olcucu("Değer ile sıralama");
        vector<BuyukVeri> siralanacak = veriler; // Kopyalama
        sort(siralanacak.begin(), siralanacak.end(),
             [](const BuyukVeri& a, const BuyukVeri& b) {
                 return a.id > b.id;
             });
    }
    
    // Pointer ile sıralama
    {
        PerformansOlcucu olcucu("Pointer ile sıralama");
        vector<BuyukVeri*> pointerlar;
        for(auto& veri : veriler) {
            pointerlar.push_back(&veri);
        }
        
        sort(pointerlar.begin(), pointerlar.end(),
             [](const BuyukVeri* a, const BuyukVeri* b) {
                 return a->id > b->id;
             });
    }
    
    // 4. Cache-friendly erişim
    cout << "\n--- Cache Performance ---" << endl;
    
    // Sequential erişim (cache-friendly)
    {
        PerformansOlcucu olcucu("Sequential erişim");
        long toplam = 0;
        for(const auto& veri : veriler) {
            toplam += veri.id;
        }
        cout << "Toplam (sequential): " << toplam << endl;
    }
    
    // Random erişim (cache-unfriendly)
    {
        PerformansOlcucu olcucu("Random pointer erişim");
        vector<BuyukVeri*> randomPointerlar;
        for(auto& veri : veriler) {
            randomPointerlar.push_back(&veri);
        }
        
        // Karıştır
        random_shuffle(randomPointerlar.begin(), randomPointerlar.end());
        
        long toplam = 0;
        for(const auto* ptr : randomPointerlar) {
            toplam += ptr->id;
        }
        cout << "Toplam (random): " << toplam << endl;
    }
    
    // 5. Memory prefetching örneği
    cout << "\n--- Memory Prefetching ---" << endl;
    {
        PerformansOlcucu olcucu("Prefetch ile erişim");
        long toplam = 0;
        
        for(size_t i = 0; i < veriler.size(); i++) {
            // Bir sonraki elementi prefetch et
            if(i + 1 < veriler.size()) {
                __builtin_prefetch(&veriler[i + 1], 0, 1);
            }
            
            toplam += veriler[i].id;
        }
        cout << "Toplam (prefetch): " << toplam << endl;
    }
    
    // 6. Smart pointer performans karşılaştırması
    cout << "\n--- Smart Pointer Performansı ---" << endl;
    
    // Raw pointer
    {
        PerformansOlcucu olcucu("Raw pointer");
        vector<BuyukVeri*> rawPtrs;
        for(auto& veri : veriler) {
            rawPtrs.push_back(&veri);
        }
        
        long toplam = 0;
        for(auto* ptr : rawPtrs) {
            toplam += ptr->id;
        }
    }
    
    // shared_ptr
    {
        PerformansOlcucu olcucu("shared_ptr");
        vector<shared_ptr<BuyukVeri>> sharedPtrs;
        for(auto& veri : veriler) {
            sharedPtrs.push_back(make_shared<BuyukVeri>(veri));
        }
        
        long toplam = 0;
        for(const auto& ptr : sharedPtrs) {
            toplam += ptr->id;
        }
    }
    
    cout << "\n--- Performans Testleri Tamamlandı ---" << endl;
    
    return 0;
}
```

---

## Özet

Pointerlar, C++'ın en güçlü özelliklerinden biridir ve doğru kullanıldığında:

### Avantajları:
- **Performans**: Büyük veri yapılarını kopyalamak yerine adreslerini geçirebiliriz
- **Esneklik**: Dinamik bellek yönetimi ve polimorfizm mümkün
- **Bellek Kontrolü**: Manuel bellek yönetimi ile optimize edilmiş programlar

### Dikkat Edilmesi Gerekenler:
- **Null Pointer Kontrolü**: Her zaman null kontrolü yapın
- **Bellek Sızıntısı**: `new` ile ayrılan her bellek `delete` ile serbest bırakılmalı
- **Dangling Pointerlar**: Silinmiş nesnelere işaret eden pointerlardan kaçının
- **Array Bounds**: Dizi sınırlarını aşmayın

### Modern C++ Önerileri:
- Raw pointer yerine **smart pointer** kullanın (`unique_ptr`, `shared_ptr`)
- **RAII** prensibini uygulayın
- **Range-based for** döngüleri tercih edin
- **Auto** keyword'ü ile tip çıkarımından yararlanın

Pointerlar güçlü bir araç olmakla birlikte dikkatli kullanılması gereken bir özelliktir. Modern C++ ile birlikte gelen smart pointerlar ve güvenlik önlemleri, pointer kullanımını daha güvenli hale getirmiştir.