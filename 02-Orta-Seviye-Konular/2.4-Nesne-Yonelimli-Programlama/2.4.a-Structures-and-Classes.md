# Structures and Classes

## İçindekiler
1. [Struct ve Class Nedir?](#struct-ve-class-nedir)
2. [Temel Farklar](#temel-farklar)
3. [Struct Kullanımı](#struct-kullanımı)
4. [Class Kullanımı](#class-kullanımı)
5. [Erişim Belirleyiciler](#erişim-belirleyiciler)
6. [Constructor ve Destructor](#constructor-ve-destructor)
7. [Member Functions](#member-functions)
8. [Static Members](#static-members)
9. [Friend Functions](#friend-functions)
10. [Pratik Örnekler](#pratik-örnekler)

---

## Struct ve Class Nedir?

**Struct** ve **Class**, C++'da kullanıcı tanımlı veri türleri oluşturmak için kullanılan temel yapılardır. Her ikisi de veri ve fonksiyonları bir arada gruplandırma imkanı sağlar.

### Temel Kavramlar

```cpp
#include <iostream>
#include <string>
using namespace std;

// Basit struct örneği
struct Nokta {
    int x, y;
    
    void yazdir() {
        cout << "(" << x << ", " << y << ")" << endl;
    }
};

// Basit class örneği
class Dikdortgen {
private:
    int genislik, yukseklik;
    
public:
    Dikdortgen(int g, int y) : genislik(g), yukseklik(y) {}
    
    int alanHesapla() {
        return genislik * yukseklik;
    }
    
    void bilgiYazdir() {
        cout << "Genişlik: " << genislik << ", Yükseklik: " << yukseklik << endl;
        cout << "Alan: " << alanHesapla() << endl;
    }
};

int main() {
    cout << "=== Struct ve Class Temel Kullanım ===" << endl;
    
    // Struct kullanımı
    Nokta nokta1;
    nokta1.x = 10;
    nokta1.y = 20;
    cout << "Nokta 1: ";
    nokta1.yazdir();
    
    // Class kullanımı
    Dikdortgen dikdortgen(15, 25);
    dikdortgen.bilgiYazdir();
    
    return 0;
}
```

---

## Temel Farklar

### Erişim Düzeyi Farkları

```cpp
#include <iostream>
using namespace std;

// STRUCT - Varsayılan erişim: public
struct OgrenciStruct {
    string isim;        // public (varsayılan)
    int yas;           // public (varsayılan)
    double not_ort;    // public (varsayılan)
    
private:
    string sifre;      // private olarak belirtildi
    
public:
    void bilgiGoster() {
        cout << "Öğrenci: " << isim << ", Yaş: " << yas << ", Not Ort: " << not_ort << endl;
    }
    
    void sifreAyarla(const string& yeni_sifre) {
        sifre = yeni_sifre;
    }
};

// CLASS - Varsayılan erişim: private
class OgrenciClass {
    string isim;       // private (varsayılan)
    int yas;          // private (varsayılan)
    double not_ort;   // private (varsayılan)
    string sifre;     // private (varsayılan)
    
public:
    // Constructor
    OgrenciClass(const string& ad, int y, double not) 
        : isim(ad), yas(y), not_ort(not) {}
    
    // Public member functions
    void bilgiGoster() const {
        cout << "Öğrenci: " << isim << ", Yaş: " << yas << ", Not Ort: " << not_ort << endl;
    }
    
    void sifreAyarla(const string& yeni_sifre) {
        sifre = yeni_sifre;
    }
    
    // Getter functions
    string getIsim() const { return isim; }
    int getYas() const { return yas; }
    double getNotOrt() const { return not_ort; }
};

int main() {
    cout << "=== Struct vs Class Erişim Farkları ===" << endl;
    
    // Struct kullanımı
    OgrenciStruct ogrenci_struct;
    ogrenci_struct.isim = "Ali";     // Doğrudan erişim (public)
    ogrenci_struct.yas = 20;         // Doğrudan erişim (public)
    ogrenci_struct.not_ort = 85.5;   // Doğrudan erişim (public)
    ogrenci_struct.bilgiGoster();
    
    // Class kullanımı
    OgrenciClass ogrenci_class("Ayşe", 21, 92.3);
    // ogrenci_class.isim = "Deneme";  // HATA! private member
    cout << "Class öğrenci ismi: " << ogrenci_class.getIsim() << endl;
    ogrenci_class.bilgiGoster();
    
    return 0;
}
```

### Kalıtım Farkları

```cpp
#include <iostream>
using namespace std;

// Base struct - Varsayılan kalıtım: public
struct TemelStruct {
protected:
    string turu;
    
public:
    TemelStruct(const string& t) : turu(t) {}
    virtual void bilgiYazdir() {
        cout << "Tür: " << turu << endl;
    }
};

// Base class - Varsayılan kalıtım: private
class TemelClass {
protected:
    string turu;
    
public:
    TemelClass(const string& t) : turu(t) {}
    virtual void bilgiYazdir() {
        cout << "Tür: " << turu << endl;
    }
};

// Struct inheritance - public by default
struct HayvanStruct : TemelStruct {
    string isim;
    
    HayvanStruct(const string& ad) : TemelStruct("Hayvan"), isim(ad) {}
    
    void bilgiYazdir() override {
        TemelStruct::bilgiYazdir();
        cout << "İsim: " << isim << endl;
    }
};

// Class inheritance - private by default, so we need to specify public
class HayvanClass : public TemelClass {
private:
    string isim;
    
public:
    HayvanClass(const string& ad) : TemelClass("Hayvan"), isim(ad) {}
    
    void bilgiYazdir() override {
        TemelClass::bilgiYazdir();
        cout << "İsim: " << isim << endl;
    }
    
    string getIsim() const { return isim; }
};

int main() {
    cout << "=== Struct vs Class Kalıtım Farkları ===" << endl;
    
    HayvanStruct hayvan_struct("Minnoş");
    cout << "Struct Hayvan:" << endl;
    hayvan_struct.bilgiYazdir();
    
    HayvanClass hayvan_class("Karabaş");
    cout << "\nClass Hayvan:" << endl;
    hayvan_class.bilgiYazdir();
    
    return 0;
}
```

---

## Struct Kullanımı

### Veri Yapıları için Struct

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Coordinate struct
struct Koordinat {
    double x, y, z;
    
    Koordinat() : x(0), y(0), z(0) {}
    Koordinat(double x_val, double y_val, double z_val) 
        : x(x_val), y(y_val), z(z_val) {}
    
    // Operatör overloading
    Koordinat operator+(const Koordinat& other) const {
        return Koordinat(x + other.x, y + other.y, z + other.z);
    }
    
    Koordinat operator-(const Koordinat& other) const {
        return Koordinat(x - other.x, y - other.y, z - other.z);
    }
    
    double mesafe(const Koordinat& other) const {
        double dx = x - other.x;
        double dy = y - other.y;
        double dz = z - other.z;
        return sqrt(dx*dx + dy*dy + dz*dz);
    }
    
    void yazdir() const {
        cout << "(" << x << ", " << y << ", " << z << ")";
    }
};

// Renk struct
struct Renk {
    unsigned char r, g, b, a;
    
    Renk() : r(0), g(0), b(0), a(255) {}
    Renk(unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha = 255)
        : r(red), g(green), b(blue), a(alpha) {}
    
    void yazdir() const {
        cout << "RGBA(" << (int)r << ", " << (int)g << ", " << (int)b << ", " << (int)a << ")";
    }
    
    bool operator==(const Renk& other) const {
        return r == other.r && g == other.g && b == other.b && a == other.a;
    }
};

// Vertex struct (3D grafik için)
struct Vertex {
    Koordinat pozisyon;
    Koordinat normal;
    Renk renk;
    
    Vertex() {}
    Vertex(const Koordinat& pos, const Koordinat& norm, const Renk& col)
        : pozisyon(pos), normal(norm), renk(col) {}
    
    void yazdir() const {
        cout << "Vertex[Pos: ";
        pozisyon.yazdir();
        cout << ", Normal: ";
        normal.yazdir();
        cout << ", Renk: ";
        renk.yazdir();
        cout << "]";
    }
};

int main() {
    cout << "=== Struct Veri Yapıları ===" << endl;
    
    // Koordinat kullanımı
    Koordinat nokta1(1.5, 2.0, 3.5);
    Koordinat nokta2(4.0, 6.0, 8.0);
    
    cout << "Nokta 1: ";
    nokta1.yazdir();
    cout << endl;
    
    cout << "Nokta 2: ";
    nokta2.yazdir();
    cout << endl;
    
    Koordinat toplam = nokta1 + nokta2;
    cout << "Toplam: ";
    toplam.yazdir();
    cout << endl;
    
    cout << "Mesafe: " << nokta1.mesafe(nokta2) << endl;
    
    // Vertex kullanımı
    vector<Vertex> vertices;
    vertices.emplace_back(
        Koordinat(0, 0, 0),
        Koordinat(0, 0, 1),
        Renk(255, 0, 0)
    );
    vertices.emplace_back(
        Koordinat(1, 0, 0),
        Koordinat(0, 0, 1),
        Renk(0, 255, 0)
    );
    vertices.emplace_back(
        Koordinat(0.5, 1, 0),
        Koordinat(0, 0, 1),
        Renk(0, 0, 255)
    );
    
    cout << "\nVertex listesi:" << endl;
    for(size_t i = 0; i < vertices.size(); i++) {
        cout << "Vertex " << i << ": ";
        vertices[i].yazdir();
        cout << endl;
    }
    
    return 0;
}
```

### Configuration ve Settings için Struct

```cpp
#include <iostream>
#include <string>
#include <fstream>
using namespace std;

// Game settings struct
struct OyunAyarlari {
    // Graphics settings
    int cozunurluk_genislik = 1920;
    int cozunurluk_yukseklik = 1080;
    bool tam_ekran = false;
    int fps_limit = 60;
    float brightness = 1.0f;
    
    // Audio settings
    float master_ses = 100.0f;
    float muzik_ses = 80.0f;
    float efekt_ses = 90.0f;
    bool ses_acik = true;
    
    // Control settings
    string hareket_tuslari[4] = {"W", "A", "S", "D"};
    string aksyon_tusu = "SPACE";
    float mouse_hassasiyet = 1.0f;
    
    void varsayilanAyarlar() {
        cozunurluk_genislik = 1920;
        cozunurluk_yukseklik = 1080;
        tam_ekran = false;
        fps_limit = 60;
        brightness = 1.0f;
        master_ses = 100.0f;
        muzik_ses = 80.0f;
        efekt_ses = 90.0f;
        ses_acik = true;
        hareket_tuslari[0] = "W";
        hareket_tuslari[1] = "A";
        hareket_tuslari[2] = "S";
        hareket_tuslari[3] = "D";
        aksyon_tusu = "SPACE";
        mouse_hassasiyet = 1.0f;
    }
    
    void ayarlariGoster() const {
        cout << "=== Oyun Ayarları ===" << endl;
        cout << "Çözünürlük: " << cozunurluk_genislik << "x" << cozunurluk_yukseklik << endl;
        cout << "Tam Ekran: " << (tam_ekran ? "Evet" : "Hayır") << endl;
        cout << "FPS Limit: " << fps_limit << endl;
        cout << "Parlaklık: " << brightness << endl;
        cout << "Master Ses: " << master_ses << "%" << endl;
        cout << "Müzik Ses: " << muzik_ses << "%" << endl;
        cout << "Efekt Ses: " << efekt_ses << "%" << endl;
        cout << "Ses Açık: " << (ses_acik ? "Evet" : "Hayır") << endl;
        cout << "Hareket Tuşları: " << hareket_tuslari[0] << ", " << hareket_tuslari[1] 
             << ", " << hareket_tuslari[2] << ", " << hareket_tuslari[3] << endl;
        cout << "Aksiyon Tuşu: " << aksyon_tusu << endl;
        cout << "Mouse Hassasiyet: " << mouse_hassasiyet << endl;
    }
    
    bool dosyadanYukle(const string& dosyaAdi) {
        ifstream dosya(dosyaAdi);
        if(!dosya.is_open()) {
            cout << "Ayar dosyası bulunamadı, varsayılan ayarlar kullanılıyor." << endl;
            return false;
        }
        
        string satir;
        while(getline(dosya, satir)) {
            size_t esittir_pos = satir.find('=');
            if(esittir_pos != string::npos) {
                string anahtar = satir.substr(0, esittir_pos);
                string deger = satir.substr(esittir_pos + 1);
                
                if(anahtar == "genislik") cozunurluk_genislik = stoi(deger);
                else if(anahtar == "yukseklik") cozunurluk_yukseklik = stoi(deger);
                else if(anahtar == "tam_ekran") tam_ekran = (deger == "1");
                else if(anahtar == "fps_limit") fps_limit = stoi(deger);
                else if(anahtar == "brightness") brightness = stof(deger);
                else if(anahtar == "master_ses") master_ses = stof(deger);
                else if(anahtar == "muzik_ses") muzik_ses = stof(deger);
                else if(anahtar == "efekt_ses") efekt_ses = stof(deger);
                else if(anahtar == "ses_acik") ses_acik = (deger == "1");
                else if(anahtar == "mouse_hassasiyet") mouse_hassasiyet = stof(deger);
            }
        }
        
        dosya.close();
        return true;
    }
    
    bool dosyayaKaydet(const string& dosyaAdi) const {
        ofstream dosya(dosyaAdi);
        if(!dosya.is_open()) {
            cout << "Ayar dosyası kaydedilemedi!" << endl;
            return false;
        }
        
        dosya << "genislik=" << cozunurluk_genislik << endl;
        dosya << "yukseklik=" << cozunurluk_yukseklik << endl;
        dosya << "tam_ekran=" << (tam_ekran ? 1 : 0) << endl;
        dosya << "fps_limit=" << fps_limit << endl;
        dosya << "brightness=" << brightness << endl;
        dosya << "master_ses=" << master_ses << endl;
        dosya << "muzik_ses=" << muzik_ses << endl;
        dosya << "efekt_ses=" << efekt_ses << endl;
        dosya << "ses_acik=" << (ses_acik ? 1 : 0) << endl;
        dosya << "mouse_hassasiyet=" << mouse_hassasiyet << endl;
        
        dosya.close();
        return true;
    }
};

int main() {
    cout << "=== Configuration Struct Örneği ===" << endl;
    
    OyunAyarlari ayarlar;
    
    // Varsayılan ayarları göster
    ayarlar.ayarlariGoster();
    
    // Ayarları değiştir
    ayarlar.cozunurluk_genislik = 2560;
    ayarlar.cozunurluk_yukseklik = 1440;
    ayarlar.tam_ekran = true;
    ayarlar.master_ses = 75.0f;
    
    cout << "\n--- Değiştirilmiş Ayarlar ---" << endl;
    ayarlar.ayarlariGoster();
    
    // Dosyaya kaydet
    if(ayarlar.dosyayaKaydet("ayarlar.txt")) {
        cout << "\nAyarlar dosyaya kaydedildi." << endl;
    }
    
    // Yeni struct oluştur ve dosyadan yükle
    OyunAyarlari yeniAyarlar;
    yeniAyarlar.varsayilanAyarlar();
    
    if(yeniAyarlar.dosyadanYukle("ayarlar.txt")) {
        cout << "\n--- Dosyadan Yüklenen Ayarlar ---" << endl;
        yeniAyarlar.ayarlariGoster();
    }
    
    return 0;
}
```

---

## Class Kullanımı

### Encapsulation (Kapsülleme) Örneği

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class BankaHesabi {
private:
    string hesap_numarasi;
    string hesap_sahibi;
    double bakiye;
    vector<string> islem_gecmisi;
    static int toplam_hesap_sayisi;
    
    // Private helper function
    void islemKaydet(const string& islem) {
        islem_gecmisi.push_back(islem);
        if(islem_gecmisi.size() > 100) {
            islem_gecmisi.erase(islem_gecmisi.begin());
        }
    }
    
    string formatPara(double miktar) const {
        return to_string(miktar) + " TL";
    }

public:
    // Constructor
    BankaHesabi(const string& hesap_no, const string& sahip, double baslangic_bakiye = 0.0) 
        : hesap_numarasi(hesap_no), hesap_sahibi(sahip), bakiye(baslangic_bakiye) {
        toplam_hesap_sayisi++;
        islemKaydet("Hesap açıldı. Başlangıç bakiyesi: " + formatPara(baslangic_bakiye));
    }
    
    // Destructor
    ~BankaHesabi() {
        toplam_hesap_sayisi--;
        cout << "Hesap kapatıldı: " << hesap_numarasi << endl;
    }
    
    // Public interface methods
    bool paraYatir(double miktar) {
        if(miktar <= 0) {
            cout << "Geçersiz miktar!" << endl;
            return false;
        }
        
        bakiye += miktar;
        islemKaydet("Para yatırıldı: " + formatPara(miktar) + 
                   " - Yeni bakiye: " + formatPara(bakiye));
        return true;
    }
    
    bool paraCek(double miktar) {
        if(miktar <= 0) {
            cout << "Geçersiz miktar!" << endl;
            return false;
        }
        
        if(miktar > bakiye) {
            cout << "Yetersiz bakiye!" << endl;
            return false;
        }
        
        bakiye -= miktar;
        islemKaydet("Para çekildi: " + formatPara(miktar) + 
                   " - Yeni bakiye: " + formatPara(bakiye));
        return true;
    }
    
    bool havaleYap(BankaHesabi& hedef_hesap, double miktar) {
        if(paraCek(miktar)) {
            hedef_hesap.paraYatir(miktar);
            islemKaydet("Havale yapıldı: " + formatPara(miktar) + 
                       " -> " + hedef_hesap.getHesapNumarasi());
            hedef_hesap.islemKaydet("Havale alındı: " + formatPara(miktar) + 
                                   " <- " + hesap_numarasi);
            return true;
        }
        return false;
    }
    
    // Getter methods
    string getHesapNumarasi() const { return hesap_numarasi; }
    string getHesapSahibi() const { return hesap_sahibi; }
    double getBakiye() const { return bakiye; }
    static int getToplam Hesap_sayisi() { return toplam_hesap_sayisi; }
    
    void hesapOzeti() const {
        cout << "\n=== Hesap Özeti ===" << endl;
        cout << "Hesap No: " << hesap_numarasi << endl;
        cout << "Hesap Sahibi: " << hesap_sahibi << endl;
        cout << "Güncel Bakiye: " << formatPara(bakiye) << endl;
    }
    
    void islemGecmisiGoster(int son_n_islem = 5) const {
        cout << "\n=== Son " << son_n_islem << " İşlem ===" << endl;
        int baslangic = max(0, (int)islem_gecmisi.size() - son_n_islem);
        for(int i = baslangic; i < islem_gecmisi.size(); i++) {
            cout << (i + 1) << ". " << islem_gecmisi[i] << endl;
        }
    }
};

// Static member initialization
int BankaHesabi::toplam_hesap_sayisi = 0;

int main() {
    cout << "=== Banka Hesabı Class Örneği ===" << endl;
    
    // Hesapları oluştur
    BankaHesabi hesap1("123456789", "Ali Veli", 1000.0);
    BankaHesabi hesap2("987654321", "Ayşe Yılmaz", 500.0);
    
    cout << "Toplam hesap sayısı: " << BankaHesabi::getToplam Hesap_sayisi() << endl;
    
    // İşlemler yap
    hesap1.paraYatir(250.0);
    hesap1.paraCek(100.0);
    hesap1.havaleYap(hesap2, 200.0);
    
    hesap2.paraYatir(50.0);
    hesap2.paraCek(300.0);
    
    // Hesap özetlerini göster
    hesap1.hesapOzeti();
    hesap1.islemGecmisiGoster();
    
    hesap2.hesapOzeti();
    hesap2.islemGecmisiGoster();
    
    cout << "\nToplam hesap sayısı: " << BankaHesabi::getToplam Hesap_sayisi() << endl;
    
    return 0;
}
```

### Composition ve Aggregation

```cpp
#include <iostream>
#include <vector>
#include <memory>
using namespace std;

// Motor class - Composition için
class Motor {
private:
    int guc;
    string tipi;
    bool calisiyorMu;
    
public:
    Motor(int g, const string& t) : guc(g), tipi(t), calisiyorMu(false) {
        cout << "Motor oluşturuldu: " << tipi << " (" << guc << " HP)" << endl;
    }
    
    ~Motor() {
        cout << "Motor yok edildi: " << tipi << endl;
    }
    
    void calistir() {
        calisiyorMu = true;
        cout << tipi << " motor çalıştırıldı." << endl;
    }
    
    void durdur() {
        calisiyorMu = false;
        cout << tipi << " motor durduruldu." << endl;
    }
    
    bool getCalisiyorMu() const { return calisiyorMu; }
    int getGuc() const { return guc; }
    string getTipi() const { return tipi; }
};

// Lastik class - Composition için
class Lastik {
private:
    string marka;
    int cap;
    bool patlamis;
    
public:
    Lastik(const string& m, int c) : marka(m), cap(c), patlamis(false) {}
    
    void patla() { patlamis = true; }
    void tamir() { patlamis = false; }
    
    bool getPatlamis() const { return patlamis; }
    string getMarka() const { return marka; }
    int getCap() const { return cap; }
};

// Kişi class - Aggregation için
class Kisi {
private:
    string isim;
    int yas;
    
public:
    Kisi(const string& ad, int y) : isim(ad), yas(y) {
        cout << "Kişi oluşturuldu: " << isim << endl;
    }
    
    ~Kisi() {
        cout << "Kişi destructor: " << isim << endl;
    }
    
    string getIsim() const { return isim; }
    int getYas() const { return yas; }
    
    void bilgiGoster() const {
        cout << "İsim: " << isim << ", Yaş: " << yas << endl;
    }
};

// Araba class - Composition ve Aggregation örneği
class Araba {
private:
    string marka;
    string model;
    unique_ptr<Motor> motor;        // Composition - Motor araba olmadan var olamaz
    vector<unique_ptr<Lastik>> lastikler; // Composition
    vector<Kisi*> yolcular;         // Aggregation - Kişiler araba olmadan da var olabilir
    Kisi* sahip;                    // Aggregation
    
public:
    Araba(const string& mrk, const string& mdl, int motor_guc, const string& motor_tipi)
        : marka(mrk), model(mdl), sahip(nullptr) {
        
        // Motor oluştur (Composition)
        motor = make_unique<Motor>(motor_guc, motor_tipi);
        
        // Lastikleri oluştur (Composition)
        for(int i = 0; i < 4; i++) {
            lastikler.push_back(make_unique<Lastik>("Michelin", 17));
        }
        
        cout << "Araba oluşturuldu: " << marka << " " << model << endl;
    }
    
    ~Araba() {
        cout << "Araba yok edildi: " << marka << " " << model << endl;
        // Motor ve lastikler otomatik olarak yok edilir (unique_ptr)
        // Yolcular ve sahip YOK EDİLMEZ (sadece referansları temizlenir)
        yolcular.clear();
        sahip = nullptr;
    }
    
    void sahipAta(Kisi* yeni_sahip) {
        sahip = yeni_sahip;
        cout << yeni_sahip->getIsim() << " arabanın sahibi oldu." << endl;
    }
    
    void yolcuEkle(Kisi* yolcu) {
        if(yolcular.size() < 5) {
            yolcular.push_back(yolcu);
            cout << yolcu->getIsim() << " arabaya bindi." << endl;
        } else {
            cout << "Araba dolu!" << endl;
        }
    }
    
    void yolcuCikar(Kisi* yolcu) {
        auto it = find(yolcular.begin(), yolcular.end(), yolcu);
        if(it != yolcular.end()) {
            yolcular.erase(it);
            cout << yolcu->getIsim() << " arabadan indi." << endl;
        }
    }
    
    void calistir() {
        if(motor) {
            motor->calistir();
            cout << marka << " " << model << " hareket ediyor." << endl;
        }
    }
    
    void durdur() {
        if(motor) {
            motor->durdur();
            cout << marka << " " << model << " durdu." << endl;
        }
    }
    
    void durumGoster() const {
        cout << "\n=== " << marka << " " << model << " Durumu ===" << endl;
        
        if(motor) {
            cout << "Motor: " << motor->getTipi() << " (" << motor->getGuc() << " HP) - ";
            cout << (motor->getCalisiyorMu() ? "Çalışıyor" : "Durgun") << endl;
        }
        
        cout << "Lastikler: " << lastikler.size() << " adet" << endl;
        
        if(sahip) {
            cout << "Sahip: " << sahip->getIsim() << endl;
        }
        
        cout << "Yolcu sayısı: " << yolcular.size() << endl;
        for(const auto* yolcu : yolcular) {
            cout << "  - " << yolcu->getIsim() << endl;
        }
    }
};

int main() {
    cout << "=== Composition ve Aggregation Örneği ===" << endl;
    
    // Kişileri oluştur (Bağımsız yaşam döngüsü)
    Kisi* ali = new Kisi("Ali", 30);
    Kisi* ayse = new Kisi("Ayşe", 25);
    Kisi* mehmet = new Kisi("Mehmet", 35);
    
    {
        // Araba oluştur
        Araba araba("Toyota", "Corolla", 120, "Benzinli");
        
        // Sahip ata ve yolcu ekle
        araba.sahipAta(ali);
        araba.yolcuEkle(ayse);
        araba.yolcuEkle(mehmet);
        
        araba.durumGoster();
        
        araba.calistir();
        araba.durdur();
        
        araba.yolcuCikar(mehmet);
        araba.durumGoster();
        
        cout << "\nAraba scope'dan çıkıyor..." << endl;
    } // Araba burada yok edilir, motor ve lastikler de yok edilir
      // Ama kişiler hâlâ yaşıyor (Aggregation)
    
    cout << "\nKişiler hâlâ yaşıyor:" << endl;
    ali->bilgiGoster();
    ayse->bilgiGoster();
    mehmet->bilgiGoster();
    
    // Kişileri manuel olarak sil
    delete ali;
    delete ayse;
    delete mehmet;
    
    return 0;
}
```

---

## Erişim Belirleyiciler

### Public, Private, Protected Detaylı Kullanım

```cpp
#include <iostream>
#include <string>
using namespace std;

class TemelSinif {
private:
    string gizli_bilgi;           // Sadece bu sınıftan erişilebilir
    
protected:
    string korunmus_bilgi;        // Bu sınıf ve türetilmiş sınıflardan erişilebilir
    
    void koruma li_method() {      // Türetilmiş sınıflardan çağrılabilir
        cout << "Korunmuş method çağrıldı" << endl;
    }
    
public:
    string genel_bilgi;           // Her yerden erişilebilir
    
    TemelSinif() {
        gizli_bilgi = "Bu bilgi gizli";
        korunmus_bilgi = "Bu bilgi korunmuş";
        genel_bilgi = "Bu bilgi genel";
    }
    
    void genel_method() {         // Her yerden çağrılabilir
        cout << "Genel method çağrıldı" << endl;
        gizli_method();           // Private method'u çağırabilir
    }
    
    // Getter/Setter for private member
    string getGizliBilgi() const { 
        return gizli_bilgi; 
    }
    
    void setGizliBilgi(const string& yeni_bilgi) {
        if(!yeni_bilgi.empty()) {  // Validation
            gizli_bilgi = yeni_bilgi;
        }
    }

private:
    void gizli_method() {         // Sadece bu sınıftan çağrılabilir
        cout << "Gizli method çağrıldı" << endl;
    }
};

class TuretilmisSinif : public TemelSinif {
private:
    string ozel_bilgi;
    
public:
    TuretilmisSinif() {
        ozel_bilgi = "Türetilmiş sınıfa özel bilgi";
        
        // Erişim örnekleri
        genel_bilgi = "Değiştirildi";         // ✅ Public - erişilebilir
        korunmus_bilgi = "Değiştirildi";      // ✅ Protected - erişilebilir
        // gizli_bilgi = "Değiştirildi";      // ❌ Private - erişilemez!
    }
    
    void tum_bilgileri_goster() {
        cout << "=== Türetilmiş Sınıf Bilgileri ===" << endl;
        cout << "Genel Bilgi: " << genel_bilgi << endl;
        cout << "Korunmuş Bilgi: " << korunmus_bilgi << endl;
        cout << "Gizli Bilgi: " << getGizliBilgi() << endl; // Getter ile erişim
        cout << "Özel Bilgi: " << ozel_bilgi << endl;
        
        // Method çağırma örnekleri
        genel_method();           // ✅ Public - çağrılabilir
        korunmus_method();        // ✅ Protected - çağrılabilir
        // gizli_method();        // ❌ Private - çağrılamaz!
    }
};

// Friend function örneği
class GizliVeriler {
private:
    int super_gizli_sayi = 42;
    string super_gizli_metin = "Çok gizli";
    
public:
    GizliVeriler() {}
    
    // Friend function declaration
    friend void gizli_verileri_goster(const GizliVeriler& obj);
    friend class GizliVerilereErisim;  // Friend class
};

// Friend function definition
void gizli_verileri_goster(const GizliVeriler& obj) {
    cout << "Friend function erişimi:" << endl;
    cout << "Gizli sayı: " << obj.super_gizli_sayi << endl;        // Private'a erişim!
    cout << "Gizli metin: " << obj.super_gizli_metin << endl;       // Private'a erişim!
}

// Friend class
class GizliVerilereErisim {
public:
    void verileri_manipule_et(GizliVeriler& obj) {
        cout << "Friend class erişimi:" << endl;
        obj.super_gizli_sayi = 100;                    // Private değişkeni değiştir
        obj.super_gizli_metin = "Değiştirildi";        // Private değişkeni değiştir
        cout << "Veriler değiştirildi!" << endl;
    }
};

int main() {
    cout << "=== Erişim Belirleyiciler Örneği ===" << endl;
    
    // Temel sınıf kullanımı
    TemelSinif temel;
    cout << "Genel bilgi: " << temel.genel_bilgi << endl;           // ✅ Public
    // cout << temel.korunmus_bilgi << endl;                         // ❌ Protected
    // cout << temel.gizli_bilgi << endl;                            // ❌ Private
    cout << "Gizli bilgi (getter ile): " << temel.getGizliBilgi() << endl;
    
    temel.genel_method();                                           // ✅ Public method
    // temel.korunmus_method();                                     // ❌ Protected method
    // temel.gizli_method();                                        // ❌ Private method
    
    cout << "\n" << string(50, '-') << "\n" << endl;
    
    // Türetilmiş sınıf kullanımı
    TuretilmisSinif turetilmis;
    turetilmis.tum_bilgileri_goster();
    
    cout << "\n" << string(50, '-') << "\n" << endl;
    
    // Friend function ve class kullanımı
    GizliVeriler gizli_obj;
    
    gizli_verileri_goster(gizli_obj);                              // Friend function
    
    GizliVerilereErisim erisim_obj;
    erisim_obj.verileri_manipule_et(gizli_obj);                    // Friend class
    
    gizli_verileri_goster(gizli_obj);                              // Değişiklikleri göster
    
    return 0;
}
```

---

## Constructor ve Destructor

### Constructor Türleri ve Kullanımı

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class Ogrenci {
private:
    string isim;
    int yas;
    vector<int> notlar;
    double* dinamik_veriler;
    static int toplam_ogrenci_sayisi;
    
public:
    // 1. Default Constructor
    Ogrenci() {
        cout << "Default constructor çağrıldı" << endl;
        isim = "Bilinmeyen";
        yas = 0;
        dinamik_veriler = new double[10];
        for(int i = 0; i < 10; i++) {
            dinamik_veriler[i] = 0.0;
        }
        toplam_ogrenci_sayisi++;
    }
    
    // 2. Parametreli Constructor
    Ogrenci(const string& ad, int y) {
        cout << "Parametreli constructor çağrıldı: " << ad << endl;
        isim = ad;
        yas = y;
        dinamik_veriler = new double[10];
        for(int i = 0; i < 10; i++) {
            dinamik_veriler[i] = 0.0;
        }
        toplam_ogrenci_sayisi++;
    }
    
    // 3. Constructor with initializer list (önerilen yöntem)
    Ogrenci(const string& ad, int y, const vector<int>& ogrenci_notlari) 
        : isim(ad), yas(y), notlar(ogrenci_notlari) {
        cout << "Initializer list constructor çağrıldı: " << ad << endl;
        dinamik_veriler = new double[10];
        for(int i = 0; i < 10; i++) {
            dinamik_veriler[i] = i * 1.5;
        }
        toplam_ogrenci_sayisi++;
    }
    
    // 4. Copy Constructor
    Ogrenci(const Ogrenci& other) 
        : isim(other.isim), yas(other.yas), notlar(other.notlar) {
        cout << "Copy constructor çağrıldı: " << other.isim << endl;
        
        // Deep copy for dynamic memory
        dinamik_veriler = new double[10];
        for(int i = 0; i < 10; i++) {
            dinamik_veriler[i] = other.dinamik_veriler[i];
        }
        toplam_ogrenci_sayisi++;
    }
    
    // 5. Move Constructor (C++11)
    Ogrenci(Ogrenci&& other) noexcept 
        : isim(move(other.isim)), yas(other.yas), notlar(move(other.notlar)) {
        cout << "Move constructor çağrıldı" << endl;
        
        // Move dynamic memory
        dinamik_veriler = other.dinamik_veriler;
        other.dinamik_veriler = nullptr;
        other.yas = 0;
        toplam_ogrenci_sayisi++;
    }
    
    // Destructor
    ~Ogrenci() {
        cout << "Destructor çağrıldı: " << isim << endl;
        delete[] dinamik_veriler;
        toplam_ogrenci_sayisi--;
    }
    
    // Assignment operators
    Ogrenci& operator=(const Ogrenci& other) {
        cout << "Copy assignment çağrıldı" << endl;
        if(this != &other) {
            isim = other.isim;
            yas = other.yas;
            notlar = other.notlar;
            
            // Delete old memory and copy new
            delete[] dinamik_veriler;
            dinamik_veriler = new double[10];
            for(int i = 0; i < 10; i++) {
                dinamik_veriler[i] = other.dinamik_veriler[i];
            }
        }
        return *this;
    }
    
    Ogrenci& operator=(Ogrenci&& other) noexcept {
        cout << "Move assignment çağrıldı" << endl;
        if(this != &other) {
            // Clean up existing resources
            delete[] dinamik_veriler;
            
            // Move resources
            isim = move(other.isim);
            yas = other.yas;
            notlar = move(other.notlar);
            dinamik_veriler = other.dinamik_veriler;
            
            // Reset other object
            other.dinamik_veriler = nullptr;
            other.yas = 0;
        }
        return *this;
    }
    
    // Utility methods
    void notEkle(int not_degeri) {
        notlar.push_back(not_degeri);
    }
    
    double ortalama() const {
        if(notlar.empty()) return 0.0;
        int toplam = 0;
        for(int not_degeri : notlar) {
            toplam += not_degeri;
        }
        return static_cast<double>(toplam) / notlar.size();
    }
    
    void bilgiGoster() const {
        cout << "İsim: " << isim << ", Yaş: " << yas;
        if(!notlar.empty()) {
            cout << ", Ortalama: " << ortalama();
        }
        cout << endl;
    }
    
    static int getToplamOgrenciSayisi() {
        return toplam_ogrenci_sayisi;
    }
};

// Static member initialization
int Ogrenci::toplam_ogrenci_sayisi = 0;

// Factory function for creating students
Ogrenci ogrenciOlustur(const string& isim, int yas) {
    cout << "Factory function çağrıldı" << endl;
    return Ogrenci(isim, yas);  // Move constructor kullanılacak
}

int main() {
    cout << "=== Constructor ve Destructor Örnekleri ===" << endl;
    
    cout << "\n--- Default Constructor ---" << endl;
    Ogrenci ogrenci1;  // Default constructor
    ogrenci1.bilgiGoster();
    
    cout << "\n--- Parametreli Constructor ---" << endl;
    Ogrenci ogrenci2("Ali", 20);  // Parametreli constructor
    ogrenci2.notEkle(85);
    ogrenci2.notEkle(92);
    ogrenci2.bilgiGoster();
    
    cout << "\n--- Initializer List Constructor ---" << endl;
    vector<int> notlar = {78, 85, 91, 88};
    Ogrenci ogrenci3("Ayşe", 19, notlar);  // Initializer list constructor
    ogrenci3.bilgiGoster();
    
    cout << "\n--- Copy Constructor ---" << endl;
    Ogrenci ogrenci4 = ogrenci2;  // Copy constructor
    ogrenci4.bilgiGoster();
    
    cout << "\n--- Move Constructor (Factory) ---" << endl;
    Ogrenci ogrenci5 = ogrenciOlustur("Mehmet", 21);  // Move constructor
    ogrenci5.notEkle(95);
    ogrenci5.bilgiGoster();
    
    cout << "\n--- Assignment Operators ---" << endl;
    Ogrenci ogrenci6;
    ogrenci6 = ogrenci3;  // Copy assignment
    ogrenci6.bilgiGoster();
    
    ogrenci6 = ogrenciOlustur("Fatma", 22);  // Move assignment
    ogrenci6.bilgiGoster();
    
    cout << "\nToplam öğrenci sayısı: " << Ogrenci::getToplamOgrenciSayisi() << endl;
    
    cout << "\n--- Scope Sonunda Destructorlar Çağrılacak ---" << endl;
    
    return 0;
}
```

---

## Static Members

### Static Variables ve Functions

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <memory>
using namespace std;

class IDManager {
private:
    static int next_id;
    static vector<int> used_ids;
    
public:
    static int getNextID() {
        used_ids.push_back(next_id);
        return next_id++;
    }
    
    static void releaseID(int id) {
        auto it = find(used_ids.begin(), used_ids.end(), id);
        if(it != used_ids.end()) {
            used_ids.erase(it);
        }
    }
    
    static void showUsedIDs() {
        cout << "Kullanılan ID'ler: ";
        for(int id : used_ids) {
            cout << id << " ";
        }
        cout << endl;
    }
    
    static int getUsedIDCount() {
        return used_ids.size();
    }
};

// Static member initialization
int IDManager::next_id = 1000;
vector<int> IDManager::used_ids;

class Employee {
private:
    int employee_id;
    string name;
    string department;
    double salary;
    
    static int total_employees;
    static double total_salary_budget;
    static const double MAX_SALARY;
    
public:
    // Constructor
    Employee(const string& emp_name, const string& dept, double sal) 
        : name(emp_name), department(dept) {
        employee_id = IDManager::getNextID();
        setSalary(sal);
        total_employees++;
        cout << "Çalışan oluşturuldu: " << name << " (ID: " << employee_id << ")" << endl;
    }
    
    // Destructor
    ~Employee() {
        total_employees--;
        total_salary_budget -= salary;
        IDManager::releaseID(employee_id);
        cout << "Çalışan silindi: " << name << " (ID: " << employee_id << ")" << endl;
    }
    
    // Instance methods
    void setSalary(double new_salary) {
        if(new_salary > MAX_SALARY) {
            cout << "Uyarı: Maksimum maaş aşıldı! " << new_salary << " -> " << MAX_SALARY << endl;
            new_salary = MAX_SALARY;
        }
        
        total_salary_budget -= salary;  // Eski maaşı çıkar
        salary = new_salary;
        total_salary_budget += salary;  // Yeni maaşı ekle
    }
    
    void showInfo() const {
        cout << "ID: " << employee_id << ", İsim: " << name 
             << ", Departman: " << department << ", Maaş: " << salary << endl;
    }
    
    // Static methods
    static int getTotalEmployees() {
        return total_employees;
    }
    
    static double getTotalSalaryBudget() {
        return total_salary_budget;
    }
    
    static double getAverageSalary() {
        if(total_employees == 0) return 0.0;
        return total_salary_budget / total_employees;
    }
    
    static void showCompanyStats() {
        cout << "\n=== Şirket İstatistikleri ===" << endl;
        cout << "Toplam çalışan sayısı: " << total_employees << endl;
        cout << "Toplam maaş bütçesi: " << total_salary_budget << " TL" << endl;
        cout << "Ortalama maaş: " << getAverageSalary() << " TL" << endl;
        cout << "Maksimum maaş limiti: " << MAX_SALARY << " TL" << endl;
        IDManager::showUsedIDs();
    }
    
    // Getters
    int getID() const { return employee_id; }
    string getName() const { return name; }
    string getDepartment() const { return department; }
    double getSalary() const { return salary; }
};

// Static member initialization
int Employee::total_employees = 0;
double Employee::total_salary_budget = 0.0;
const double Employee::MAX_SALARY = 50000.0;

// Singleton pattern example with static
class Logger {
private:
    static Logger* instance;
    static bool instanceFlag;
    string log_file;
    
    // Private constructor
    Logger() {
        log_file = "system.log";
        cout << "Logger instance oluşturuldu" << endl;
    }
    
public:
    static Logger* getInstance() {
        if(!instanceFlag) {
            instance = new Logger();
            instanceFlag = true;
        }
        return instance;
    }
    
    void log(const string& message) {
        cout << "[LOG] " << message << endl;
        // Gerçek uygulamada dosyaya yazılabilir
    }
    
    static void destroyInstance() {
        if(instanceFlag) {
            delete instance;
            instance = nullptr;
            instanceFlag = false;
            cout << "Logger instance yok edildi" << endl;
        }
    }
    
    ~Logger() {
        cout << "Logger destructor çağrıldı" << endl;
    }
};

// Static member initialization for Singleton
Logger* Logger::instance = nullptr;
bool Logger::instanceFlag = false;

int main() {
    cout << "=== Static Members Örneği ===" << endl;
    
    // Initial stats
    Employee::showCompanyStats();
    
    // Create employees
    cout << "\n--- Çalışanlar Oluşturuluyor ---" << endl;
    Employee* emp1 = new Employee("Ali Veli", "IT", 15000);
    Employee* emp2 = new Employee("Ayşe Yılmaz", "HR", 12000);
    Employee* emp3 = new Employee("Mehmet Demir", "Finance", 18000);
    
    Employee::showCompanyStats();
    
    // Salary updates
    cout << "\n--- Maaş Güncellemeleri ---" << endl;
    emp1->setSalary(20000);
    emp3->setSalary(60000);  // MAX_SALARY'ı aşacak
    
    Employee::showCompanyStats();
    
    // Individual employee info
    cout << "\n--- Çalışan Bilgileri ---" << endl;
    emp1->showInfo();
    emp2->showInfo();
    emp3->showInfo();
    
    // Singleton Logger example
    cout << "\n--- Singleton Logger Örneği ---" << endl;
    Logger* logger1 = Logger::getInstance();
    Logger* logger2 = Logger::getInstance();  // Aynı instance
    
    cout << "logger1 == logger2: " << (logger1 == logger2 ? "true" : "false") << endl;
    
    logger1->log("Sistem başlatıldı");
    logger2->log("Kullanıcı giriş yaptı");  // Aynı logger instance
    
    // Clean up
    cout << "\n--- Temizlik ---" << endl;
    delete emp2;  // Bir çalışanı sil
    
    Employee::showCompanyStats();
    
    delete emp1;
    delete emp3;
    
    Employee::showCompanyStats();
    
    Logger::destroyInstance();
    
    return 0;
}
```

---

## Özet

Struct ve Class, C++'da nesne yönelimli programlamanın temel yapı taşlarıdır:

### Temel Farklar:
- **Varsayılan Erişim**: Struct → public, Class → private
- **Kalıtım**: Struct → public kalıtım, Class → private kalıtım
- **Kullanım Amacı**: Struct → veri yapıları, Class → karmaşık nesneler

### Struct Kullanım Alanları:
- **Basit veri yapıları** (Point, Color, Vertex)
- **Configuration ayarları**
- **POD (Plain Old Data) türleri**
- **C ile uyumluluk gereken durumlar**

### Class Kullanım Alanları:
- **Encapsulation** gereken durumlar
- **Karmaşık iş mantığı**
- **Inheritance** kullanımı
- **Abstract data types**

### Modern C++ Önerileri:
- **RAII** prensibi ile kaynak yönetimi
- **Smart pointer** kullanımı
- **Move semantics** ile performans optimizasyonu
- **Static member** fonksiyonları ile utility sınıfları
- **Friend** keyword'ü dikkatli kullanımı

Her iki yapı da güçlü araçlardır ve doğru bağlamda kullanıldığında etkili kod yazımına imkan sağlar!
