# Dinamik Polimorfizm (Dynamic Polymorphism)

Dinamik polimorfizm, runtime'da nesnenin gerçek tipine göre doğru fonksiyonun çağrılmasını sağlayan mekanizmadır. C++'da virtual functions ve inheritance ile gerçekleştirilir ve nesne yönelimli programlamanın en güçlü özelliklerinden biridir.

## Runtime Polymorphism Temelleri

### Dynamic Dispatch Mechanism

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <typeinfo>

// Base class - Media Player Interface
class MediaPlayer {
protected:
    std::string filename;
    double duration;  // seconds
    bool isPlaying;
    double currentPosition;
    
public:
    MediaPlayer(const std::string& file, double dur) 
        : filename(file), duration(dur), isPlaying(false), currentPosition(0.0) {
        std::cout << "MediaPlayer constructor: " << filename << std::endl;
    }
    
    virtual ~MediaPlayer() {
        std::cout << "MediaPlayer destructor: " << filename << std::endl;
    }
    
    // Pure virtual functions - define interface
    virtual void play() = 0;
    virtual void pause() = 0;
    virtual void stop() = 0;
    virtual void seek(double position) = 0;
    virtual std::string getFileType() const = 0;
    virtual void showMetadata() const = 0;
    
    // Virtual functions with default implementation
    virtual void showInfo() const {
        std::cout << "Media: " << filename 
                  << ", Duration: " << duration << "s"
                  << ", Type: " << getFileType()
                  << ", Status: " << (isPlaying ? "Playing" : "Stopped") << std::endl;
    }
    
    virtual double getProgress() const {
        return duration > 0 ? (currentPosition / duration) * 100.0 : 0.0;
    }
    
    // Non-virtual functions
    const std::string& getFilename() const { return filename; }
    double getDuration() const { return duration; }
    bool getIsPlaying() const { return isPlaying; }
    double getCurrentPosition() const { return currentPosition; }
};

// Concrete implementation - Audio Player
class AudioPlayer : public MediaPlayer {
private:
    std::string artist;
    std::string album;
    int bitrate;  // kbps
    
public:
    AudioPlayer(const std::string& file, double dur, const std::string& art, 
                const std::string& alb, int br) 
        : MediaPlayer(file, dur), artist(art), album(alb), bitrate(br) {
        std::cout << "AudioPlayer constructor: " << artist << " - " << filename << std::endl;
    }
    
    ~AudioPlayer() override {
        std::cout << "AudioPlayer destructor: " << filename << std::endl;
    }
    
    // Implement pure virtual functions
    void play() override {
        if (!isPlaying) {
            isPlaying = true;
            std::cout << "🎵 Playing audio: " << artist << " - " << filename 
                      << " (bitrate: " << bitrate << " kbps)" << std::endl;
        } else {
            std::cout << "Audio is already playing" << std::endl;
        }
    }
    
    void pause() override {
        if (isPlaying) {
            isPlaying = false;
            std::cout << "⏸️ Audio paused: " << filename << " at " << currentPosition << "s" << std::endl;
        } else {
            std::cout << "Audio is not playing" << std::endl;
        }
    }
    
    void stop() override {
        if (isPlaying) {
            isPlaying = false;
            currentPosition = 0.0;
            std::cout << "⏹️ Audio stopped: " << filename << std::endl;
        } else {
            std::cout << "Audio is already stopped" << std::endl;
        }
    }
    
    void seek(double position) override {
        if (position >= 0 && position <= duration) {
            currentPosition = position;
            std::cout << "🎯 Audio seeked to: " << position << "s in " << filename << std::endl;
        } else {
            std::cout << "Invalid seek position: " << position << "s" << std::endl;
        }
    }
    
    std::string getFileType() const override {
        return "Audio";
    }
    
    void showMetadata() const override {
        std::cout << "Audio Metadata:" << std::endl;
        std::cout << "  File: " << filename << std::endl;
        std::cout << "  Artist: " << artist << std::endl;
        std::cout << "  Album: " << album << std::endl;
        std::cout << "  Duration: " << duration << "s" << std::endl;
        std::cout << "  Bitrate: " << bitrate << " kbps" << std::endl;
    }
    
    // Audio-specific methods
    void adjustVolume(int volume) {
        std::cout << "🔊 Volume adjusted to " << volume << "% for " << filename << std::endl;
    }
    
    void showEqualizer() {
        std::cout << "🎛️ Equalizer settings for " << filename << std::endl;
    }
    
    const std::string& getArtist() const { return artist; }
    const std::string& getAlbum() const { return album; }
    int getBitrate() const { return bitrate; }
};

// Concrete implementation - Video Player
class VideoPlayer : public MediaPlayer {
private:
    std::string resolution;
    int fps;
    bool hasSubtitles;
    
public:
    VideoPlayer(const std::string& file, double dur, const std::string& res, 
                int f, bool subs) 
        : MediaPlayer(file, dur), resolution(res), fps(f), hasSubtitles(subs) {
        std::cout << "VideoPlayer constructor: " << filename << " (" << resolution << ")" << std::endl;
    }
    
    ~VideoPlayer() override {
        std::cout << "VideoPlayer destructor: " << filename << std::endl;
    }
    
    // Implement pure virtual functions
    void play() override {
        if (!isPlaying) {
            isPlaying = true;
            std::cout << "🎬 Playing video: " << filename 
                      << " (" << resolution << " @ " << fps << " FPS)" << std::endl;
        } else {
            std::cout << "Video is already playing" << std::endl;
        }
    }
    
    void pause() override {
        if (isPlaying) {
            isPlaying = false;
            std::cout << "⏸️ Video paused: " << filename << " at " << currentPosition << "s" << std::endl;
        } else {
            std::cout << "Video is not playing" << std::endl;
        }
    }
    
    void stop() override {
        if (isPlaying) {
            isPlaying = false;
            currentPosition = 0.0;
            std::cout << "⏹️ Video stopped: " << filename << std::endl;
        } else {
            std::cout << "Video is already stopped" << std::endl;
        }
    }
    
    void seek(double position) override {
        if (position >= 0 && position <= duration) {
            currentPosition = position;
            std::cout << "🎯 Video seeked to: " << position << "s in " << filename << std::endl;
        } else {
            std::cout << "Invalid seek position: " << position << "s" << std::endl;
        }
    }
    
    std::string getFileType() const override {
        return "Video";
    }
    
    void showMetadata() const override {
        std::cout << "Video Metadata:" << std::endl;
        std::cout << "  File: " << filename << std::endl;
        std::cout << "  Resolution: " << resolution << std::endl;
        std::cout << "  FPS: " << fps << std::endl;
        std::cout << "  Duration: " << duration << "s" << std::endl;
        std::cout << "  Subtitles: " << (hasSubtitles ? "Available" : "Not available") << std::endl;
    }
    
    // Video-specific methods
    void toggleFullscreen() {
        std::cout << "🖥️ Fullscreen toggled for " << filename << std::endl;
    }
    
    void changeResolution(const std::string& newRes) {
        resolution = newRes;
        std::cout << "📺 Resolution changed to " << resolution << " for " << filename << std::endl;
    }
    
    void toggleSubtitles() {
        if (hasSubtitles) {
            std::cout << "📝 Subtitles toggled for " << filename << std::endl;
        } else {
            std::cout << "No subtitles available for " << filename << std::endl;
        }
    }
    
    const std::string& getResolution() const { return resolution; }
    int getFps() const { return fps; }
    bool getHasSubtitles() const { return hasSubtitles; }
};

// Concrete implementation - Image Viewer
class ImageViewer : public MediaPlayer {
private:
    std::string dimensions;
    int colorDepth;
    std::string format;
    
public:
    ImageViewer(const std::string& file, const std::string& dims, 
                int depth, const std::string& fmt) 
        : MediaPlayer(file, 0.0), dimensions(dims), colorDepth(depth), format(fmt) {
        std::cout << "ImageViewer constructor: " << filename << " (" << dimensions << ")" << std::endl;
    }
    
    ~ImageViewer() override {
        std::cout << "ImageViewer destructor: " << filename << std::endl;
    }
    
    // Implement pure virtual functions
    void play() override {
        isPlaying = true;
        std::cout << "🖼️ Displaying image: " << filename 
                  << " (" << dimensions << ", " << colorDepth << "-bit)" << std::endl;
    }
    
    void pause() override {
        std::cout << "Images don't have pause functionality" << std::endl;
    }
    
    void stop() override {
        isPlaying = false;
        std::cout << "🚫 Image closed: " << filename << std::endl;
    }
    
    void seek(double position) override {
        std::cout << "Images don't have seek functionality" << std::endl;
    }
    
    std::string getFileType() const override {
        return "Image";
    }
    
    void showMetadata() const override {
        std::cout << "Image Metadata:" << std::endl;
        std::cout << "  File: " << filename << std::endl;
        std::cout << "  Dimensions: " << dimensions << std::endl;
        std::cout << "  Color Depth: " << colorDepth << " bits" << std::endl;
        std::cout << "  Format: " << format << std::endl;
    }
    
    double getProgress() const override {
        return isPlaying ? 100.0 : 0.0;  // Image is either shown or not
    }
    
    // Image-specific methods
    void zoom(double factor) {
        std::cout << "🔍 Zoomed to " << (factor * 100) << "% for " << filename << std::endl;
    }
    
    void rotate(int degrees) {
        std::cout << "🔄 Rotated " << degrees << " degrees for " << filename << std::endl;
    }
    
    void applyFilter(const std::string& filter) {
        std::cout << "🎨 Applied " << filter << " filter to " << filename << std::endl;
    }
    
    const std::string& getDimensions() const { return dimensions; }
    int getColorDepth() const { return colorDepth; }
    const std::string& getFormat() const { return format; }
};

// Media Library Manager - demonstrates polymorphism
class MediaLibrary {
private:
    std::vector<std::unique_ptr<MediaPlayer>> mediaFiles;
    int currentIndex;
    
public:
    MediaLibrary() : currentIndex(-1) {
        std::cout << "MediaLibrary created" << std::endl;
    }
    
    ~MediaLibrary() {
        std::cout << "MediaLibrary destroyed" << std::endl;
    }
    
    void addMedia(std::unique_ptr<MediaPlayer> media) {
        std::cout << "Added to library: " << media->getFilename() << std::endl;
        mediaFiles.push_back(std::move(media));
    }
    
    void playAll() {
        std::cout << "\n=== Playing All Media Files ===" << std::endl;
        for (auto& media : mediaFiles) {
            media->showInfo();      // Virtual dispatch
            media->showMetadata();  // Virtual dispatch
            media->play();          // Virtual dispatch
            std::cout << "Progress: " << media->getProgress() << "%" << std::endl;
            std::cout << std::endl;
        }
    }
    
    void playByIndex(size_t index) {
        if (index < mediaFiles.size()) {
            currentIndex = static_cast<int>(index);
            std::cout << "Playing media at index " << index << ":" << std::endl;
            mediaFiles[index]->play();
        } else {
            std::cout << "Invalid index: " << index << std::endl;
        }
    }
    
    void pauseCurrent() {
        if (currentIndex >= 0 && currentIndex < static_cast<int>(mediaFiles.size())) {
            mediaFiles[currentIndex]->pause();
        } else {
            std::cout << "No media currently selected" << std::endl;
        }
    }
    
    void stopAll() {
        std::cout << "\n=== Stopping All Media ===" << std::endl;
        for (auto& media : mediaFiles) {
            media->stop();  // Virtual dispatch
        }
        currentIndex = -1;
    }
    
    void showLibrary() const {
        std::cout << "\n=== Media Library Contents ===" << std::endl;
        for (size_t i = 0; i < mediaFiles.size(); ++i) {
            std::cout << "[" << i << "] ";
            mediaFiles[i]->showInfo();  // Virtual dispatch
        }
    }
    
    void searchByType(const std::string& type) const {
        std::cout << "\n=== Searching for " << type << " files ===" << std::endl;
        bool found = false;
        for (const auto& media : mediaFiles) {
            if (media->getFileType() == type) {  // Virtual dispatch
                media->showInfo();
                found = true;
            }
        }
        if (!found) {
            std::cout << "No " << type << " files found" << std::endl;
        }
    }
    
    size_t getMediaCount() const { return mediaFiles.size(); }
};

void dynamicPolymorphismDemo() {
    std::cout << "=== Dynamic Polymorphism Demo ===" << std::endl;
    
    // Create media library
    MediaLibrary library;
    
    // Add different types of media - all through base class interface
    library.addMedia(std::make_unique<AudioPlayer>("song1.mp3", 180.5, "The Beatles", "Abbey Road", 320));
    library.addMedia(std::make_unique<VideoPlayer>("movie1.mp4", 7200.0, "1920x1080", 30, true));
    library.addMedia(std::make_unique<ImageViewer>("photo1.jpg", "4000x3000", 24, "JPEG"));
    library.addMedia(std::make_unique<AudioPlayer>("song2.flac", 245.8, "Pink Floyd", "Dark Side of the Moon", 1411));
    library.addMedia(std::make_unique<VideoPlayer>("clip1.avi", 120.0, "1280x720", 24, false));
    library.addMedia(std::make_unique<ImageViewer>("image1.png", "1920x1080", 32, "PNG"));
    
    // Show library contents - polymorphic behavior
    library.showLibrary();
    
    // Play all media - each type behaves differently
    library.playAll();
    
    // Search by type - demonstrates runtime type checking
    library.searchByType("Audio");
    library.searchByType("Video");
    library.searchByType("Image");
    
    // Individual media control
    std::cout << "\n=== Individual Media Control ===" << std::endl;
    library.playByIndex(0);  // Audio
    library.pauseCurrent();
    
    library.playByIndex(1);  // Video
    library.pauseCurrent();
    
    library.playByIndex(2);  // Image
    
    // Stop all
    library.stopAll();
    
    std::cout << "\nTotal media files: " << library.getMediaCount() << std::endl;
}

int main() {
    dynamicPolymorphismDemo();
    return 0;
}
```

## Interface-Based Design

### Abstract Interfaces ve Implementation

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <algorithm>
#include <random>

// Pure interface - no data members, only pure virtual functions
class Drawable {
public:
    virtual ~Drawable() = default;
    virtual void draw() const = 0;
    virtual void move(double dx, double dy) = 0;
    virtual double getArea() const = 0;
    virtual std::string getType() const = 0;
};

// Another interface
class Colorable {
public:
    virtual ~Colorable() = default;
    virtual void setColor(const std::string& color) = 0;
    virtual std::string getColor() const = 0;
    virtual void blend(const std::string& color, double ratio) = 0;
};

// Another interface
class Transformable {
public:
    virtual ~Transformable() = default;
    virtual void scale(double factor) = 0;
    virtual void rotate(double angle) = 0;
    virtual void reflect() = 0;
};

// Base class implementing common functionality
class GeometricShape : public Drawable, public Colorable, public Transformable {
protected:
    double x, y;        // Position
    std::string color;
    double rotation;    // Angle in degrees
    double scaleFactor;
    
public:
    GeometricShape(double posX, double posY, const std::string& col) 
        : x(posX), y(posY), color(col), rotation(0.0), scaleFactor(1.0) {
        std::cout << "GeometricShape created at (" << x << ", " << y << ") with color " << color << std::endl;
    }
    
    virtual ~GeometricShape() {
        std::cout << "GeometricShape destroyed" << std::endl;
    }
    
    // Implement Drawable interface
    void move(double dx, double dy) override {
        x += dx;
        y += dy;
        std::cout << getType() << " moved to (" << x << ", " << y << ")" << std::endl;
    }
    
    // Implement Colorable interface
    void setColor(const std::string& newColor) override {
        color = newColor;
        std::cout << getType() << " color changed to " << color << std::endl;
    }
    
    std::string getColor() const override {
        return color;
    }
    
    void blend(const std::string& blendColor, double ratio) override {
        std::cout << getType() << " blending " << color << " with " << blendColor 
                  << " (ratio: " << ratio << ")" << std::endl;
        // Simplified blending - just change color if ratio > 0.5
        if (ratio > 0.5) {
            color = blendColor;
        }
    }
    
    // Implement Transformable interface
    void scale(double factor) override {
        scaleFactor *= factor;
        std::cout << getType() << " scaled by factor " << factor 
                  << " (total scale: " << scaleFactor << ")" << std::endl;
    }
    
    void rotate(double angle) override {
        rotation += angle;
        // Keep rotation in 0-360 range
        while (rotation >= 360.0) rotation -= 360.0;
        while (rotation < 0.0) rotation += 360.0;
        std::cout << getType() << " rotated by " << angle 
                  << "° (total rotation: " << rotation << "°)" << std::endl;
    }
    
    void reflect() override {
        rotation = 360.0 - rotation;
        std::cout << getType() << " reflected (new rotation: " << rotation << "°)" << std::endl;
    }
    
    // Common getters
    double getX() const { return x; }
    double getY() const { return y; }
    double getRotation() const { return rotation; }
    double getScaleFactor() const { return scaleFactor; }
    
    // Common display method
    virtual void showInfo() const {
        std::cout << getType() << " - Position: (" << x << ", " << y 
                  << "), Color: " << color 
                  << ", Rotation: " << rotation << "°"
                  << ", Scale: " << scaleFactor 
                  << ", Area: " << getArea() << std::endl;
    }
};

// Concrete implementation - Circle
class Circle : public GeometricShape {
private:
    double radius;
    
public:
    Circle(double posX, double posY, double r, const std::string& col) 
        : GeometricShape(posX, posY, col), radius(r) {
        std::cout << "Circle created with radius " << radius << std::endl;
    }
    
    ~Circle() override {
        std::cout << "Circle destroyed" << std::endl;
    }
    
    void draw() const override {
        std::cout << "Drawing " << color << " circle at (" << x << ", " << y 
                  << ") with radius " << (radius * scaleFactor) 
                  << " (rotation: " << rotation << "°)" << std::endl;
        std::cout << "    ●" << std::endl;
        std::cout << "   ○ ○" << std::endl;
        std::cout << "    ●" << std::endl;
    }
    
    double getArea() const override {
        double effectiveRadius = radius * scaleFactor;
        return 3.14159 * effectiveRadius * effectiveRadius;
    }
    
    std::string getType() const override {
        return "Circle";
    }
    
    double getRadius() const { return radius; }
    void setRadius(double r) { 
        radius = r; 
        std::cout << "Circle radius changed to " << radius << std::endl;
    }
};

// Concrete implementation - Rectangle
class Rectangle : public GeometricShape {
private:
    double width, height;
    
public:
    Rectangle(double posX, double posY, double w, double h, const std::string& col) 
        : GeometricShape(posX, posY, col), width(w), height(h) {
        std::cout << "Rectangle created with dimensions " << width << "x" << height << std::endl;
    }
    
    ~Rectangle() override {
        std::cout << "Rectangle destroyed" << std::endl;
    }
    
    void draw() const override {
        std::cout << "Drawing " << color << " rectangle at (" << x << ", " << y 
                  << ") with dimensions " << (width * scaleFactor) << "x" << (height * scaleFactor)
                  << " (rotation: " << rotation << "°)" << std::endl;
        std::cout << "┌────────┐" << std::endl;
        std::cout << "│        │" << std::endl;
        std::cout << "│        │" << std::endl;
        std::cout << "└────────┘" << std::endl;
    }
    
    double getArea() const override {
        return width * height * scaleFactor * scaleFactor;
    }
    
    std::string getType() const override {
        return "Rectangle";
    }
    
    double getWidth() const { return width; }
    double getHeight() const { return height; }
    void setDimensions(double w, double h) { 
        width = w; 
        height = h; 
        std::cout << "Rectangle dimensions changed to " << width << "x" << height << std::endl;
    }
};

// Concrete implementation - Triangle
class Triangle : public GeometricShape {
private:
    double base, height;
    
public:
    Triangle(double posX, double posY, double b, double h, const std::string& col) 
        : GeometricShape(posX, posY, col), base(b), height(h) {
        std::cout << "Triangle created with base " << base << " and height " << height << std::endl;
    }
    
    ~Triangle() override {
        std::cout << "Triangle destroyed" << std::endl;
    }
    
    void draw() const override {
        std::cout << "Drawing " << color << " triangle at (" << x << ", " << y 
                  << ") with base " << (base * scaleFactor) << " and height " << (height * scaleFactor)
                  << " (rotation: " << rotation << "°)" << std::endl;
        std::cout << "    /\\" << std::endl;
        std::cout << "   /  \\" << std::endl;
        std::cout << "  /____\\" << std::endl;
    }
    
    double getArea() const override {
        return 0.5 * base * height * scaleFactor * scaleFactor;
    }
    
    std::string getType() const override {
        return "Triangle";
    }
    
    double getBase() const { return base; }
    double getTriangleHeight() const { return height; }
    void setDimensions(double b, double h) { 
        base = b; 
        height = h; 
        std::cout << "Triangle dimensions changed to base " << base << " and height " << height << std::endl;
    }
};

// Canvas class - manages multiple drawable objects
class Canvas {
private:
    std::vector<std::unique_ptr<Drawable>> shapes;
    std::string canvasName;
    double width, height;
    
public:
    Canvas(const std::string& name, double w, double h) 
        : canvasName(name), width(w), height(h) {
        std::cout << "Canvas '" << canvasName << "' created (" << width << "x" << height << ")" << std::endl;
    }
    
    ~Canvas() {
        std::cout << "Canvas '" << canvasName << "' destroyed" << std::endl;
    }
    
    void addShape(std::unique_ptr<Drawable> shape) {
        std::cout << "Added " << shape->getType() << " to canvas '" << canvasName << "'" << std::endl;
        shapes.push_back(std::move(shape));
    }
    
    void drawAll() {
        std::cout << "\n=== Drawing Canvas '" << canvasName << "' ===" << std::endl;
        for (const auto& shape : shapes) {
            shape->draw();  // Dynamic dispatch
            std::cout << "Area: " << shape->getArea() << " square units" << std::endl;
            std::cout << std::endl;
        }
    }
    
    void moveAllShapes(double dx, double dy) {
        std::cout << "\n=== Moving All Shapes by (" << dx << ", " << dy << ") ===" << std::endl;
        for (auto& shape : shapes) {
            shape->move(dx, dy);  // Dynamic dispatch
        }
    }
    
    void showShapeInfo() {
        std::cout << "\n=== Shape Information ===" << std::endl;
        for (const auto& shape : shapes) {
            // Try to cast to GeometricShape for detailed info
            if (auto geoShape = dynamic_cast<const GeometricShape*>(shape.get())) {
                geoShape->showInfo();
            } else {
                std::cout << "Unknown shape type: " << shape->getType() << std::endl;
            }
        }
    }
    
    double getTotalArea() const {
        double total = 0.0;
        for (const auto& shape : shapes) {
            total += shape->getArea();  // Dynamic dispatch
        }
        return total;
    }
    
    void transformAll() {
        std::cout << "\n=== Applying Transformations ===" << std::endl;
        for (auto& shape : shapes) {
            // Try to cast to Transformable interface
            if (auto transformable = dynamic_cast<Transformable*>(shape.get())) {
                transformable->scale(1.2);   // Scale up by 20%
                transformable->rotate(45.0); // Rotate 45 degrees
            }
        }
    }
    
    void colorizeAll(const std::string& color) {
        std::cout << "\n=== Colorizing All Shapes to " << color << " ===" << std::endl;
        for (auto& shape : shapes) {
            // Try to cast to Colorable interface
            if (auto colorable = dynamic_cast<Colorable*>(shape.get())) {
                colorable->setColor(color);
            }
        }
    }
    
    size_t getShapeCount() const { return shapes.size(); }
    const std::string& getName() const { return canvasName; }
};

// Demonstration function for interface-based design
void interfaceBasedDesignDemo() {
    std::cout << "\n=== Interface-Based Design Demo ===" << std::endl;
    
    // Create canvas
    Canvas canvas("ArtCanvas", 800, 600);
    
    // Add different shapes - all through interface
    canvas.addShape(std::make_unique<Circle>(100, 100, 50, "red"));
    canvas.addShape(std::make_unique<Rectangle>(200, 150, 80, 60, "blue"));
    canvas.addShape(std::make_unique<Triangle>(350, 200, 70, 90, "green"));
    canvas.addShape(std::make_unique<Circle>(450, 100, 30, "yellow"));
    canvas.addShape(std::make_unique<Rectangle>(50, 300, 120, 40, "purple"));
    
    // Display initial state
    canvas.showShapeInfo();
    canvas.drawAll();
    
    std::cout << "Total area: " << canvas.getTotalArea() << " square units" << std::endl;
    
    // Demonstrate polymorphic operations
    canvas.moveAllShapes(10, 20);
    canvas.transformAll();
    canvas.colorizeAll("orange");
    
    // Draw after transformations
    canvas.drawAll();
    
    std::cout << "Total area after scaling: " << canvas.getTotalArea() << " square units" << std::endl;
    
    std::cout << "\nCanvas contains " << canvas.getShapeCount() << " shapes" << std::endl;
}

int main() {
    dynamicPolymorphismDemo();
    interfaceBasedDesignDemo();
    
    std::cout << "\n=== Dynamic Polymorphism Benefits ===" << std::endl;
    std::cout << "✓ Runtime behavior selection" << std::endl;
    std::cout << "✓ Code reusability through common interfaces" << std::endl;
    std::cout << "✓ Extensibility - new types without changing existing code" << std::endl;
    std::cout << "✓ Maintainability through loose coupling" << std::endl;
    std::cout << "✓ Plugin architecture support" << std::endl;
    
    return 0;
}
```

## Type Identification ve Dynamic Casting

### Runtime Type Information (RTTI)

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <typeinfo>

// Base class hierarchy for RTTI demonstration
class Instrument {
protected:
    std::string name;
    std::string brand;
    
public:
    Instrument(const std::string& n, const std::string& b) : name(n), brand(b) {
        std::cout << "Instrument constructor: " << brand << " " << name << std::endl;
    }
    
    virtual ~Instrument() {
        std::cout << "Instrument destructor: " << name << std::endl;
    }
    
    virtual void play() const = 0;
    virtual void tune() const = 0;
    virtual std::string getCategory() const = 0;
    
    virtual void showInfo() const {
        std::cout << "Instrument: " << brand << " " << name 
                  << " (Category: " << getCategory() << ")" << std::endl;
    }
    
    const std::string& getName() const { return name; }
    const std::string& getBrand() const { return brand; }
};

// String instruments
class StringInstrument : public Instrument {
protected:
    int numberOfStrings;
    
public:
    StringInstrument(const std::string& n, const std::string& b, int strings) 
        : Instrument(n, b), numberOfStrings(strings) {
        std::cout << "StringInstrument constructor: " << numberOfStrings << " strings" << std::endl;
    }
    
    virtual ~StringInstrument() {
        std::cout << "StringInstrument destructor" << std::endl;
    }
    
    std::string getCategory() const override {
        return "String";
    }
    
    void tune() const override {
        std::cout << "Tuning " << numberOfStrings << " strings of " << name << std::endl;
    }
    
    void changeStrings() const {
        std::cout << "Changing strings on " << name << std::endl;
    }
    
    int getNumberOfStrings() const { return numberOfStrings; }
};

class Guitar : public StringInstrument {
private:
    bool isElectric;
    
public:
    Guitar(const std::string& brand, bool electric) 
        : StringInstrument(electric ? "Electric Guitar" : "Acoustic Guitar", brand, 6), 
          isElectric(electric) {
        std::cout << "Guitar constructor: " << (electric ? "Electric" : "Acoustic") << std::endl;
    }
    
    ~Guitar() override {
        std::cout << "Guitar destructor" << std::endl;
    }
    
    void play() const override {
        std::cout << "🎸 Playing " << (isElectric ? "electric" : "acoustic") 
                  << " guitar: " << brand << " " << name << std::endl;
    }
    
    void plugIn() const {
        if (isElectric) {
            std::cout << "🔌 Plugging in electric guitar to amplifier" << std::endl;
        } else {
            std::cout << "Acoustic guitar doesn't need to be plugged in" << std::endl;
        }
    }
    
    void adjustPickups() const {
        if (isElectric) {
            std::cout << "🎛️ Adjusting pickup height on electric guitar" << std::endl;
        } else {
            std::cout << "Acoustic guitar doesn't have pickups" << std::endl;
        }
    }
    
    bool getIsElectric() const { return isElectric; }
};

class Violin : public StringInstrument {
private:
    bool hasFinetuners;
    
public:
    Violin(const std::string& brand, bool finetuners = true) 
        : StringInstrument("Violin", brand, 4), hasFinetuners(finetuners) {
        std::cout << "Violin constructor: " << (finetuners ? "with" : "without") << " fine tuners" << std::endl;
    }
    
    ~Violin() override {
        std::cout << "Violin destructor" << std::endl;
    }
    
    void play() const override {
        std::cout << "🎻 Playing violin: " << brand << " " << name << " with bow" << std::endl;
    }
    
    void useBow() const {
        std::cout << "🏹 Drawing bow across violin strings" << std::endl;
    }
    
    void adjustFineTuners() const {
        if (hasFinetuners) {
            std::cout << "🔧 Adjusting fine tuners on violin" << std::endl;
        } else {
            std::cout << "This violin doesn't have fine tuners" << std::endl;
        }
    }
    
    bool getHasFinetuners() const { return hasFinetuners; }
};

// Wind instruments
class WindInstrument : public Instrument {
protected:
    std::string material;
    
public:
    WindInstrument(const std::string& n, const std::string& b, const std::string& mat) 
        : Instrument(n, b), material(mat) {
        std::cout << "WindInstrument constructor: made of " << material << std::endl;
    }
    
    virtual ~WindInstrument() {
        std::cout << "WindInstrument destructor" << std::endl;
    }
    
    std::string getCategory() const override {
        return "Wind";
    }
    
    void tune() const override {
        std::cout << "Tuning " << name << " by adjusting embouchure and breath" << std::endl;
    }
    
    void clean() const {
        std::cout << "Cleaning " << material << " " << name << std::endl;
    }
    
    const std::string& getMaterial() const { return material; }
};

class Flute : public WindInstrument {
private:
    bool hasOpenHoles;
    
public:
    Flute(const std::string& brand, bool openHoles = false) 
        : WindInstrument("Flute", brand, "Silver"), hasOpenHoles(openHoles) {
        std::cout << "Flute constructor: " << (openHoles ? "open holes" : "closed holes") << std::endl;
    }
    
    ~Flute() override {
        std::cout << "Flute destructor" << std::endl;
    }
    
    void play() const override {
        std::cout << "🎵 Playing flute: " << brand << " " << name << " with breath control" << std::endl;
    }
    
    void adjustEmbouchure() const {
        std::cout << "👄 Adjusting embouchure for flute playing" << std::endl;
    }
    
    void coverHoles() const {
        if (hasOpenHoles) {
            std::cout << "🕳️ Covering open holes on flute for different tones" << std::endl;
        } else {
            std::cout << "This flute has closed holes" << std::endl;
        }
    }
    
    bool getHasOpenHoles() const { return hasOpenHoles; }
};

class Trumpet : public WindInstrument {
private:
    int numberOfValves;
    
public:
    Trumpet(const std::string& brand, int valves = 3) 
        : WindInstrument("Trumpet", brand, "Brass"), numberOfValves(valves) {
        std::cout << "Trumpet constructor: " << numberOfValves << " valves" << std::endl;
    }
    
    ~Trumpet() override {
        std::cout << "Trumpet destructor" << std::endl;
    }
    
    void play() const override {
        std::cout << "🎺 Playing trumpet: " << brand << " " << name << " with valves and mouthpiece" << std::endl;
    }
    
    void pressValve(int valve) const {
        if (valve >= 1 && valve <= numberOfValves) {
            std::cout << "🔽 Pressing valve " << valve << " on trumpet" << std::endl;
        } else {
            std::cout << "Invalid valve number: " << valve << std::endl;
        }
    }
    
    void mute() const {
        std::cout << "🔇 Inserting mute into trumpet bell" << std::endl;
    }
    
    int getNumberOfValves() const { return numberOfValves; }
};

// Orchestra class demonstrating RTTI and dynamic casting
class Orchestra {
private:
    std::vector<std::unique_ptr<Instrument>> instruments;
    std::string orchestraName;
    
public:
    Orchestra(const std::string& name) : orchestraName(name) {
        std::cout << "Orchestra '" << orchestraName << "' formed" << std::endl;
    }
    
    ~Orchestra() {
        std::cout << "Orchestra '" << orchestraName << "' disbanded" << std::endl;
    }
    
    void addInstrument(std::unique_ptr<Instrument> instrument) {
        std::cout << "Added " << instrument->getName() << " to " << orchestraName << std::endl;
        instruments.push_back(std::move(instrument));
    }
    
    void performConcert() {
        std::cout << "\n=== " << orchestraName << " Concert Performance ===" << std::endl;
        for (const auto& instrument : instruments) {
            instrument->showInfo();  // Virtual call
            instrument->tune();      // Virtual call
            instrument->play();      // Virtual call
            std::cout << std::endl;
        }
    }
    
    void demonstrateRTTI() {
        std::cout << "\n=== RTTI Demonstration ===" << std::endl;
        
        for (const auto& instrument : instruments) {
            std::cout << "\n--- Analyzing instrument ---" << std::endl;
            
            // typeid operator - compile-time and runtime type info
            std::cout << "typeid name: " << typeid(*instrument).name() << std::endl;
            
            // dynamic_cast for safe downcasting
            if (auto guitar = dynamic_cast<Guitar*>(instrument.get())) {
                std::cout << "✓ This is a Guitar" << std::endl;
                std::cout << "  Type: " << (guitar->getIsElectric() ? "Electric" : "Acoustic") << std::endl;
                std::cout << "  Strings: " << guitar->getNumberOfStrings() << std::endl;
                guitar->plugIn();
                guitar->adjustPickups();
                
            } else if (auto violin = dynamic_cast<Violin*>(instrument.get())) {
                std::cout << "✓ This is a Violin" << std::endl;
                std::cout << "  Strings: " << violin->getNumberOfStrings() << std::endl;
                std::cout << "  Fine tuners: " << (violin->getHasFinetuners() ? "Yes" : "No") << std::endl;
                violin->useBow();
                violin->adjustFineTuners();
                
            } else if (auto flute = dynamic_cast<Flute*>(instrument.get())) {
                std::cout << "✓ This is a Flute" << std::endl;
                std::cout << "  Material: " << flute->getMaterial() << std::endl;
                std::cout << "  Open holes: " << (flute->getHasOpenHoles() ? "Yes" : "No") << std::endl;
                flute->adjustEmbouchure();
                flute->coverHoles();
                
            } else if (auto trumpet = dynamic_cast<Trumpet*>(instrument.get())) {
                std::cout << "✓ This is a Trumpet" << std::endl;
                std::cout << "  Material: " << trumpet->getMaterial() << std::endl;
                std::cout << "  Valves: " << trumpet->getNumberOfValves() << std::endl;
                trumpet->pressValve(1);
                trumpet->mute();
            }
            
            // Test inheritance relationships
            if (auto stringInst = dynamic_cast<StringInstrument*>(instrument.get())) {
                std::cout << "  ➤ Also a StringInstrument with " << stringInst->getNumberOfStrings() << " strings" << std::endl;
                stringInst->changeStrings();
            }
            
            if (auto windInst = dynamic_cast<WindInstrument*>(instrument.get())) {
                std::cout << "  ➤ Also a WindInstrument made of " << windInst->getMaterial() << std::endl;
                windInst->clean();
            }
        }
    }
    
    void categorizeInstruments() {
        std::cout << "\n=== Instrument Categorization ===" << std::endl;
        
        int stringCount = 0, windCount = 0;
        
        for (const auto& instrument : instruments) {
            std::string category = instrument->getCategory();  // Virtual call
            
            if (category == "String") {
                stringCount++;
            } else if (category == "Wind") {
                windCount++;
            }
            
            std::cout << instrument->getBrand() << " " << instrument->getName() 
                      << " - Category: " << category << std::endl;
        }
        
        std::cout << "\nSummary:" << std::endl;
        std::cout << "String instruments: " << stringCount << std::endl;
        std::cout << "Wind instruments: " << windCount << std::endl;
        std::cout << "Total instruments: " << instruments.size() << std::endl;
    }
    
    void typeComparison() {
        std::cout << "\n=== Type Comparison Demo ===" << std::endl;
        
        if (instruments.size() >= 2) {
            const auto& inst1 = instruments[0];
            const auto& inst2 = instruments[1];
            
            std::cout << "Comparing first two instruments:" << std::endl;
            std::cout << "Instrument 1: " << inst1->getName() << " (type: " << typeid(*inst1).name() << ")" << std::endl;
            std::cout << "Instrument 2: " << inst2->getName() << " (type: " << typeid(*inst2).name() << ")" << std::endl;
            
            // Type equality comparison
            if (typeid(*inst1) == typeid(*inst2)) {
                std::cout << "✓ Same types" << std::endl;
            } else {
                std::cout << "✗ Different types" << std::endl;
            }
            
            // Category comparison
            if (inst1->getCategory() == inst2->getCategory()) {
                std::cout << "✓ Same category: " << inst1->getCategory() << std::endl;
            } else {
                std::cout << "✗ Different categories: " << inst1->getCategory() 
                          << " vs " << inst2->getCategory() << std::endl;
            }
        }
    }
    
    size_t getInstrumentCount() const { return instruments.size(); }
};

void rttiDemo() {
    std::cout << "\n=== RTTI and Dynamic Casting Demo ===" << std::endl;
    
    // Create orchestra
    Orchestra orchestra("City Symphony Orchestra");
    
    // Add various instruments
    orchestra.addInstrument(std::make_unique<Guitar>("Fender", true));   // Electric guitar
    orchestra.addInstrument(std::make_unique<Guitar>("Martin", false));  // Acoustic guitar
    orchestra.addInstrument(std::make_unique<Violin>("Stradivarius", true));
    orchestra.addInstrument(std::make_unique<Flute>("Yamaha", true));    // Open holes
    orchestra.addInstrument(std::make_unique<Trumpet>("Bach", 3));
    orchestra.addInstrument(std::make_unique<Violin>("Suzuki", false));  // No fine tuners
    
    // Demonstrate polymorphic behavior
    orchestra.performConcert();
    
    // Demonstrate RTTI and dynamic casting
    orchestra.demonstrateRTTI();
    
    // Categorize instruments
    orchestra.categorizeInstruments();
    
    // Type comparison
    orchestra.typeComparison();
    
    std::cout << "\nOrchestra has " << orchestra.getInstrumentCount() << " instruments" << std::endl;
}

int main() {
    dynamicPolymorphismDemo();
    interfaceBasedDesignDemo();
    rttiDemo();
    
    std::cout << "\n=== RTTI and Dynamic Casting Best Practices ===" << std::endl;
    std::cout << "✓ Use dynamic_cast for safe downcasting" << std::endl;
    std::cout << "✓ Always check dynamic_cast result for nullptr" << std::endl;
    std::cout << "✓ Prefer virtual functions over RTTI when possible" << std::endl;
    std::cout << "✓ Use typeid for type comparison and debugging" << std::endl;
    std::cout << "✓ Consider visitor pattern for complex type-specific operations" << std::endl;
    std::cout << "✓ RTTI has runtime overhead - use judiciously" << std::endl;
    
    return 0;
}
```

Dinamik polimorfizm, C++'da runtime'da esnek davranış sağlamanın en güçlü yoludur. Interface-based design, clean architecture ve maintainable code yazmak için kritik öneme sahiptir.
