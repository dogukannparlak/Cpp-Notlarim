# Polimorfizm Nedir ?

Polimorfizm, aynı interface'e sahip farklı türlerin, farklı davranışlar sergileyebilmesi yeteneğidir. C++'da iki ana polimorfizm türü vardır:

- **Dinamik Polimorfizm**: Virtual fonksiyonlar ile çalışma zamanında çözümlenir
- **Statik Polimorfizm**: Template'ler ve function overloading ile derleme zamanında çözümlenir

Statik polimorfizm, performans avantajı sağlarken, dinamik polimorfizm çalışma zamanı esnekliği sunar.

# Statik Polimorfizm

Statik polimorfizm, C++'da **derleyici zamanında (compile-time)** çözümlenen polimorfizm türüdür. Çalışma zamanında (runtime) herhangi bir performans maliyeti olmadan, farklı türler için farklı davranışlar sergileyebilir. Bu, dinamik polimorfizmden (virtual fonksiyonlar) farklı olarak, derleme sırasında hangi fonksiyonun çağrılacağının belirlenmesi anlamına gelir.

## Statik Polimorfizmin Türleri

C++'da statik polimorfizm başlıca şu yöntemlerle gerçekleştirilir:

1. **Function Overloading** (Fonksiyon Aşırı Yükleme)
2. **Template Specialization** (Şablon Özelleştirme)
3. **CRTP (Curiously Recurring Template Pattern)**
4. **Template Metaprogramming**

## Function Overloading ile Statik Polimorfizm

Fonksiyon overloading, en basit statik polimorfizm türüdür:

```cpp
#include <iostream>
#include <string>
using namespace std;

class Printer {
public:
    // STATIK POLIMORFİZM - Aynı fonksiyon ismi, farklı davranışlar
    // Derleyici, parametre türüne bakarak hangi fonksiyonun çağrılacağına karar verir
    // Bu karar DERLEME ZAMANINDA alınır, çalışma zamanında performans maliyeti yoktur
    
    // INTEGER türü için özelleştirilmiş yazdırma
    void print(int value) {
        cout << "Integer: " << value << endl;
        // int türündeki değerleri "Integer:" prefixi ile yazdırır
        // Örnek: print(42) -> "Integer: 42"
    }
    
    // DOUBLE türü için özelleştirilmiş yazdırma
    void print(double value) {
        cout << "Double: " << value << endl;
        // double türündeki değerleri "Double:" prefixi ile yazdırır
        // Floating-point sayılar için özel format
        // Örnek: print(3.14) -> "Double: 3.14"
    }
    
    // STRING türü için özelleştirilmiş yazdırma
    void print(const string& value) {
        cout << "String: " << value << endl;
        // string türündeki değerleri "String:" prefixi ile yazdırır
        // const reference kullanımı performans için önemli
        // Örnek: print("Merhaba") -> "String: Merhaba"
    }
    
    // CHARACTER türü için özelleştirilmiş yazdırma
    void print(char value) {
        cout << "Character: " << value << endl;
        // char türündeki değerleri "Character:" prefixi ile yazdırır
        // Tek karakterler için özel işlem
        // Örnek: print('A') -> "Character: A"
    }
    
    // ÇOKLU PARAMETRE ile overloading - Koordinat yazdırma
    void print(int x, int y) {
        cout << "Koordinat: (" << x << ", " << y << ")" << endl;
        // İki int parametre alan versiyon - koordinat sistemi
        // Aynı türde olsa bile parametre sayısı farklı olduğu için overloading mümkün
        // Örnek: print(10, 20) -> "Koordinat: (10, 20)"
    }
    
    /*
     * STATİK POLIMORFİZM AVANTAJLARI:
     * 
     * 1. PERFORMANS: Çalışma zamanında fonksiyon arama maliyeti yok
     * 2. TYP SAFETY: Derleme zamanında tür kontrolü
     * 3. INLINE OPTİMİZASYON: Derleyici fonksiyonları inline yapabilir
     * 4. NO VIRTUAL TABLE: Virtual function table overhead'i yok
     * 5. COMPILE-TIME RESOLUTION: Hangi fonksiyonun çağrılacağı derlemede belli
     * 
     * ÇALIŞMA ŞEKLİ:
     * Derleyici, fonksiyon çağrısını gördüğünde:
     * 1. Parametre türlerini analiz eder
     * 2. En uygun overload'ı seçer
     * 3. Doğrudan o fonksiyona çağrı yapar
     * 4. Çalışma zamanında hiçbir polimorfik arama yapmaz
     */
};

int main() {
    Printer p;
    
    cout << "=== STATİK POLIMORFİZM DEMO ===" << endl;
    
    // Derleyici, her çağrıda parametre türüne göre doğru fonksiyonu seçer
    // Bu seçim DERLEME ZAMANINDA yapılır!
    
    p.print(42);           // int literal -> int versiyonu çağrılır
    p.print(3.14);         // double literal -> double versiyonu çağrılır  
    p.print("Merhaba");    // string literal -> const string& versiyonu çağrılır
    p.print('A');          // char literal -> char versiyonu çağrılır
    p.print(10, 20);       // iki int -> çoklu parametre versiyonu çağrılır
    
    cout << "\n=== TÜR ANALİZİ ===" << endl;
    
    // Farklı türlerle test
    int intVar = 100;
    double doubleVar = 2.71828;
    string stringVar = "C++ Polimorfizm";
    char charVar = 'X';
    
    p.print(intVar);       // int değişken
    p.print(doubleVar);    // double değişken
    p.print(stringVar);    // string değişken
    p.print(charVar);      // char değişken
    
    // MİXED TYPES - Otomatik tür dönüşümü durumları
    cout << "\n=== OTOMATIK TÜR DÖNÜŞÜMLERİ ===" << endl;
    
    p.print(5.0f);         // float -> double'a dönüştürülür
    p.print(static_cast<int>(3.99)); // explicit cast ile int
    
    /*
     * BEKLENEN ÇIKTI:
     * === STATİK POLIMORFİZM DEMO ===
     * Integer: 42
     * Double: 3.14
     * String: Merhaba
     * Character: A
     * Koordinat: (10, 20)
     * 
     * === TÜR ANALİZİ ===
     * Integer: 100
     * Double: 2.71828
     * String: C++ Polimorfizm
     * Character: X
     * 
     * === OTOMATIK TÜR DÖNÜŞÜMLERİ ===
     * Double: 5
     * Integer: 3
     * 
     * NOT: Her çağrı derleme zamanında çözümlenmiş durumda
     * Çalışma zamanında hiçbir polimorfik arama maliyeti yoktur!
     */
    
    return 0;
}
```

## Template ile Statik Polimorfizm

Template'ler, türden bağımsız kod yazmaya olanak sağlar:

### Function Templates

Function template'ler, aynı işlevi farklı türlerle gerçekleştiren fonksiyonlar yazmak için kullanılır. Derleyici, template'i kullanıldığı her tür için ayrı bir fonksiyon oluşturur. Bu process "template instantiation" olarak adlandırılır.

**Function Template'lerin Avantajları:**
- **Code Reusability**: Tek kod, birçok tür için çalışır
- **Type Safety**: Derleme zamanında tür kontrolü yapılır  
- **Performance**: Virtual function overhead'i olmadan polimorfizm
- **Automatic Type Deduction**: Çoğu durumda tür çıkarımı otomatik

**Kullanım Alanları:**
- Generic algoritmalar (sort, find, transform vb.)
- Mathematical functions (max, min, abs vb.)
- Container operations (print, process vb.)
- Type-safe generic programming

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// GENERIC FUNCTION TEMPLATE - Türden bağımsız kod yazma
// Template, derleyicinin her tür için ayrı fonksiyon üretmesini sağlar
template<typename T>
void display(const T& value) {
    cout << "Değer: " << value << endl;
    /*
     * TEMPLATE ÇALIŞMA ŞEKLİ:
     * 1. Derleyici bu template'i görür
     * 2. Kullanıldığı her türle çağrıldığında, o tür için özel bir fonksiyon üretir
     * 3. display<int>, display<double>, display<string> gibi ayrı fonksiyonlar oluşur
     * 4. Bu process "template instantiation" olarak adlandırılır
     * 
     * AVANTAJLAR:
     * - Tek kod, birçok tür için çalışır
     * - Type-safe: Her tür için derleme zamanında kontrol
     * - Performance: Virtual function overhead'i yok
     * - Automatic type deduction: T türü otomatik çıkarılır
     */
}

// ÇOKLU TEMPLATE PARAMETRELİ FONKSİYON - Farklı türleri birleştirme
template<typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
    return a + b;
    /*
     * MODERN C++ (C++11) ÖZELLİKLERİ:
     * 1. auto: Dönüş türünü otomatik çıkarım
     * 2. decltype(a + b): a + b işleminin sonuç türünü belirler
     * 3. Trailing return type: -> decltype(a + b) syntax
     * 
     * ÖRNEK ÇALIŞMA:
     * add(5, 3.14) -> int + double = double
     * add("Hello", string(" World")) -> string concatenation
     * 
     * C++14'te daha basit yazım:
     * template<typename T, typename U>
     * auto add(T a, U b) { return a + b; }
     */
}

// TEMPLATE İLE GENERIC ALGORİTMA - Container-agnostic algorithm
template<typename T>
T findMax(const vector<T>& vec) {
    if (vec.empty()) {
        throw invalid_argument("Boş vektör!");
        // Exception handling ile güvenli kod
    }
    
    T maxVal = vec[0];    // İlk elemanı maximum olarak başlat
    for (const T& item : vec) {
        if (item > maxVal) {
            maxVal = item;  // Büyük değer bulunursa güncelle
        }
    }
    return maxVal;
    /*
     * GENERIC ALGORITHM ÖZELLİKLERİ:
     * 1. T türü herhangi bir karşılaştırılabilir tür olabilir
     * 2. operator> kullanımı gereklidir
     * 3. Copy-constructible olmalıdır (T maxVal = vec[0])
     * 4. Aynı algoritma int, double, string vs. ile çalışır
     * 
     * TEMPLATE CONSTRAINTS (Modern C++20 ile):
     * template<std::totally_ordered T>
     * T findMax(const vector<T>& vec) { ... }
     */
}

int main() {
    cout << "=== TEMPLATE FUNCTION DEMO ===" << endl;
    
    // GENERIC DISPLAY FUNCTION TEST
    cout << "\n1. Generic Display Fonksiyonu:" << endl;
    
    // Derleyici her çağrı için özel bir fonksiyon instantiate eder
    display(42);           // display<int> instantiation
    display(3.14);         // display<double> instantiation  
    display("Merhaba");    // display<const char*> instantiation
    display('X');          // display<char> instantiation
    
    // STL containers ile de çalışır
    vector<int> numbers = {1, 2, 3};
    display(numbers);      // display<vector<int>> instantiation
    
    // ÇOKLU TEMPLATE PARAMETRE TEST
    cout << "\n2. Çoklu Template Parametreli Add Fonksiyonu:" << endl;
    
    // Farklı tür kombinasyonları
    cout << "int + double: " << add(5, 3.14) << endl;           // T=int, U=double -> double
    cout << "string + string: " << add(string("C"), string("++")) << endl; // T=string, U=string -> string
    cout << "float + int: " << add(2.5f, 10) << endl;          // T=float, U=int -> float
    cout << "char + int: " << add('A', 1) << endl;             // T=char, U=int -> int ('A' + 1 = 66)
    
    // GENERIC ALGORİTMA TEST
    cout << "\n3. Generic Maximum Bulma Algoritması:" << endl;
    
    // Integer vector ile test
    vector<int> intVec = {1, 5, 3, 9, 2, 7};
    cout << "Integer vektörü: ";
    for (int val : intVec) cout << val << " ";
    cout << "\nMax int: " << findMax(intVec) << endl;
    
    // String vector ile test (lexicographic comparison)
    vector<string> stringVec = {"elma", "zebra", "armut", "çilek"};
    cout << "\nString vektörü: ";
    for (const string& str : stringVec) cout << str << " ";
    cout << "\nMax string: " << findMax(stringVec) << endl;
    
    // Double vector ile test
    vector<double> doubleVec = {3.14, 2.71, 1.41, 1.73, 0.57};
    cout << "\nDouble vektörü: ";
    for (double val : doubleVec) cout << val << " ";
    cout << "\nMax double: " << findMax(doubleVec) << endl;
    
    cout << "\n=== TEMPLATE INSTANTIATION BİLGİSİ ===" << endl;
    cout << "Derleyici bu programı derlerken şu fonksiyonları oluşturdu:" << endl;
    cout << "• display<int>(const int&)" << endl;
    cout << "• display<double>(const double&)" << endl;  
    cout << "• display<const char*>(const char* const&)" << endl;
    cout << "• display<char>(const char&)" << endl;
    cout << "• display<vector<int>>(const vector<int>&)" << endl;
    cout << "• add<int, double>(int, double)" << endl;
    cout << "• add<string, string>(string, string)" << endl;
    cout << "• findMax<int>(const vector<int>&)" << endl;
    cout << "• findMax<string>(const vector<string>&)" << endl;
    cout << "• findMax<double>(const vector<double>&)" << endl;
    
    /*
     * BEKLENEN ÇIKTI:
     * === TEMPLATE FUNCTION DEMO ===
     * 
     * 1. Generic Display Fonksiyonu:
     * Değer: 42
     * Değer: 3.14
     * Değer: Merhaba
     * Değer: X
     * Değer: 1 2 3 (vector implementation dependent)
     * 
     * 2. Çoklu Template Parametreli Add Fonksiyonu:
     * int + double: 8.14
     * string + string: C++
     * float + int: 12.5
     * char + int: 66
     * 
     * 3. Generic Maximum Bulma Algoritması:
     * Integer vektörü: 1 5 3 9 2 7 
     * Max int: 9
     * 
     * String vektörü: elma zebra armut çilek 
     * Max string: zebra
     * 
     * Double vektörü: 3.14 2.71 1.41 1.73 0.57 
     * Max double: 3.14
     */
    
    return 0;
}
```

### Class Templates

Class template'ler, farklı türlerle çalışabilen generic sınıflar oluşturmak için kullanılır. Function template'lerden farklı olarak, hem tür parametreleri hem de değer parametreleri alabilirler.

**Class Template'lerin Özellikleri:**
- **Generic Data Structures**: Container'lar, smart pointer'lar vb.
- **Type ve Value Parameters**: Hem tür hem de compile-time değer parametreleri
- **Static Member Support**: Her instantiation için ayrı static member'lar
- **Specialization Support**: Belirli türler için özel implementasyonlar

**Kullanım Alanları:**
- STL Container'ları (vector, array, map vb.)
- Smart Pointer'lar (unique_ptr, shared_ptr vb.)
- RAII Wrapper'ları
- Template Metaprogramming
- Policy-based Design Pattern'ları

```cpp
#include <iostream>
#include <stdexcept>
using namespace std;

// GENERIC CONTAINER SINIFI - Türden bağımsız veri yapısı
// Template ile hem tür (T) hem de değer (N) parametresi alır
template<typename T, size_t N>
class Array {
private:
    T data[N];    // N boyutunda T türünden sabit boyutlu dizi
    /*
     * TEMPLATE PARAMETRELERI:
     * - typename T: Herhangi bir tür (int, double, string, custom class, vs.)
     * - size_t N: Compile-time sabit (array boyutu)
     * 
     * AVANTAJLAR:
     * - Stack allocation (heap'e göre hızlı)
     * - Compile-time boyut kontrolü
     * - Cache-friendly memory layout
     * - No dynamic allocation overhead
     */
    
public:
    // ELEMENT ERİŞİMİ - Non-const version
    T& operator[](size_t index) {
        if (index >= N) {
            throw out_of_range("Index dışında!");
        }
        return data[index];
        /*
         * NON-CONST OPERATOR[] ÖZELLİKLERİ:
         * - Referans döndürür (T&)
         * - Değer değiştirmeye izin verir
         * - Bounds checking ile güvenli erişim
         * - Array syntax: arr[i] = value;
         */
    }
    
    // ELEMENT ERİŞİMİ - Const version (const correctness)
    const T& operator[](size_t index) const {
        if (index >= N) {
            throw out_of_range("Index dışında!");
        }
        return data[index];
        /*
         * CONST OPERATOR[] ÖZELLİKLERİ:
         * - Const referans döndürür (const T&)
         * - Sadece okuma erişimi
         * - Const nesnelerde çağrılabilir
         * - Değer değiştirmeye izin vermez
         */
    }
    
    // BOYUT BİLGİSİ - Compile-time constant
    constexpr size_t size() const { return N; }
    /*
     * CONSTEXPR ÖZELLİKLERİ:
     * - Compile-time'da değerlendirilebilir
     * - Template metaprogramming'de kullanılabilir
     * - Runtime maliyeti yok
     * - Static assertion'larda kullanılabilir
     */
    
    // DİZİYİ DOLDURMA - Tüm elemanları aynı değerle
    void fill(const T& value) {
        for (size_t i = 0; i < N; i++) {
            data[i] = value;    // Assignment operator kullanır
        }
        /*
         * FILL FONKSIYON ÖZELLİKLERİ:
         * - T türü copy-assignable olmalı
         * - Tüm elemanları aynı değerle doldurur
         * - memset'ten güvenli (custom types için)
         * - Constructor/destructor respectful
         */
    }
    
    // ITERATOR SUPPORT - Range-based for loop desteği
    T* begin() { return data; }                    // Non-const iterator
    T* end() { return data + N; }                  // Non-const iterator
    const T* begin() const { return data; }        // Const iterator
    const T* end() const { return data + N; }      // Const iterator
    /*
     * ITERATOR PATTERN ÖZELLİKLERİ:
     * - STL uyumlu iterator interface
     * - Range-based for loop desteği: for(auto& item : array)
     * - STL algoritmaları ile uyumlu
     * - begin()/end() fonksiyon çiftleri
     * 
     * KULLANIM ÖRNEKLERİ:
     * for(auto& item : array) { item *= 2; }
     * std::sort(array.begin(), array.end());
     * auto it = std::find(array.begin(), array.end(), value);
     */
};

// TEMPLATE SINIFINDA STATIC MEMBER - Tür başına ayrı static değişken
template<typename T>
class Counter {
private:
    static int count;    // Her T türü için ayrı bir count değişkeni
    T value;
    
public:
    Counter(T val) : value(val) { 
        count++;    // Constructor'da sayaç artırılır
    }
    
    ~Counter() { 
        count--;    // Destructor'da sayaç azaltılır
    }
    
    // Copy constructor ve assignment operator için de count yönetimi gerekli
    Counter(const Counter& other) : value(other.value) { 
        count++; 
    }
    
    Counter& operator=(const Counter& other) {
        if (this != &other) {
            value = other.value;
            // count değişmez (mevcut nesne için assignment)
        }
        return *this;
    }
    
    static int getCount() { return count; }    // Tür başına nesne sayısı
    T getValue() const { return value; }
    
    /*
     * STATIC MEMBER TEMPLATE ÖZELLİKLERİ:
     * - Her instantiated type için ayrı static değişken
     * - Counter<int>::count ve Counter<string>::count farklı değişkenler
     * - Template specialization'da da çalışır
     * - Thread-safety dikkate alınmalı (multi-threading'de)
     */
};

// STATIC MEMBER TANIMI - Template için özel syntax
template<typename T>
int Counter<T>::count = 0;    // Her T türü için 0'dan başlat
/*
 * STATIC MEMBER DEFINITION:
 * - Template class'ın dışında tanımlanmalı
 * - Her T türü için ayrı bir count değişkeni oluşur
 * - Linker tarafından doğru şekilde resolve edilir
 */

int main() {
    cout << "=== CLASS TEMPLATE DEMO ===" << endl;
    
    // FARKLI TÜRLER VE BOYUTLAR İÇİN ARRAY
    cout << "\n1. Farklı Template Parametreleri ile Array Örnekleri:" << endl;
    
    Array<int, 5> intArray;           // 5 elemanlı int array
    Array<string, 3> stringArray;     // 3 elemanlı string array  
    Array<double, 10> doubleArray;    // 10 elemanlı double array
    
    cout << "Array boyutları:" << endl;
    cout << "• intArray boyutu: " << intArray.size() << endl;
    cout << "• stringArray boyutu: " << stringArray.size() << endl;
    cout << "• doubleArray boyutu: " << doubleArray.size() << endl;
    
    // INT ARRAY KULLANIMI
    cout << "\n2. Int Array İşlemleri:" << endl;
    
    intArray.fill(42);        // Tüm elemanları 42 ile doldur
    intArray[0] = 100;        // İlk elemanı değiştir
    intArray[1] = 200;        // İkinci elemanı değiştir
    
    cout << "Int array içeriği: ";
    for (size_t i = 0; i < intArray.size(); i++) {
        cout << intArray[i] << " ";
    }
    cout << endl;
    
    // STRING ARRAY KULLANIMI
    cout << "\n3. String Array İşlemleri:" << endl;
    
    stringArray[0] = "Bir";
    stringArray[1] = "İki";  
    stringArray[2] = "Üç";
    
    cout << "String array elemanları: ";
    for (const auto& item : stringArray) {    // Range-based for loop
        cout << item << " ";
    }
    cout << endl;
    
    // COUNTER TEMPLATE KULLANIMI
    cout << "\n4. Template Static Member Örneği:" << endl;
    
    // Farklı türler için Counter nesneleri oluştur
    Counter<int> c1(10);
    Counter<int> c2(20);      // int için 2. nesne
    Counter<string> c3("test");
    Counter<string> c4("hello"); // string için 2. nesne
    Counter<double> c5(3.14);    // double için 1. nesne
    
    // Her tür için ayrı count değeri
    cout << "Counter istatistikleri:" << endl;
    cout << "• Int Counter sayısı: " << Counter<int>::getCount() << endl;       // 2
    cout << "• String Counter sayısı: " << Counter<string>::getCount() << endl; // 2  
    cout << "• Double Counter sayısı: " << Counter<double>::getCount() << endl; // 1
    
    // BOUNDS CHECKING TEST
    cout << "\n5. Güvenli Erişim Testi:" << endl;
    
    try {
        cout << "Geçerli erişim: intArray[0] = " << intArray[0] << endl;
        cout << "Geçersiz erişim denemesi: intArray[10]..." << endl;
        cout << intArray[10] << endl;    // Exception fırlatır
    } catch (const out_of_range& e) {
        cout << "HATA YAKALANDI: " << e.what() << endl;
    }
    
    // CONST CORRECTNESS TEST
    cout << "\n6. Const Correctness Testi:" << endl;
    
    const Array<int, 3> constArray = {{1, 2, 3}};  // Const array
    // constArray[0] = 100;  // DERLEME HATASI - const nesne değiştirilemez
    cout << "Const array[0]: " << constArray[0] << endl;  // Sadece okuma
    
    cout << "\n=== TEMPLATE INSTANTIATION BİLGİSİ ===" << endl;
    cout << "Derleyici bu sınıfların aşağıdaki versiyonlarını oluşturdu:" << endl;
    cout << "• Array<int, 5>" << endl;
    cout << "• Array<string, 3>" << endl;
    cout << "• Array<double, 10>" << endl;
    cout << "• Counter<int>" << endl;
    cout << "• Counter<string>" << endl;
    cout << "• Counter<double>" << endl;
    
    /*
     * BEKLENEN ÇIKTI:
     * === CLASS TEMPLATE DEMO ===
     * 
     * 1. Farklı Template Parametreleri ile Array Örnekleri:
     * Array boyutları:
     * • intArray boyutu: 5
     * • stringArray boyutu: 3
     * • doubleArray boyutu: 10
     * 
     * 2. Int Array İşlemleri:
     * Int array içeriği: 100 200 42 42 42 
     * 
     * 3. String Array İşlemleri:
     * String array elemanları: Bir İki Üç 
     * 
     * 4. Template Static Member Örneği:
     * Counter istatistikleri:
     * • Int Counter sayısı: 2
     * • String Counter sayısı: 2
     * • Double Counter sayısı: 1
     * 
     * 5. Güvenli Erişim Testi:
     * Geçerli erişim: intArray[0] = 100
     * Geçersiz erişim denemesi: intArray[10]...
     * HATA YAKALANDI: Index dışında!
     * 
     * 6. Const Correctness Testi:
     * Const array[0]: 1
     */
    
    return 0;
}
```

## Template Specialization

### Specialization Nedir?

Template specialization, genel bir template'in belirli türler veya değerler için özel implementasyonlar sağlamasıdır. Bu, aynı template'in farklı türler için farklı davranışlar sergilemesini mümkün kılar.

**İki ana specialization türü vardır:**

1. **Full Specialization (Tam Özelleştirme)**: Template'in tüm parametreleri için özel implementasyon
2. **Partial Specialization (Kısmi Özelleştirme)**: Template parametrelerinin bir kısmı için özel implementasyon

**Specialization'ın avantajları:**
- Belirli türler için optimize edilmiş kod yazabilirsiniz
- Farklı türler için farklı algoritmalar kullanabilirsiniz
- Type-specific davranışlar tanımlayabilirsiniz
- Compile-time'da doğru implementasyon seçilir

**Örnek kullanım alanları:**
- C-style string'ler için özel string işlemleri
- Pointer türleri için güvenli erişim
- Sayısal türler için matematiksel optimizasyonlar
- Container türleri için özel algoritmaları

### Full Specialization

Full specialization (tam özelleştirme), bir template'in tüm parametrelerini belirli değerlerle sabitleyerek, o tür kombinasyonu için tamamen özel bir implementasyon sağlamasıdır.

**Full Specialization Özellikleri:**
- **Complete Override**: Generic implementasyonu tamamen değiştirir
- **template<> Syntax**: Boş template parameter listesi kullanır
- **Exact Match**: Sadece belirtilen tür kombinasyonu için çalışır
- **Compile-time Resolution**: Derleyici en spesifik eşleşmeyi seçer

**Kullanım Durumları:**
- Belirli türler için optimize edilmiş algoritmalar
- Özel türler için type-specific davranışlar
- C-style string'ler için güvenli işlemler
- Sayısal türler için matematiksel optimizasyonlar
- Debugging ve logging için özel formatlar

```cpp
#include <iostream>
#include <string>
#include <cstring>
using namespace std;

// GENERIC TEMPLATE - Genel implementasyon
// Bu, tüm türler için varsayılan davranışı tanımlar
template<typename T>
class Serializer {
public:
    static string serialize(const T& obj) {
        // Generic serialization: nesnenin bellek adresini string'e çevirir
        return "Generic serialization: " + to_string(reinterpret_cast<uintptr_t>(&obj));
        /*
         * GENERIC SERIALIZATION ÖZELLİKLERİ:
         * - Herhangi bir tür için fallback implementasyon
         * - Nesnenin bellek adresini string olarak döndürür
         * - Debugging ve geliştirme amaçlı
         * - Production'da genellikle daha anlamlı implementasyon gerekir
         * 
         * reinterpret_cast<uintptr_t>(&obj):
         * - Nesnenin adresini integer'a çevirir
         * - Platform bağımsız pointer-to-integer conversion
         * - uintptr_t: pointer boyutunda unsigned integer
         */
    }
};

// INT İÇİN FULL SPECİALİZATİON - Tam özelleştirme
// template<> syntax ile belirli bir tür için özel implementasyon
template<>
class Serializer<int> {
public:
    static string serialize(const int& value) {
        return "INT:" + to_string(value);
        /*
         * INT SPECİALİZATİON ÖZELLİKLERİ:
         * - Sadece int türü için çalışır
         * - "INT:" prefixi ile formatlanmış çıktı
         * - to_string() kullanarak optimize edilmiş dönüşüm
         * - Numeric değerler için optimize edilmiş serialization
         */
    }
};

// STRING İÇİN FULL SPECİALİZATİON
template<>
class Serializer<string> {
public:
    static string serialize(const string& value) {
        return "STR:" + value;
        /*
         * STRING SPECİALİZATİON ÖZELLİKLERİ:
         * - String türü için özel format
         * - "STR:" prefixi ile işaretlenmiş
         * - Doğrudan string concatenation
         * - Escape character handling eklenebilir
         * - JSON-like format için genişletilebilir
         */
    }
};

// DOUBLE İÇİN FULL SPECİALİZATİON
template<>
class Serializer<double> {
public:
    static string serialize(const double& value) {
        return "DBL:" + to_string(value);
        /*
         * DOUBLE SPECİALİZATİON ÖZELLİKLERİ:
         * - Floating-point sayılar için özel format
         * - "DBL:" prefixi ile işaretlenmiş
         * - Precision kontrolü eklenebilir
         * - Scientific notation desteği eklenebilir
         * - NaN ve infinity handling eklenebilir
         */
    }
};

// POINTER'LAR İÇİN PARTIAL SPECİALİZATİON
// template<typename T> ile herhangi bir türün pointer'ı için özelleştirme
template<typename T>
class Serializer<T*> {
public:
    static string serialize(T* const& ptr) {
        if (ptr == nullptr) {
            return "NULL_PTR";
            /*
             * NULL POINTER HANDLİNG:
             * - Güvenli pointer erişimi
             * - Segmentation fault önleme
             * - Explicit null representation
             */
        }
        return "PTR:" + Serializer<T>::serialize(*ptr);
        /*
         * POINTER SPECİALİZATİON ÖZELLİKLERİ:
         * - Herhangi bir türün pointer'ı için çalışır
         * - Pointer dereference (*ptr) ile değere erişim
         * - Recursive serialization: T türü için uygun serializer çağrılır
         * - "PTR:" prefixi ile pointer olduğunu belirtir
         * - Null pointer safety kontrolü
         * 
         * RECURSIVE CALL:
         * Serializer<T>::serialize(*ptr) çağrısı:
         * - T türüne göre uygun serializer seçilir
         * - int* için: Serializer<int>::serialize() çağrılır
         * - string* için: Serializer<string>::serialize() çağrılır
         * - Generic tür için: Generic Serializer<T>::serialize() çağrılır
         */
    }
};

int main() {
    cout << "=== TEMPLATE SPECİALİZATİON DEMO ===" << endl;
    
    // TEST VERİLERİ
    int i = 42;
    double d = 3.14159;
    string s = "Merhaba Dünya";
    char c = 'X';
    int* ptr = &i;
    int* nullPtr = nullptr;
    
    cout << "\n1. Specialized Types (Özelleştirilmiş Türler):" << endl;
    
    // Her tür için uygun specialization çağrılır
    cout << "Int serialization: " << Serializer<int>::serialize(i) << endl;
    // Çağrılan: Serializer<int> specialization
    
    cout << "Double serialization: " << Serializer<double>::serialize(d) << endl;
    // Çağrılan: Serializer<double> specialization
    
    cout << "String serialization: " << Serializer<string>::serialize(s) << endl;
    // Çağrılan: Serializer<string> specialization
    
    cout << "\n2. Generic Type (Generic Implementasyon):" << endl;
    
    cout << "Char serialization: " << Serializer<char>::serialize(c) << endl;
    // Çağrılan: Generic Serializer<T> (char için specialization yok)
    
    cout << "\n3. Pointer Specialization (Pointer Özelleştirmesi):" << endl;
    
    cout << "Valid pointer: " << Serializer<int*>::serialize(ptr) << endl;
    // Çağrılan: Serializer<T*> specialization -> Serializer<int> specialization
    
    cout << "Null pointer: " << Serializer<int*>::serialize(nullPtr) << endl;
    // Çağrılan: Serializer<T*> specialization (null check)
    
    cout << "\n4. Nested Pointer Test:" << endl;
    
    string str = "Test String";
    string* strPtr = &str;
    cout << "String pointer: " << Serializer<string*>::serialize(strPtr) << endl;
    // Çağrılan: Serializer<string*> -> Serializer<string> specialization
    
    cout << "\n5. Custom Type Test (Generic Fallback):" << endl;
    
    // Custom struct için generic implementation kullanılır
    struct CustomType { int x, y; } custom{10, 20};
    cout << "Custom type: " << Serializer<CustomType>::serialize(custom) << endl;
    // Çağrılan: Generic Serializer<T> (CustomType için specialization yok)
    
    cout << "\n=== SPECİALİZATİON SEÇİM MANTIĞI ===" << endl;
    cout << "Derleyici şu öncelik sırasını kullanır:" << endl;
    cout << "1. Exact match specialization (tam eşleşme)" << endl;
    cout << "2. Partial specialization (kısmi özelleştirme)" << endl;  
    cout << "3. Generic template (genel şablon)" << endl;
    
    cout << "\nÖrnek seçimler:" << endl;
    cout << "• Serializer<int> -> int specialization (1. öncelik)" << endl;
    cout << "• Serializer<int*> -> T* partial specialization (2. öncelik)" << endl;
    cout << "• Serializer<char> -> generic template (3. öncelik)" << endl;
    
    /*
     * BEKLENEN ÇIKTI:
     * === TEMPLATE SPECİALİZATİON DEMO ===
     * 
     * 1. Specialized Types (Özelleştirilmiş Türler):
     * Int serialization: INT:42
     * Double serialization: DBL:3.141590
     * String serialization: STR:Merhaba Dünya
     * 
     * 2. Generic Type (Generic Implementasyon):
     * Char serialization: Generic serialization: [memory address]
     * 
     * 3. Pointer Specialization (Pointer Özelleştirmesi):
     * Valid pointer: PTR:INT:42
     * Null pointer: NULL_PTR
     * 
     * 4. Nested Pointer Test:
     * String pointer: PTR:STR:Test String
     * 
     * 5. Custom Type Test (Generic Fallback):
     * Custom type: Generic serialization: [memory address]
     * 
     * TEMPLATe SPECİALİZATİON AVANTAJLARI:
     * - Type-specific optimizations
     * - Custom behavior for special types
     * - Maintain generic interface
     * - Compile-time resolution
     * - No runtime overhead
     */
    
    return 0;
}
```

### Function Template Specialization

Function template specialization, generic function template'lerinin belirli türler için özel davranışlar sergilemesini sağlar. Class template specialization'dan farklı olarak, function'lar için partial specialization mümkün değildir.

**Function Template Specialization Özellikleri:**
- **Only Full Specialization**: Function'lar için sadece tam özelleştirme mümkün
- **Type-Specific Behavior**: Belirli türler için optimize edilmiş algoritmalar
- **Function Overloading Alternative**: Function overloading'e alternatif yaklaşım
- **Template Argument Deduction**: Çoğu durumda tür çıkarımı otomatik

**Kullanım Senaryoları:**
- String işlemleri için optimize edilmiş algoritmalar
- Sayısal türler için matematiksel optimizasyonlar
- Pointer türleri için güvenli erişim fonksiyonları
- Container türleri için özel işlem fonksiyonları
- Type-safe I/O operations

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// GENERIC TEMPLATE FUNCTION - Genel implementasyon
// Herhangi bir tür için varsayılan davranış
template<typename T>
void process(const T& value) {
    cout << "Generic processing: " << value << endl;
    /*
     * GENERIC PROCESSING ÖZELLİKLERİ:
     * - Herhangi bir tür için fallback implementasyon
     * - Operator<< gerektiren türler için çalışır
     * - Basit yazdırma işlemi
     * - Specialization olmayan türler için kullanılır
     */
}

// INT İÇİN FUNCTION TEMPLATE SPECİALİZATİON
// template<> syntax ile belirli bir tür için özel implementasyon
template<>
void process<int>(const int& value) {
    cout << "Integer processing: " << value * 2 << endl;
    /*
     * INT SPECİALİZATİON ÖZELLİKLERİ:
     * - Sadece int türü için çalışır
     * - Özel işlem: değeri 2 ile çarpar
     * - Integer-specific optimization
     * - Mathematical operations için optimize
     * 
     * KULLANIM AMACI:
     * - Sayısal türler için özel algoritmaları
     * - Performance-critical operations
     * - Type-specific business logic
     */
}

// STRING İÇİN FUNCTION TEMPLATE SPECİALİZATİON
template<>
void process<string>(const string& value) {
    cout << "String processing: " << value << " (length: " << value.length() << ")" << endl;
    /*
     * STRING SPECİALİZATİON ÖZELLİKLERİ:
     * - String türü için özel işlem
     * - Uzunluk bilgisi ekleme
     * - String-specific operations
     * - Text processing için optimize
     * 
     * İLAVE ÖZELLİKLER:
     * - Character encoding handling
     * - Validation operations
     * - Formatting and sanitization
     * - Localization support
     */
}

// GENERIC CONTAINER FUNCTION - Herhangi bir container için
// Template function ile generic container processing
template<typename Container>
void printContainer(const Container& container) {
    cout << "Container içeriği: ";
    for (const auto& item : container) {
        cout << item << " ";
    }
    cout << endl;
    /*
     * GENERIC CONTAINER ÖZELLİKLERİ:
     * - Range-based for loop desteği gereken containerlar
     * - Iterator pattern uyumlu yapılar
     * - STL containers (vector, list, set, vs.)
     * - Custom containers with iterator support
     * 
     * TEMPLATE CONSTRAINTS (C++20'de):
     * template<std::ranges::range Container>
     * void printContainer(const Container& container) { ... }
     */
}

// VECTOR<BOOL> İÇİN SPECİAL CASE SPECİALİZATİON
// vector<bool> özel bir implementation'a sahip (space optimization)
template<>
void printContainer<vector<bool>>(const vector<bool>& container) {
    cout << "Bool vector içeriği: ";
    for (size_t i = 0; i < container.size(); i++) {
        cout << (container[i] ? "true" : "false") << " ";
    }
    cout << endl;
    /*
     * VECTOR<BOOL> SPECİAL CASE:
     * - vector<bool> standart vector implementasyonundan farklı
     * - Space optimization: her bool için 1 bit kullanır
     * - Proxy object döndürür (bool& değil)
     * - Range-based for loop'ta problem çıkarabilir
     * - Index-based access daha güvenli
     * 
     * NEDEN SPECİALİZATİON GEREKLİ?
     * - vector<bool>::iterator özel bir proxy
     * - auto& item range-based for'da sorun çıkarır
     * - Explicit bool conversion gerekebilir
     * - Memory layout farklı (bit-packed)
     */
}

int main() {
    cout << "=== FUNCTION TEMPLATE SPECİALİZATİON DEMO ===" << endl;
    
    // BASIC TYPE PROCESSING TEST
    cout << "\n1. Temel Tür İşleme Testleri:" << endl;
    
    cout << "Int processing: ";
    process(42);           // Specialization: int versiyonu (42 * 2 = 84)
    
    cout << "Double processing: ";
    process(3.14);         // Generic: double için specialization yok
    
    cout << "String processing: ";
    process(string("Merhaba"));  // Specialization: string versiyonu (+ length)
    
    cout << "Char processing: ";
    process('X');          // Generic: char için specialization yok
    
    // ADVANCED TYPE TESTS
    cout << "\n2. Gelişmiş Tür Testleri:" << endl;
    
    // Boolean test
    cout << "Bool processing: ";
    process(true);         // Generic: bool için specialization yok
    
    // Float test  
    cout << "Float processing: ";
    process(2.5f);         // Generic: float için specialization yok
    
    // Long test
    cout << "Long processing: ";
    process(1000L);        // Generic: long için specialization yok
    
    // CONTAINER PROCESSING TESTS
    cout << "\n3. Container İşleme Testleri:" << endl;
    
    // Normal vector test
    vector<int> intVec = {1, 2, 3, 4, 5};
    cout << "Int vector: ";
    printContainer(intVec);    // Generic container function
    
    // String vector test
    vector<string> stringVec = {"elma", "armut", "çilek"};
    cout << "String vector: ";
    printContainer(stringVec); // Generic container function
    
    // Special case: vector<bool>
    vector<bool> boolVec = {true, false, true, false, true};
    cout << "Bool vector: ";
    printContainer(boolVec);   // Specialized function for vector<bool>
    
    // Other STL containers
    cout << "\n4. Diğer STL Container'ları:" << endl;
    
    // List test
    list<double> doubleList = {1.1, 2.2, 3.3};
    cout << "Double list: ";
    printContainer(doubleList); // Generic container function
    
    // Array test (C++11)
    array<char, 4> charArray = {'A', 'B', 'C', 'D'};
    cout << "Char array: ";
    printContainer(charArray);  // Generic container function
    
    cout << "\n=== SPECİALİZATİON SELECTION LOGIC ===" << endl;
    cout << "Derleyici fonksiyon seçimi:" << endl;
    cout << "\n1. process() fonksiyonu için:" << endl;
    cout << "• process(int) -> int specialization kullanıldı" << endl;
    cout << "• process(string) -> string specialization kullanıldı" << endl;  
    cout << "• process(double) -> generic template kullanıldı" << endl;
    cout << "• process(char) -> generic template kullanıldı" << endl;
    
    cout << "\n2. printContainer() fonksiyonu için:" << endl;
    cout << "• printContainer(vector<int>) -> generic template kullanıldı" << endl;
    cout << "• printContainer(vector<bool>) -> vector<bool> specialization kullanıldı" << endl;
    cout << "• printContainer(list<double>) -> generic template kullanıldı" << endl;
    
    cout << "\n=== PERFORMANS VE AVANTAJLAR ===" << endl;
    cout << "Specialization avantajları:" << endl;
    cout << "• Type-specific optimizations (tür-özel optimizasyonlar)" << endl;
    cout << "• Algorithm selection (algoritma seçimi)" << endl;
    cout << "• Special case handling (özel durum yönetimi)" << endl;
    cout << "• Compile-time resolution (derleme zamanı çözümlemesi)" << endl;
    cout << "• No runtime overhead (çalışma zamanı ek maliyeti yok)" << endl;
    
    /*
     * BEKLENEN ÇIKTI:
     * === FUNCTION TEMPLATE SPECİALİZATİON DEMO ===
     * 
     * 1. Temel Tür İşleme Testleri:
     * Int processing: Integer processing: 84
     * Double processing: Generic processing: 3.14
     * String processing: String processing: Merhaba (length: 7)
     * Char processing: Generic processing: X
     * 
     * 2. Gelişmiş Tür Testleri:
     * Bool processing: Generic processing: 1
     * Float processing: Generic processing: 2.5
     * Long processing: Generic processing: 1000
     * 
     * 3. Container İşleme Testleri:
     * Int vector: Container içeriği: 1 2 3 4 5 
     * String vector: Container içeriği: elma armut çilek 
     * Bool vector: Bool vector içeriği: true false true false true 
     * 
     * 4. Diğer STL Container'ları:
     * Double list: Container içeriği: 1.1 2.2 3.3 
     * Char array: Container içeriği: A B C D 
     */
    
    return 0;
}
```

## CRTP (Curiously Recurring Template Pattern)

CRTP, statik polimorfizminin en gelişmiş tekniklerinden biridir:

### Temel CRTP

CRTP (Curiously Recurring Template Pattern), bir sınıfın kendisini template parametresi olarak base class'ına geçirdiği gelişmiş bir template pattern'idir. Bu teknik, virtual function'ların sağladığı polimorfizmi runtime overhead olmadan compile-time'da gerçekleştirir.

**CRTP'nin Temel Özellikleri:**
- **Static Polymorphism**: Virtual function table overhead'i olmadan polimorfizm
- **Self-Injection Pattern**: Derived class kendini base class'a enjekte eder
- **Compile-time Resolution**: Tüm method çağrıları compile-time'da çözümlenir
- **Type Safety**: Template system ile güçlü tür kontrolü

**CRTP'nin Avantajları:**
- **Zero Runtime Cost**: Virtual function call overhead'i yok
- **Inlining Opportunities**: Derleyici daha agresif optimizasyon yapabilir
- **Strong Type Safety**: Template system ile güvenli kod
- **Interface Enforcement**: Base class, derived class interface'ini zorlayabilir

**Kullanım Alanları:**
- Singleton Pattern implementasyonu
- Mixin pattern'ları
- Policy-based design
- STL iterator hierarchy'si
- Performance-critical polymorphic code

```cpp
#include <iostream>
using namespace std;

// CRTP BASE TEMPLATE SINIFI - Curiously Recurring Template Pattern
// Bu pattern, türetilmiş sınıfı template parametresi olarak alan base sınıf demektir
template<typename Derived>
class Animal {
public:
    // POLİMORFİK FONKSIYON ÇAĞRILARI - Static polymorphism via CRTP
    void makeSound() {
        // Static cast ile türetilmiş sınıfa erişim
        static_cast<Derived*>(this)->makeSound();
        /*
         * STATIC_CAST AÇIKLAMASI:
         * - this pointer'ını Derived* türüne dönüştürür
         * - Compile-time'da yapılan güvenli cast işlemi
         * - Virtual function table overhead'i yoktur
         * - Türetilmiş sınıfın gerçek implementasyonunu çağırır
         * 
         * CRTP ÇALIŞMA PRENSİBİ:
         * 1. Animal<Dog> sınıfından Animal base'i oluşur
         * 2. makeSound() çağrıldığında static_cast<Dog*>(this) yapılır
         * 3. Dog::makeSound() direkt olarak çağrılır
         * 4. Virtual function lookup maliyeti yoktur
         */
    }
    
    void move() {
        static_cast<Derived*>(this)->move();
        // Aynı pattern ile move fonksiyonu için de polimorfik çağrı
    }
    
    // INTERFACE FUNCTION - Template Method Pattern
    // Base sınıfta tanımlanan, türetilmiş sınıfların implementasyonunu kullanan fonksiyon
    void dailyRoutine() {
        cout << "Günlük rutin başlıyor..." << endl;
        makeSound();    // Polimorfik çağrı: türetilmiş sınıfın implementasyonu
        move();         // Polimorfik çağrı: türetilmiş sınıfın implementasyonu
        cout << "Günlük rutin bitti." << endl;
        /*
         * TEMPLATE METHOD PATTERN:
         * - Base sınıf genel algoritmanın iskeletini tanımlar
         * - Türetilmiş sınıflar spesifik adımları implement eder
         * - Compile-time'da çözümlenmiş polimorfizm
         * - Code reuse ve consistent interface sağlar
         * 
         * AVANTAJLAR:
         * - Virtual function overhead'i yok
         * - Inline optimization mümkün
         * - Type safety compile-time'da garanti
         * - Better performance than virtual functions
         */
    }
};

// TÜRETILMIŞ SINIFLAR - CRTP kullanarak özelleştirilmiş davranışlar

// DOG SINIFI - Köpek davranışları
class Dog : public Animal<Dog> {    // CRTP: Dog kendini template parametresi olarak geçirir
public:
    void makeSound() {
        cout << "Köpek: Hav hav!" << endl;
        /*
         * DOG-SPECİFİC IMPLEMENTATION:
         * - Köpeğe özel ses çıkarma davranışı
         * - Bu fonksiyon Animal<Dog>::makeSound() tarafından çağrılır
         * - Compile-time'da doğrudan bu implementation'a bağlanır
         */
    }
    
    void move() {
        cout << "Köpek koşuyor..." << endl;
        /*
         * DOG-SPECİFİC MOVEMENT:
         * - Köpeğe özel hareket davranışı
         * - Energetic movement pattern
         * - Bu fonksiyon Animal<Dog>::move() tarafından çağrılır
         */
    }
};

// CAT SINIFI - Kedi davranışları
class Cat : public Animal<Cat> {    // CRTP: Cat kendini template parametresi olarak geçirir
public:
    void makeSound() {
        cout << "Kedi: Miyav!" << endl;
        /*
         * CAT-SPECİFİC IMPLEMENTATION:
         * - Kediye özel ses çıkarma davranışı
         * - Farklı frequency ve pattern
         * - Animal<Cat>::makeSound() tarafından çağrılır
         */
    }
    
    void move() {
        cout << "Kedi sinsice yürüyor..." << endl;
        /*
         * CAT-SPECİFİC MOVEMENT:
         * - Kediye özel hareket davranışı
         * - Stealty movement pattern
         * - Grace ve agility odaklı
         */
    }
};

// BIRD SINIFI - Kuş davranışları  
class Bird : public Animal<Bird> {  // CRTP: Bird kendini template parametresi olarak geçirir
public:
    void makeSound() {
        cout << "Kuş: Cik cik!" << endl;
        /*
         * BIRD-SPECİFİC IMPLEMENTATION:
         * - Kuşa özel ses çıkarma davranışı
         * - High-pitch sounds
         * - Communication patterns
         */
    }
    
    void move() {
        cout << "Kuş uçuyor..." << endl;
        /*
         * BIRD-SPECİFİC MOVEMENT:
         * - Kuşa özel hareket davranışı
         * - 3D movement capability
         * - Flight mechanics
         */
    }
};

int main() {
    cout << "=== CRTP (CURIOUSLY RECURRING TEMPLATE PATTERN) DEMO ===" << endl;
    
    // NESNE OLUŞTURMA - Her türetilmiş sınıftan bir örnek
    Dog dog;    // Animal<Dog> base sınıfından türeyen Dog nesnesi
    Cat cat;    // Animal<Cat> base sınıfından türeyen Cat nesnesi  
    Bird bird;  // Animal<Bird> base sınıfından türeyen Bird nesnesi
    
    cout << "\n1. Köpek Günlük Rutini:" << endl;
    dog.dailyRoutine();
    /*
     * ÇAĞRI SIRASI:
     * 1. Animal<Dog>::dailyRoutine() çağrılır
     * 2. dailyRoutine() içinde makeSound() çağrılır
     * 3. static_cast<Dog*>(this)->makeSound() ile Dog::makeSound() çağrılır
     * 4. dailyRoutine() içinde move() çağrılır  
     * 5. static_cast<Dog*>(this)->move() ile Dog::move() çağrılır
     */
    
    cout << "\n2. Kedi Günlük Rutini:" << endl;
    cat.dailyRoutine();
    /*
     * COMPILE-TIME RESOLUTION:
     * - Animal<Cat> template instantiation
     * - static_cast<Cat*> operations
     * - Direct function calls (no virtual table lookup)
     */
    
    cout << "\n3. Kuş Günlük Rutini:" << endl;
    bird.dailyRoutine();
    
    cout << "\n=== MANUEL FONKSİYON ÇAĞRILARI ===" << endl;
    
    // Direkt fonksiyon çağrıları
    cout << "\nDirekt ses çıkarma:" << endl;
    dog.makeSound();     // Dog::makeSound() direkt çağrı
    cat.makeSound();     // Cat::makeSound() direkt çağrı  
    bird.makeSound();    // Bird::makeSound() direkt çağrı
    
    cout << "\nDirekt hareket:" << endl;
    dog.move();          // Dog::move() direkt çağrı
    cat.move();          // Cat::move() direkt çağrı
    bird.move();         // Bird::move() direkt çağrı
    
    cout << "\n=== CRTP AVANTAJLARI ===" << endl;
    cout << "1. PERFORMANS:" << endl;
    cout << "   • Virtual function call overhead'i yok" << endl;
    cout << "   • Compile-time'da function resolution" << endl;
    cout << "   • Inline optimization mümkün" << endl;
    cout << "   • CPU cache friendly" << endl;
    
    cout << "\n2. TYPE SAFETY:" << endl;
    cout << "   • Compile-time'da tür kontrolü" << endl;
    cout << "   • Wrong type usage compile error'a yol açar" << endl;
    cout << "   • Template instantiation per type" << endl;
    
    cout << "\n3. CODE REUSE:" << endl;
    cout << "   • Common interface ve behavior base'de" << endl;
    cout << "   • Specific implementations derived'de" << endl;
    cout << "   • Template method pattern desteği" << endl;
    
    cout << "\n=== MEMORY LAYOUT ===" << endl;
    cout << "sizeof(Dog): " << sizeof(dog) << " bytes" << endl;
    cout << "sizeof(Cat): " << sizeof(cat) << " bytes" << endl;
    cout << "sizeof(Bird): " << sizeof(bird) << " bytes" << endl;
    cout << "Not: Virtual table pointer yok, minimal memory footprint" << endl;
    
    /*
     * BEKLENEN ÇIKTI:
     * === CRTP (CURIOUSLY RECURRING TEMPLATE PATTERN) DEMO ===
     * 
     * 1. Köpek Günlük Rutini:
     * Günlük rutin başlıyor...
     * Köpek: Hav hav!
     * Köpek koşuyor...
     * Günlük rutin bitti.
     * 
     * 2. Kedi Günlük Rutini:
     * Günlük rutin başlıyor...
     * Kedi: Miyav!
     * Kedi sinsice yürüyor...
     * Günlük rutin bitti.
     * 
     * 3. Kuş Günlük Rutini:
     * Günlük rutin başlıyor...
     * Kuş: Cik cik!
     * Kuş uçuyor...
     * Günlük rutin bitti.
     * 
     * === MANUEL FONKSİYON ÇAĞRILARI ===
     * 
     * Direkt ses çıkarma:
     * Köpek: Hav hav!
     * Kedi: Miyav!
     * Kuş: Cik cik!
     * 
     * Direkt hareket:
     * Köpek koşuyor...
     * Kedi sinsice yürüyor...
     * Kuş uçuyor...
     */
    
    return 0;
}
```

### CRTP ile Singleton Pattern

CRTP kullanarak generic Singleton pattern implementasyonu oluşturmak, her sınıf için ayrı Singleton kodu yazmaktan kurtarır. Bu yaklaşım, Singleton functionality'sini template base class'ına kapsüller ve type-safe bir şekilde her derived class için otomatik olarak Singleton davranışı sağlar.

**CRTP Singleton'ın Avantajları:**
- **Code Reusability**: Tek base class, tüm Singleton ihtiyaçlarını karşılar
- **Type Safety**: Her Singleton türü için ayrı instance garantisi
- **Thread Safety**: Modern C++ özellikleri ile güvenli implementasyon
- **No Boilerplate Code**: Derived class'lar sadece constructor'ı private yapar

**Geleneksel Singleton'dan Farkları:**
- Her Singleton class için kod tekrarı yok
- Template sayesinde tür güvenliği garantili
- Meyer's Singleton pattern ile thread-safe implementasyon
- Memory layout ve performance optimizasyonları

**Kullanım Senaryoları:**
- Logger sınıfları
- Configuration manager'ları
- Database connection pool'ları
- Resource manager'ları
- Cache implementation'ları

```cpp
#include <iostream>
#include <string>
using namespace std;

// CRTP SINGLETON BASE SINIFI - Generic Singleton Implementation
// Bu base sınıf, herhangi bir sınıfı singleton yapabilen generic bir template'dir
template<typename T>
class Singleton {
protected:
    Singleton() = default;              // Protected constructor: sadece türetilmiş sınıflar erişebilir
    virtual ~Singleton() = default;     // Virtual destructor: safe polymorphic destruction
    
public:
    // COPY VE ASSIGNMENT'I ENGELLE - Singleton kuralları
    Singleton(const Singleton&) = delete;           // Copy constructor'ı sil
    Singleton& operator=(const Singleton&) = delete; // Assignment operator'ı sil
    /*
     * SINGLETON KURALLARI:
     * - Sadece bir instance olmalı
     * - Copy edilememeli (copy constructor = delete)
     * - Assign edilememeli (assignment operator = delete)
     * - Move operations da genellikle delete edilir
     * 
     * = delete SYNTAX (C++11):
     * - Fonksiyonları explicitly delete eder
     * - Compile-time error verir (kullanılırsa)
     * - Intent'i açık şekilde belirtir
     */
    
    // SINGLETON INSTANCE ERİŞİMİ - Thread-safe lazy initialization
    static T& getInstance() {
        static T instance;    // Meyer's Singleton: thread-safe lazy initialization
        return instance;
        /*
         * MEYER'S SINGLETON ÖZELLİKLERİ:
         * - C++11'den itibaren thread-safe
         * - Lazy initialization: ilk çağrıda oluşturulur
         * - Static local variable guarantee
         * - Automatic destruction at program exit
         * - No double-checked locking pattern needed
         * 
         * THREAD SAFETY:
         * - C++11 standard guarantees thread-safe static initialization
         * - Compiler handles synchronization automatically
         * - Only one thread can initialize static variable
         */
    }
};

// LOGGER SINGLETON - Logging sistemi implementasyonu
class Logger : public Singleton<Logger> {
    friend class Singleton<Logger>;  // Base sınıfın private constructor'a erişimi için
    
private:
    string logLevel;    // Log seviyesi (DEBUG, INFO, WARNING, ERROR)
    
    // PRIVATE CONSTRUCTOR - Dışarıdan instance oluşturmayı engeller
    Logger() : logLevel("INFO") {
        cout << "Logger instance oluşturuldu (default level: INFO)" << endl;
    }
    /*
     * PRIVATE CONSTRUCTOR ÖZELLİKLERİ:
     * - Dışarıdan new Logger() yapılamaz
     * - Stack'te Logger obj; yapılamaz
     * - Sadece getInstance() ile erişilebilir
     * - friend class sayesinde Singleton<Logger> erişebilir
     */
    
public:
    // LOG YAZMA FONKSİYONU
    void log(const string& message) {
        cout << "[" << logLevel << "] " << message << endl;
        /*
         * LOG FORMAT:
         * [LEVEL] message
         * Örnek: [INFO] Application started
         * 
         * GELİŞTİRİLEBİLİR ÖZELLİKLER:
         * - Timestamp ekleme
         * - File output
         * - Different log levels filtering
         * - Thread ID ekleme
         */
    }
    
    // LOG LEVEL AYARLAMA
    void setLogLevel(const string& level) {
        logLevel = level;
        cout << "Log level changed to: " << level << endl;
    }
    
    // LOG LEVEL OKUMA
    string getLogLevel() const {
        return logLevel;
    }
};

// DATABASE MANAGER SINGLETON - Veritabanı bağlantı yöneticisi
class DatabaseManager : public Singleton<DatabaseManager> {
    friend class Singleton<DatabaseManager>;  // Base sınıfın constructor erişimi
    
private:
    bool connected;        // Bağlantı durumu
    string connectionString; // Bağlantı string'i
    
    // PRIVATE CONSTRUCTOR
    DatabaseManager() : connected(false), connectionString("localhost:5432/mydb") {
        cout << "DatabaseManager instance oluşturuldu" << endl;
    }
    
public:
    // VERİTABANI BAĞLANTISI
    void connect() {
        if (!connected) {
            connected = true;
            cout << "Veritabanına bağlanıldı: " << connectionString << endl;
        } else {
            cout << "Zaten bağlı durumda!" << endl;
        }
        /*
         * CONNECTION MANAGEMENT:
         * - Duplicate connection check
         * - Connection pooling eklenebilir
         * - Retry mechanism eklenebilir
         * - Health check functionality
         */
    }
    
    // VERİTABANI BAĞLANTISI KESME
    void disconnect() {
        if (connected) {
            connected = false;
            cout << "Veritabanı bağlantısı kesildi." << endl;
        } else {
            cout << "Zaten bağlı değil!" << endl;
        }
    }
    
    // BAĞLANTI DURUMU KONTROLÜ
    bool isConnected() const {
        return connected;
    }
    
    // BAĞLANTI STRING'İ AYARLAMA
    void setConnectionString(const string& connStr) {
        if (!connected) {
            connectionString = connStr;
            cout << "Connection string updated: " << connStr << endl;
        } else {
            cout << "Cannot change connection string while connected!" << endl;
        }
    }
};

int main() {
    cout << "=== CRTP SINGLETON PATTERN DEMO ===" << endl;
    
    // LOGGER SINGLETON KULLANIMI
    cout << "\n1. Logger Singleton Testi:" << endl;
    
    Logger& logger1 = Logger::getInstance();  // İlk erişim: instance oluşturulur
    Logger& logger2 = Logger::getInstance();  // İkinci erişim: aynı instance döner
    
    // INSTANCE KONTROLÜ - Aynı nesne mi?
    cout << "Logger instance'ları aynı mı? " 
         << (&logger1 == &logger2 ? "Evet" : "Hayır") << endl;
    cout << "logger1 address: " << &logger1 << endl;
    cout << "logger2 address: " << &logger2 << endl;
    
    // LOG İŞLEMLERİ
    cout << "\n2. Logging İşlemleri:" << endl;
    logger1.setLogLevel("DEBUG");    // İlk referans ile log level ayarlama
    logger1.log("İlk log mesajı");   
    
    logger2.log("İkinci log mesajı"); // İkinci referans ile log yazma
    cout << "Current log level: " << logger2.getLogLevel() << endl;
    
    // Her iki referans da aynı state'i paylaşır
    
    // DATABASE MANAGER SINGLETON KULLANIMI
    cout << "\n3. DatabaseManager Singleton Testi:" << endl;
    
    DatabaseManager& db1 = DatabaseManager::getInstance();
    DatabaseManager& db2 = DatabaseManager::getInstance();
    
    cout << "DatabaseManager instance'ları aynı mı? " 
         << (&db1 == &db2 ? "Evet" : "Hayır") << endl;
    
    // VERİTABANI İŞLEMLERİ
    cout << "\n4. Database İşlemleri:" << endl;
    cout << "Başlangıç bağlantı durumu: " << (db1.isConnected() ? "Bağlı" : "Bağlı değil") << endl;
    
    db1.connect();                    // İlk referans ile bağlantı
    cout << "db1 ile bağlandıktan sonra db2 durumu: " << (db2.isConnected() ? "Bağlı" : "Bağlı değil") << endl;
    
    db2.connect();                    // İkinci referans ile tekrar bağlantı denemesi
    db1.disconnect();                 // İlk referans ile bağlantı kesme
    
    // ADVANCED SINGLETON OPERATIONS
    cout << "\n5. Gelişmiş Singleton İşlemleri:" << endl;
    
    // Log level değiştirme ve cross-reference test
    logger1.setLogLevel("ERROR");
    logger2.log("Error seviyesinde mesaj");
    
    // Database connection string değiştirme
    db2.setConnectionString("postgresql://localhost:5433/newdb");
    db1.connect();  // Yeni connection string ile bağlanma
    
    cout << "\n=== SINGLETON PATTERN AVANTAJLARI ===" << endl;
    cout << "1. GLOBAL ACCESS: Tüm uygulamadan tek noktaya erişim" << endl;
    cout << "2. RESOURCE CONTROL: Kritik kaynakların tek instance kontrolü" << endl;
    cout << "3. LAZY INITIALIZATION: İhtiyaç duyulduğunda oluşturma" << endl;
    cout << "4. THREAD SAFETY: Modern C++'da otomatik thread-safe initialization" << endl;
    cout << "5. MEMORY EFFICIENCY: Sadece bir instance, memory tasarrufu" << endl;
    
    cout << "\n=== CRTP SINGLETON vs TRADITIONAL SINGLETON ===" << endl;
    cout << "CRTP Avantajları:" << endl;
    cout << "• Boilerplate code reduction (kod tekrarını azaltır)" << endl;
    cout << "• Type safety (compile-time tür güvenliği)" << endl;
    cout << "• Easy multiple singleton classes (birden fazla singleton kolayca)" << endl;
    cout << "• Template-based flexibility (template esnekliği)" << endl;
    
    /*
     * BEKLENEN ÇIKTI:
     * === CRTP SINGLETON PATTERN DEMO ===
     * 
     * 1. Logger Singleton Testi:
     * Logger instance oluşturuldu (default level: INFO)
     * Logger instance'ları aynı mı? Evet
     * logger1 address: [same address]
     * logger2 address: [same address]
     * 
     * 2. Logging İşlemleri:
     * Log level changed to: DEBUG
     * [DEBUG] İlk log mesajı
     * [DEBUG] İkinci log mesajı
     * Current log level: DEBUG
     * 
     * 3. DatabaseManager Singleton Testi:
     * DatabaseManager instance oluşturuldu
     * DatabaseManager instance'ları aynı mı? Evet
     * 
     * 4. Database İşlemleri:
     * Başlangıç bağlantı durumu: Bağlı değil
     * Veritabanına bağlanıldı: localhost:5432/mydb
     * db1 ile bağlandıktan sonra db2 durumu: Bağlı
     * Zaten bağlı durumda!
     * Veritabanı bağlantısı kesildi.
     * 
     * 5. Gelişmiş Singleton İşlemleri:
     * Log level changed to: ERROR
     * [ERROR] Error seviyesinde mesaj
     * Connection string updated: postgresql://localhost:5433/newdb
     * Veritabanına bağlanıldı: postgresql://localhost:5433/newdb
     */
    
    return 0;
}
```

### CRTP ile Policy-Based Design

Policy-Based Design, farklı algoritmaların ve davranışların template parametreleri olarak geçirilebildiği gelişmiş bir design pattern'dir. CRTP ile birleştirildiğinde, compile-time'da esnek ve performanslı kod yazma imkanı sağlar.

**Policy-Based Design'ın Temel Özellikleri:**
- **Compile-time Configuration**: Farklı davranışlar template parametreleri ile
- **Mix-and-Match Policies**: Farklı policy'lerin kombinasyonu
- **Zero Runtime Cost**: Tüm kararlar compile-time'da alınır
- **Type Safety**: Template system ile güçlü tür kontrolü

**Policy Pattern'ın Avantajları:**
- **Flexible Combinations**: Policy'ler birbirinden bağımsız olarak değiştirilebilir
- **Code Reuse**: Aynı policy farklı context'lerde kullanılabilir
- **Performance**: Virtual function overhead'i olmadan polimorfizm
- **Extensibility**: Yeni policy'ler kolayca eklenebilir

**Kullanım Alanları:**
- Memory allocation strategies
- Sorting algorithm selection
- Error handling policies
- Logging policies
- Threading policies
- Container growth strategies

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Storage policy'leri
template<typename T>
class VectorStorage {
protected:
    vector<T> data;
    
public:
    void add(const T& item) { data.push_back(item); }
    T& get(size_t index) { return data[index]; }
    size_t size() const { return data.size(); }
    
    typename vector<T>::iterator begin() { return data.begin(); }
    typename vector<T>::iterator end() { return data.end(); }
};

template<typename T>
class ArrayStorage {
protected:
    static constexpr size_t MAX_SIZE = 100;
    T data[MAX_SIZE];
    size_t currentSize = 0;
    
public:
    void add(const T& item) {
        if (currentSize < MAX_SIZE) {
            data[currentSize++] = item;
        }
    }
    
    T& get(size_t index) { return data[index]; }
    size_t size() const { return currentSize; }
    
    T* begin() { return data; }
    T* end() { return data + currentSize; }
};

// Sorting policy'leri
class AscendingSort {
public:
    template<typename Iterator>
    static void sort(Iterator begin, Iterator end) {
        std::sort(begin, end);
    }
};

class DescendingSort {
public:
    template<typename Iterator>
    static void sort(Iterator begin, Iterator end) {
        std::sort(begin, end, greater<typename Iterator::value_type>());
    }
};

// CRTP ile policy-based container
template<typename T, template<typename> class StoragePolicy, typename SortPolicy>
class Container : private StoragePolicy<T> {
public:
    using StoragePolicy<T>::add;
    using StoragePolicy<T>::get;
    using StoragePolicy<T>::size;
    using StoragePolicy<T>::begin;
    using StoragePolicy<T>::end;
    
    void sort() {
        SortPolicy::sort(begin(), end());
    }
    
    void display() {
        cout << "Container içeriği: ";
        for (const auto& item : *this) {
            cout << item << " ";
        }
        cout << endl;
    }
};

int main() {
    // Farklı storage ve sorting policy kombinasyonları
    Container<int, VectorStorage, AscendingSort> vecAsc;
    Container<int, VectorStorage, DescendingSort> vecDesc;
    Container<int, ArrayStorage, AscendingSort> arrAsc;
    
    // Veri ekleme
    vector<int> testData = {5, 2, 8, 1, 9, 3};
    for (int val : testData) {
        vecAsc.add(val);
        vecDesc.add(val);
        arrAsc.add(val);
    }
    
    cout << "Sıralamadan önce:" << endl;
    vecAsc.display();
    
    // Farklı şekillerde sıralama
    vecAsc.sort();
    vecDesc.sort();
    arrAsc.sort();
    
    cout << "Vector + Ascending:" << endl;
    vecAsc.display();
    
    cout << "Vector + Descending:" << endl;
    vecDesc.display();
    
    cout << "Array + Ascending:" << endl;
    arrAsc.display();
    
    return 0;
}
```

## Performans Karşılaştırması

Statik vs dinamik polimorfizm performans farkı:

```cpp
#include <iostream>
#include <chrono>
#include <vector>
#include <memory>
using namespace std;
using namespace chrono;

// DİNAMİK POLİMORFİZM (VIRTUAL FUNCTIONS) - Çalışma zamanı polimorfizmi
class DynamicBase {
public:
    virtual ~DynamicBase() = default;    // Virtual destructor: safe polymorphic destruction
    virtual int process(int x) = 0;      // Pure virtual function: interface contract
    /*
     * DİNAMİK POLİMORFİZM ÖZELLİKLERİ:
     * - Virtual function table (vtable) kullanır
     * - Runtime'da function lookup yapar
     * - Indirect function call (pointer dereferencing)
     * - Memory overhead: vtable pointer per object
     * - CPU overhead: vtable lookup per call
     * 
     * AVANTAJLAR:
     * - Runtime'da farklı türlerle çalışabilir
     * - Heterogeneous collections mümkün
     * - Plugin systems için ideal
     * - Runtime type determination
     * 
     * DEZAVANTAJLAR:
     * - Virtual function call overhead
     * - Cache miss riski (indirect calls)
     * - Compiler optimization limitations
     * - Memory overhead (vtable pointer)
     */
};

class DynamicDerived : public DynamicBase {
public:
    int process(int x) override {
        return x * x;    // Basit matematiksel işlem: kare alma
        /*
         * OVERRIDE KEYWORD (C++11):
         * - Virtual function'ı override ettiğini belirtir
         * - Compile-time'da signature checking
         * - Typo'ları ve hataları yakalar
         * - Intent'i açık şekilde belirtir
         */
    }
};

// STATİK POLİMORFİZM (CRTP) - Derleme zamanı polimorfizmi
template<typename Derived>
class StaticBase {
public:
    int process(int x) {
        return static_cast<Derived*>(this)->process(x);
        /*
         * STATİK POLİMORFİZM ÖZELLİKLERİ:
         * - Compile-time'da function resolution
         * - Direct function call (no indirection)
         * - No vtable overhead
         * - Inline optimization mümkün
         * - Better cache locality
         * 
         * AVANTAJLAR:
         * - Maximum performance: no virtual call overhead
         * - Compile-time type safety
         * - Compiler optimization friendly
         * - Template specialization mümkün
         * - No memory overhead
         * 
         * DEZAVANTAJLAR:
         * - Compile-time'da türler bilinmeli
         * - Heterogeneous collections zor
         * - Code bloat riski (template instantiation)
         * - Runtime type switching imkansız
         */
    }
};

class StaticDerived : public StaticBase<StaticDerived> {
public:
    int process(int x) {
        return x * x;    // Aynı işlem: performance farkını görmek için
    }
};

// TEMPLATE FONKSİYON (EN HIZLI) - Pure template approach
template<typename T>
int templateProcess(T processor, int x) {
    return processor.process(x);
    /*
     * TEMPLATE FUNCTION ÖZELLİKLERİ:
     * - Compile-time'da tam optimizasyon
     * - Inline expansion guaranteed
     * - No inheritance overhead
     * - Direct member function call
     * - Best possible performance
     * 
     * KULLANIM:
     * - Header-only libraries
     * - High-performance computing
     * - Generic algorithms
     * - STL-style programming
     */
}

int main() {
    const int ITERATIONS = 1000000;    // 1 milyon iterasyon
    const int OBJECT_COUNT = 1000;     // 1000 nesne
    
    cout << "=== POLİMORFİZM PERFORMANS KARŞILAŞTIRMASI ===" << endl;
    cout << "Test parametreleri:" << endl;
    cout << "• İterasyon sayısı: " << ITERATIONS << endl;
    cout << "• Nesne sayısı: " << OBJECT_COUNT << endl;
    cout << "• İşlem: x * x (kare alma)" << endl;
    
    // DİNAMİK POLİMORFİZM TEST HAZIRLIĞI
    cout << "\n1. Dinamik Polimorfizm Testi Hazırlığı..." << endl;
    vector<unique_ptr<DynamicBase>> dynamicObjects;
    for (int i = 0; i < OBJECT_COUNT; i++) {
        dynamicObjects.push_back(make_unique<DynamicDerived>());
    }
    cout << "• " << OBJECT_COUNT << " DynamicDerived nesnesi oluşturuldu" << endl;
    cout << "• Her nesne için vtable pointer overhead: " << sizeof(void*) << " bytes" << endl;
    
    // DİNAMİK POLİMORFİZM PERFORMANCE TEST
    cout << "\n2. Dinamik Polimorfizm Performance Testi..." << endl;
    auto start = high_resolution_clock::now();
    long long sum1 = 0;
    
    for (int i = 0; i < ITERATIONS; i++) {
        // Virtual function call: vtable lookup + indirect call
        sum1 += dynamicObjects[i % dynamicObjects.size()]->process(i);
        /*
         * DİNAMİK ÇAĞRI SÜRECİ:
         * 1. object->process(i) çağrısı
         * 2. Nesnenin vtable pointer'ına erişim
         * 3. Vtable'da process fonksiyonunun adresini bulma
         * 4. Indirect function call
         * 5. Fonksiyon çalıştırılması
         */
    }
    
    auto end = high_resolution_clock::now();
    auto dynamicTime = duration_cast<microseconds>(end - start);
    cout << "• Sonuç toplam: " << sum1 << endl;
    cout << "• Süre: " << dynamicTime.count() << " mikrosaniye" << endl;
    
    // STATİK POLİMORFİZM TEST HAZIRLIĞI
    cout << "\n3. Statik Polimorfizm Testi Hazırlığı..." << endl;
    vector<StaticDerived> staticObjects(OBJECT_COUNT);
    cout << "• " << OBJECT_COUNT << " StaticDerived nesnesi oluşturuldu" << endl;
    cout << "• Vtable overhead yok, sadece veri: minimal memory footprint" << endl;
    
    // STATİK POLİMORFİZM PERFORMANCE TEST
    cout << "\n4. Statik Polimorfizm Performance Testi..." << endl;
    start = high_resolution_clock::now();
    long long sum2 = 0;
    
    for (int i = 0; i < ITERATIONS; i++) {
        // CRTP call: compile-time resolution + direct call
        sum2 += staticObjects[i % staticObjects.size()].process(i);
        /*
         * STATİK ÇAĞRI SÜRECİ:
         * 1. staticObject.process(i) çağrısı
         * 2. Compile-time'da StaticDerived::process'e resolve
         * 3. Direct function call (inline olabilir)
         * 4. Fonksiyon çalıştırılması
         */
    }
    
    end = high_resolution_clock::now();
    auto staticTime = duration_cast<microseconds>(end - start);
    cout << "• Sonuç toplam: " << sum2 << endl;
    cout << "• Süre: " << staticTime.count() << " mikrosaniye" << endl;
    
    // TEMPLATE FONKSİYON TEST HAZIRLIĞI
    cout << "\n5. Template Function Testi Hazırlığı..." << endl;
    StaticDerived templateObj;
    cout << "• Template test için StaticDerived nesnesi hazırlandı" << endl;
    
    // TEMPLATE FUNCTION PERFORMANCE TEST
    cout << "\n6. Template Function Performance Testi..." << endl;
    start = high_resolution_clock::now();
    long long sum3 = 0;
    
    for (int i = 0; i < ITERATIONS; i++) {
        // Template call: best possible optimization
        sum3 += templateProcess(templateObj, i);
        /*
         * TEMPLATE ÇAĞRI SÜRECİ:
         * 1. templateProcess(templateObj, i) çağrısı
         * 2. Compile-time'da tam inline expansion
         * 3. processor.process(x) -> templateObj.process(i) direct call
         * 4. Muhtemelen tek assembly instruction'a optimize edilir
         */
    }
    
    end = high_resolution_clock::now();
    auto templateTime = duration_cast<microseconds>(end - start);
    cout << "• Sonuç toplam: " << sum3 << endl;
    cout << "• Süre: " << templateTime.count() << " mikrosaniye" << endl;
    
    // SONUÇLARI KARŞILAŞTIR
    cout << "\n=== PERFORMANCE SONUÇLARI ===" << endl;
    cout << "Test süresi (" << ITERATIONS << " iterasyon):" << endl;
    printf("• Dinamik polimorfizm:  %8ld mikrosaniye\n", dynamicTime.count());
    printf("• Statik polimorfizm:   %8ld mikrosaniye\n", staticTime.count());
    printf("• Template function:    %8ld mikrosaniye\n", templateTime.count());
    
    cout << "\nPerformans oranları (düşük = daha hızlı):" << endl;
    printf("• Statik/Dinamik oranı:   %.3f (statik ne kadar hızlı)\n", 
           (double)staticTime.count() / dynamicTime.count());
    printf("• Template/Dinamik oranı: %.3f (template ne kadar hızlı)\n", 
           (double)templateTime.count() / dynamicTime.count());
    printf("• Template/Statik oranı:  %.3f (template vs statik)\n", 
           (double)templateTime.count() / staticTime.count());
    
    // SONUÇLARI DOĞRULA - Hepsi aynı matematiksel işlemi yaptı mı?
    cout << "\nSonuç doğrulama:" << endl;
    cout << "• Tüm yöntemler aynı sonucu verdi mi? " 
         << (sum1 == sum2 && sum2 == sum3 ? "✓ Evet" : "✗ Hayır") << endl;
    cout << "• Dinamik toplam: " << sum1 << endl;
    cout << "• Statik toplam:  " << sum2 << endl;
    cout << "• Template toplam: " << sum3 << endl;
    
    // MEMORY USAGE ANALİZİ
    cout << "\n=== MEMORY KULLANIM ANALİZİ ===" << endl;
    cout << "Nesne başına memory kullanımı:" << endl;
    cout << "• DynamicBase nesne boyutu: " << sizeof(DynamicDerived) << " bytes (vtable pointer dahil)" << endl;
    cout << "• StaticBase nesne boyutu:  " << sizeof(StaticDerived) << " bytes (vtable yok)" << endl;
    
    size_t dynamicMemory = OBJECT_COUNT * sizeof(DynamicDerived);
    size_t staticMemory = OBJECT_COUNT * sizeof(StaticDerived);
    cout << "• Toplam dynamic memory: " << dynamicMemory << " bytes" << endl;
    cout << "• Toplam static memory:  " << staticMemory << " bytes" << endl;
    cout << "• Memory tasarrufu: " << (dynamicMemory - staticMemory) << " bytes" << endl;
    
    cout << "\n=== OPTIMIZATION NOTES ===" << endl;
    cout << "Compiler optimizations etkisi:" << endl;
    cout << "• Release mode (-O2/-O3): Farklar daha belirgin olur" << endl;
    cout << "• Debug mode (-g): Virtual call overhead maskelenebilir" << endl;
    cout << "• Inline expansion: Template > Statik > Dinamik" << endl;
    cout << "• Cache locality: Statik > Dinamik (indirect calls)" << endl;
    cout << "• Branch prediction: Direct calls > Indirect calls" << endl;
    
    /*
     * BEKLENEN SONUÇLAR (Release mode):
     * 
     * Tipik performance hierarchy:
     * 1. Template function (en hızlı): ~100-200 mikrosaniye
     * 2. Static polymorphism: ~150-300 mikrosaniye  
     * 3. Dynamic polymorphism (en yavaş): ~500-1000 mikrosaniye
     * 
     * Performance ratios:
     * - Static/Dynamic: 0.3-0.6 (static 2-3x daha hızlı)
     * - Template/Dynamic: 0.1-0.4 (template 2.5-10x daha hızlı)
     * - Template/Static: 0.5-0.9 (template biraz daha hızlı)
     * 
     * PLATFORM DEPENDENT:
     * - CPU architecture (x86, ARM, etc.)
     * - Compiler (GCC, Clang, MSVC)
     * - Optimization level
     * - Cache size ve hierarchy
     */
    
    return 0;
}
```

## En İyi Uygulamalar

## En İyi Uygulamalar

### 1. Statik vs Dinamik Polimorfizm Seçimi

Statik ve dinamik polimorfizm arasında doğru seçim yapmak, uygulamanın performansını ve maintainability'sini doğrudan etkiler. Her yaklaşımın kendine özgü avantajları ve kullanım senaryoları vardır.

**Statik Polimorfizm Tercih Edilmeli:**
- **Performance Critical Code**: Game engines, real-time systems, embedded programming
- **Compile-time Type Knowledge**: Türler derleme zamanında biliniyor
- **Template Libraries**: STL benzeri generic library development
- **Mathematical Operations**: Yoğun matematik hesaplamaları
- **Memory Constrained Environments**: Vtable overhead'ini önlemek gerektiğinde

**Dinamik Polimorfizm Tercih Edilmeli:**
- **Runtime Type Determination**: Türler çalışma zamanında belirleniyor
- **Plugin Architectures**: Dynamic library loading, plugin systems
- **Object-Oriented Design**: Classic inheritance hierarchies
- **Heterogeneous Collections**: Farklı türde nesnelerin aynı container'da tutulması
- **Interface Segregation**: Runtime'da interface değişimi gerektiğinde

**Hybrid Approaches**: Bazı durumlarda her ikisi birlikte kullanılabilir

```cpp
// STATİK POLİMORFİZM KULLANIN - Performans odaklı senaryolar
// Aşağıdaki durumlar statik polimorfizm için idealdir:

template<typename T>
void processMany(const vector<T>& objects) {
    for (const auto& obj : objects) {
        obj.process();  // Inline optimizasyonu mümkün
    }
    /*
     * STATİK POLİMORFİZM AVANTAJLARI:
     * - Performans kritikse: Virtual function call overhead yok
     * - Türler derleme zamanında biliniyorsa: Type safety
     * - Polimorfik davranış sık çağrılıyorsa: CPU optimization
     * - Template metaprogramming gerekiyorsa: Compile-time computation
     * 
     * KULLANIM ALANLARI:
     * - High-frequency trading systems
     * - Game engines (render loops)
     * - Scientific computing
     * - Embedded systems
     * - Header-only libraries
     * 
     * TEMPLATE İNSTANTİATİON:
     * processMany<StaticDerived>(staticObjects);  // Compile-time resolution
     * processMany<AnotherDerived>(otherObjects);  // Different instantiation
     */
}

// DİNAMİK POLİMORFİZM KULLANIN - Esneklik odaklı senaryolar
// Aşağıdaki durumlar dinamik polimorfizm için idealdir:

void processMixed(const vector<unique_ptr<Base>>& objects) {
    for (const auto& obj : objects) {
        obj->process();  // Virtual function call
    }
    /*
     * DİNAMİK POLİMORFİZM AVANTAJLARI:
     * - Çalışma zamanında tür belirsizliği varsa: Runtime flexibility
     * - Plugin sistemi gibi runtime loading gerekiyorsa: Dynamic loading
     * - Heterogen koleksiyonlar kullanıyorsanız: Mixed type containers
     * - Factory patterns kullanıyorsanız: Object creation flexibility
     * 
     * KULLANIM ALANLARI:
     * - Plugin architectures
     * - GUI frameworks
     * - Serialization systems
     * - Command pattern implementations
     * - Observer pattern implementations
     * 
     * HETEROGENEOUS COLLECTIONS:
     * vector<unique_ptr<Shape>> shapes;
     * shapes.push_back(make_unique<Circle>());
     * shapes.push_back(make_unique<Rectangle>());
     * shapes.push_back(make_unique<Triangle>());
     * processMixed(shapes);  // Runtime dispatch
     */
}

/*
 * SEÇIM KRİTERLERİ TABLOSU:
 * 
 * | Özellik                    | Statik       | Dinamik      |
 * |----------------------------|--------------|--------------|
 * | Performance                | Yüksek       | Orta         |
 * | Runtime Flexibility        | Düşük        | Yüksek       |
 * | Compile-time Type Safety   | Yüksek       | Orta         |
 * | Memory Overhead            | Düşük        | Orta         |
 * | Code Size                  | Büyük*       | Küçük        |
 * | Plugin Support             | Zor          | Kolay        |
 * | Inline Optimization        | Mümkün       | Sınırlı      |
 * | Mixed Type Collections     | Zor          | Kolay        |
 * 
 * * Template instantiation nedeniyle code bloat olabilir
 */
```

### 2. Compile-Time vs Runtime Hata Yakalama

Statik polimorfizm, hataların derleme zamanında yakalanmasını sağlarken, dinamik polimorfizm çoğu hatayı çalışma zamanına bırakır. Bu fundamental fark, debugging, testing ve code reliability açısından kritik öneme sahiptir.

**Compile-Time Hata Yakalama Avantajları:**
- **Early Error Detection**: Hatalar derleme sırasında yakalanır
- **Zero Runtime Cost**: Çalışma zamanında hata kontrolü overhead'i yok
- **Better IDE Support**: Code completion, IntelliSense desteği
- **Type Safety Guarantees**: Template system ile güçlü tür kontrolü
- **Refactoring Safety**: Büyük code base'lerde güvenli refactoring

**Runtime Hata Yakalama Durumları:**
- **Dynamic Type Loading**: Plugin systems, reflection scenarios
- **User Input Validation**: Kullanıcı girdilerinin kontrolü
- **External Resource Access**: File, network, database operations
- **Complex Business Logic**: Çalışma zamanında belirlenen kurallı

**Best Practices:**
- Mümkün olduğunda compile-time constraints kullanın
- Runtime validation sadece gerekli durumlarda yapın
- SFINAE, concepts, static_assert tekniklerini kullanın

```cpp
#include <type_traits>

// COMPILE-TIME CONSTRAINT - Derleme zamanı tür kontrolü
// Modern C++ ile güçlü type checking mekanizmaları

template<typename T>
void processNumeric(T value) {
    // static_assert: Compile-time'da condition check
    static_assert(is_arithmetic_v<T>, "T must be numeric type");
    /*
     * STATIC_ASSERT ÖZELLİKLERİ:
     * - Compile-time'da koşul kontrolü
     * - Koşul false ise compilation error
     * - Template constraints için ideal
     * - Error message customization
     * - Zero runtime cost
     * 
     * KULLANIM ALANLARI:
     * - Template parameter validation
     * - Platform-specific requirements
     * - API contract enforcement
     * - Type trait validation
     */
    
    // Implementation: sadece numeric türler için çalışır
    cout << "Processing numeric value: " << value << endl;
}

// SFINAE İLE TYPE CHECKING - Substitution Failure Is Not An Error
// Template metaprogramming ile conditional compilation

// INTEGER türleri için özelleştirilmiş fonksiyon
template<typename T>
enable_if_t<is_integral_v<T>, void>
processInteger(T value) {
    cout << "Processing integer: " << value << endl;
    cout << "• Bit size: " << sizeof(T) * 8 << " bits" << endl;
    cout << "• Signed: " << (is_signed_v<T> ? "Yes" : "No") << endl;
    cout << "• Min value: " << numeric_limits<T>::min() << endl;
    cout << "• Max value: " << numeric_limits<T>::max() << endl;
    /*
     * SFINAE ÇALIŞMA PRENSİBİ:
     * 1. enable_if_t<is_integral_v<T>, void> koşulu değerlendirilir
     * 2. T integral değilse, substitution failure olur
     * 3. Compiler bu fonksiyonu overload set'ten çıkarır
     * 4. Hata vermez, başka overload arar (SFINAE)
     * 
     * TEMPLATE TYPE TRAITS:
     * - is_integral_v<T>: T integral tür mü?
     * - is_signed_v<T>: T signed tür mü?
     * - numeric_limits<T>: T türü için limit bilgileri
     */
}

// FLOATING-POINT türleri için özelleştirilmiş fonksiyon
template<typename T>
enable_if_t<is_floating_point_v<T>, void>
processFloat(T value) {
    cout << "Processing floating-point: " << value << endl;
    cout << "• Precision: " << numeric_limits<T>::digits10 << " decimal digits" << endl;
    cout << "• Epsilon: " << numeric_limits<T>::epsilon() << endl;
    cout << "• Min positive: " << numeric_limits<T>::min() << endl;
    cout << "• Max value: " << numeric_limits<T>::max() << endl;
    cout << "• Infinity: " << numeric_limits<T>::infinity() << endl;
    /*
     * FLOATING-POINT SPECİFİC FEATURES:
     * - Precision handling
     * - Epsilon comparison
     * - Special values (inf, nan)
     * - IEEE 754 compliance
     */
}

// MODERN C++20 CONCEPTS - Daha okunabilir type constraints
// C++20 ile gelen yeni syntax

#if __cplusplus >= 202002L  // C++20 check
template<std::integral T>
void processIntegerConcept(T value) {
    cout << "C++20 concept: Processing integer " << value << endl;
}

template<std::floating_point T>
void processFloatConcept(T value) {
    cout << "C++20 concept: Processing float " << value << endl;
}
#endif

// EXAMPLE USAGE ve TEST FUNCTİONS
void demonstrateTypeConstraints() {
    cout << "=== COMPILE-TIME TYPE CONSTRAINT DEMO ===" << endl;
    
    // NUMERIC CONSTRAINT TEST
    cout << "\n1. Numeric Constraint Testi:" << endl;
    processNumeric(42);        // int: OK
    processNumeric(3.14);      // double: OK
    processNumeric(5.0f);      // float: OK
    // processNumeric("text");    // COMPILE ERROR: string is not arithmetic
    
    // SFINAE TYPE CHECKING TEST
    cout << "\n2. SFINAE Type Checking:" << endl;
    
    // Integer processing
    cout << "\nInteger types:" << endl;
    processInteger(42);         // int
    processInteger(100L);       // long
    processInteger(static_cast<short>(5)); // short
    
    // Floating-point processing
    cout << "\nFloating-point types:" << endl;
    processFloat(3.14);         // double
    processFloat(2.5f);         // float
    processFloat(1.23L);        // long double
    
    // COMPILE-TIME ERROR EXAMPLES (uncomment to see errors)
    // processInteger(3.14);    // COMPILE ERROR: double is not integral
    // processFloat(42);        // COMPILE ERROR: int is not floating_point
    
    cout << "\n=== TYPE TRAIT USAGE EXAMPLES ===" << endl;
    cout << "Type checking results:" << endl;
    cout << "• is_integral_v<int>: " << is_integral_v<int> << endl;
    cout << "• is_floating_point_v<double>: " << is_floating_point_v<double> << endl;
    cout << "• is_arithmetic_v<string>: " << is_arithmetic_v<string> << endl;
    cout << "• is_signed_v<unsigned int>: " << is_signed_v<unsigned int> << endl;
    
    /*
     * COMPILE-TIME vs RUNTIME ERROR COMPARISON:
     * 
     * COMPILE-TIME (static_assert, SFINAE, concepts):
     * ✓ Errors caught early in development
     * ✓ Zero runtime cost
     * ✓ Better optimization opportunities
     * ✓ Type safety guaranteed
     * ✗ Less flexibility
     * ✗ More complex template code
     * 
     * RUNTIME (dynamic_cast, typeid, exception):
     * ✓ Maximum flexibility
     * ✓ Runtime type decisions
     * ✓ Plugin/dynamic loading support
     * ✗ Runtime performance cost
     * ✗ Potential runtime failures
     * ✗ Harder to debug
     */
}

/*
 * BEST PRACTICES SUMMARY:
 * 
 * 1. USE STATIC POLYMORPHISM WHEN:
 *    - Performance is critical
 *    - Types are known at compile-time
 *    - Building header-only libraries
 *    - Working with template metaprogramming
 * 
 * 2. USE DYNAMIC POLYMORPHISM WHEN:
 *    - Need runtime flexibility
 *    - Working with plugin systems
 *    - Managing heterogeneous collections
 *    - Building frameworks with stable ABIs
 * 
 * 3. TYPE CONSTRAINTS:
 *    - Use static_assert for simple constraints
 *    - Use SFINAE for conditional compilation
 *    - Use concepts in C++20 for better readability
 *    - Prefer compile-time errors over runtime errors
 * 
 * 4. PERFORMANCE CONSIDERATIONS:
 *    - Profile both approaches for your use case
 *    - Consider code size vs execution speed tradeoffs
 *    - Template instantiation can increase binary size
 *    - Virtual calls may not be bottleneck in all cases
 */
```

Statik polimorfizm, C++'ın en güçlü özelliklerinden biridir. Doğru kullanıldığında, hem performans hem de type safety açısından büyük avantajlar sağlar. Özellikle library design ve generic programming alanlarında vazgeçilmez bir araçtır.
