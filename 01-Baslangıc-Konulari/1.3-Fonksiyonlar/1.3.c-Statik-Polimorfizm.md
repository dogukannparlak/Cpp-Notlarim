# Polimorfizm Nedir ?

Polimorfizm, aynı interface'e sahip farklı türlerin, farklı davranışlar sergileyebilmesi yeteneğidir. C++'da iki ana polimorfizm türü vardır:

- **Dinamik Polimorfizm**: Virtual fonksiyonlar ile çalışma zamanında çözümlenir
- **Statik Polimorfizm**: Template'ler ve function overloading ile derleme zamanında çözümlenir

Statik polimorfizm, performans avantajı sağlarken, dinamik polimorfizm çalışma zamanı esnekliği sunar.

# Statik Polimorfizm

Statik polimorfizm, C++'da **derleyici zamanında (compile-time)** çözümlenen polimorfizm türüdür. Çalışma zamanında (runtime) herhangi bir performans maliyeti olmadan, farklı türler için farklı davranışlar sergileyebilir. Bu, dinamik polimorfizmden (virtual fonksiyonlar) farklı olarak, derleme sırasında hangi fonksiyonun çağrılacağının belirlenmesi anlamına gelir.

## Statik Polimorfizmin Türleri

C++'da statik polimorfizm başlıca şu yöntemlerle gerçekleştirilir:

1. **Function Overloading** (Fonksiyon Aşırı Yükleme)
2. **Template Specialization** (Şablon Özelleştirme)
3. **CRTP (Curiously Recurring Template Pattern)**
4. **Template Metaprogramming**

## Function Overloading ile Statik Polimorfizm

Fonksiyon overloading, en basit statik polimorfizm türüdür:

```cpp
#include <iostream>
#include <string>
using namespace std;

class Printer {
public:
    // Farklı türler için aynı isimde fonksiyonlar
    void print(int value) {
        cout << "Integer: " << value << endl;
    }
    
    void print(double value) {
        cout << "Double: " << value << endl;
    }
    
    void print(const string& value) {
        cout << "String: " << value << endl;
    }
    
    void print(char value) {
        cout << "Character: " << value << endl;
    }
    
    // Çoklu parametre overloading
    void print(int x, int y) {
        cout << "Koordinat: (" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Printer p;
    
    // Derleyici parametre türüne göre doğru fonksiyonu seçer
    p.print(42);           // int versiyonu
    p.print(3.14);         // double versiyonu
    p.print("Merhaba");    // string versiyonu
    p.print('A');          // char versiyonu
    p.print(10, 20);       // çoklu parametre versiyonu
    
    return 0;
}
```

## Template ile Statik Polimorfizm

Template'ler, türden bağımsız kod yazmaya olanak sağlar:

### Function Templates

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Generic function template
template<typename T>
void display(const T& value) {
    cout << "Değer: " << value << endl;
}

// Çoklu template parametreli fonksiyon
template<typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
    return a + b;
}

// Template ile generic algoritma
template<typename T>
T findMax(const vector<T>& vec) {
    if (vec.empty()) {
        throw invalid_argument("Boş vektör!");
    }
    
    T maxVal = vec[0];
    for (const T& item : vec) {
        if (item > maxVal) {
            maxVal = item;
        }
    }
    return maxVal;
}

int main() {
    // Farklı türlerle aynı fonksiyon
    display(42);
    display(3.14);
    display("Merhaba");
    display('X');
    
    // Farklı türleri toplama
    cout << "int + double: " << add(5, 3.14) << endl;
    cout << "string + string: " << add(string("C"), string("++")) << endl;
    
    // Generic algoritma kullanımı
    vector<int> intVec = {1, 5, 3, 9, 2};
    vector<string> stringVec = {"elma", "zebra", "armut", "çilek"};
    
    cout << "Max int: " << findMax(intVec) << endl;
    cout << "Max string: " << findMax(stringVec) << endl;
    
    return 0;
}
```

### Class Templates

```cpp
#include <iostream>
#include <stdexcept>
using namespace std;

// Generic container sınıfı
template<typename T, size_t N>
class Array {
private:
    T data[N];
    
public:
    // Element erişimi
    T& operator[](size_t index) {
        if (index >= N) {
            throw out_of_range("Index dışında!");
        }
        return data[index];
    }
    
    const T& operator[](size_t index) const {
        if (index >= N) {
            throw out_of_range("Index dışında!");
        }
        return data[index];
    }
    
    // Boyut
    constexpr size_t size() const { return N; }
    
    // Doldurma
    void fill(const T& value) {
        for (size_t i = 0; i < N; i++) {
            data[i] = value;
        }
    }
    
    // Iterator support
    T* begin() { return data; }
    T* end() { return data + N; }
    const T* begin() const { return data; }
    const T* end() const { return data + N; }
};

// Template sınıfında static member
template<typename T>
class Counter {
private:
    static int count;
    T value;
    
public:
    Counter(T val) : value(val) { count++; }
    ~Counter() { count--; }
    
    static int getCount() { return count; }
    T getValue() const { return value; }
};

// Static member tanımı
template<typename T>
int Counter<T>::count = 0;

int main() {
    // Farklı türler ve boyutlar için Array
    Array<int, 5> intArray;
    Array<string, 3> stringArray;
    Array<double, 10> doubleArray;
    
    // int array kullanımı
    intArray.fill(42);
    intArray[0] = 100;
    
    cout << "Int array boyutu: " << intArray.size() << endl;
    cout << "İlk eleman: " << intArray[0] << endl;
    
    // string array kullanımı
    stringArray[0] = "Bir";
    stringArray[1] = "İki";
    stringArray[2] = "Üç";
    
    cout << "String array elemanları: ";
    for (const auto& item : stringArray) {
        cout << item << " ";
    }
    cout << endl;
    
    // Counter kullanımı
    Counter<int> c1(10);
    Counter<int> c2(20);
    Counter<string> c3("test");
    
    cout << "Int Counter sayısı: " << Counter<int>::getCount() << endl;
    cout << "String Counter sayısı: " << Counter<string>::getCount() << endl;
    
    return 0;
}
```

## Template Specialization

Template specialization, belirli türler için özel davranışlar tanımlamanıza olanak sağlar:

### Full Specialization

```cpp
#include <iostream>
#include <string>
#include <cstring>
using namespace std;

// Generic template
template<typename T>
class Serializer {
public:
    static string serialize(const T& obj) {
        return "Generic serialization: " + to_string(reinterpret_cast<uintptr_t>(&obj));
    }
};

// int için specialization
template<>
class Serializer<int> {
public:
    static string serialize(const int& value) {
        return "INT:" + to_string(value);
    }
};

// string için specialization
template<>
class Serializer<string> {
public:
    static string serialize(const string& value) {
        return "STR:" + value;
    }
};

// double için specialization
template<>
class Serializer<double> {
public:
    static string serialize(const double& value) {
        return "DBL:" + to_string(value);
    }
};

// Pointer'lar için partial specialization
template<typename T>
class Serializer<T*> {
public:
    static string serialize(T* const& ptr) {
        if (ptr == nullptr) {
            return "NULL_PTR";
        }
        return "PTR:" + Serializer<T>::serialize(*ptr);
    }
};

int main() {
    int i = 42;
    double d = 3.14;
    string s = "Merhaba";
    char c = 'X';
    int* ptr = &i;
    int* nullPtr = nullptr;
    
    cout << Serializer<int>::serialize(i) << endl;
    cout << Serializer<double>::serialize(d) << endl;
    cout << Serializer<string>::serialize(s) << endl;
    cout << Serializer<char>::serialize(c) << endl;  // Generic
    cout << Serializer<int*>::serialize(ptr) << endl;
    cout << Serializer<int*>::serialize(nullPtr) << endl;
    
    return 0;
}
```

### Function Template Specialization

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Generic template function
template<typename T>
void process(const T& value) {
    cout << "Generic processing: " << value << endl;
}

// int için specialization
template<>
void process<int>(const int& value) {
    cout << "Integer processing: " << value * 2 << endl;
}

// string için specialization
template<>
void process<string>(const string& value) {
    cout << "String processing: " << value << " (length: " << value.length() << ")" << endl;
}

// Container'lar için generic fonksiyon
template<typename Container>
void printContainer(const Container& container) {
    cout << "Container içeriği: ";
    for (const auto& item : container) {
        cout << item << " ";
    }
    cout << endl;
}

// vector<bool> için specialization (özel durum)
template<>
void printContainer<vector<bool>>(const vector<bool>& container) {
    cout << "Bool vector içeriği: ";
    for (size_t i = 0; i < container.size(); i++) {
        cout << (container[i] ? "true" : "false") << " ";
    }
    cout << endl;
}

int main() {
    process(42);
    process(3.14);
    process(string("Merhaba"));
    
    vector<int> intVec = {1, 2, 3, 4, 5};
    vector<string> stringVec = {"a", "b", "c"};
    vector<bool> boolVec = {true, false, true, false};
    
    printContainer(intVec);
    printContainer(stringVec);
    printContainer(boolVec);  // Özel davranış
    
    return 0;
}
```

## CRTP (Curiously Recurring Template Pattern)

CRTP, statik polimorfizminin en gelişmiş tekniklerinden biridir:

### Temel CRTP

```cpp
#include <iostream>
using namespace std;

// Base template sınıfı
template<typename Derived>
class Animal {
public:
    void makeSound() {
        // Static cast ile türetilmiş sınıfa erişim
        static_cast<Derived*>(this)->makeSound();
    }
    
    void move() {
        static_cast<Derived*>(this)->move();
    }
    
    // Interface fonksiyonu
    void dailyRoutine() {
        cout << "Günlük rutin başlıyor..." << endl;
        makeSound();
        move();
        cout << "Günlük rutin bitti." << endl;
    }
};

// Türetilmiş sınıflar
class Dog : public Animal<Dog> {
public:
    void makeSound() {
        cout << "Köpek: Hav hav!" << endl;
    }
    
    void move() {
        cout << "Köpek koşuyor..." << endl;
    }
};

class Cat : public Animal<Cat> {
public:
    void makeSound() {
        cout << "Kedi: Miyav!" << endl;
    }
    
    void move() {
        cout << "Kedi sinsice yürüyor..." << endl;
    }
};

class Bird : public Animal<Bird> {
public:
    void makeSound() {
        cout << "Kuş: Cik cik!" << endl;
    }
    
    void move() {
        cout << "Kuş uçuyor..." << endl;
    }
};

int main() {
    Dog dog;
    Cat cat;
    Bird bird;
    
    dog.dailyRoutine();
    cout << "---" << endl;
    cat.dailyRoutine();
    cout << "---" << endl;
    bird.dailyRoutine();
    
    return 0;
}
```

### CRTP ile Singleton Pattern

```cpp
#include <iostream>
#include <string>
using namespace std;

// CRTP Singleton base sınıfı
template<typename T>
class Singleton {
protected:
    Singleton() = default;
    virtual ~Singleton() = default;
    
public:
    // Copy ve assignment'ı engelle
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    
    static T& getInstance() {
        static T instance;
        return instance;
    }
};

// Singleton kullanımı
class Logger : public Singleton<Logger> {
    friend class Singleton<Logger>;  // Base sınıfın constructor'a erişimi için
    
private:
    string logLevel;
    
    Logger() : logLevel("INFO") {}  // Private constructor
    
public:
    void log(const string& message) {
        cout << "[" << logLevel << "] " << message << endl;
    }
    
    void setLogLevel(const string& level) {
        logLevel = level;
    }
    
    string getLogLevel() const {
        return logLevel;
    }
};

class DatabaseManager : public Singleton<DatabaseManager> {
    friend class Singleton<DatabaseManager>;
    
private:
    bool connected;
    
    DatabaseManager() : connected(false) {}
    
public:
    void connect() {
        connected = true;
        cout << "Veritabanına bağlanıldı." << endl;
    }
    
    void disconnect() {
        connected = false;
        cout << "Veritabanı bağlantısı kesildi." << endl;
    }
    
    bool isConnected() const {
        return connected;
    }
};

int main() {
    // Logger singleton kullanımı
    Logger& logger1 = Logger::getInstance();
    Logger& logger2 = Logger::getInstance();
    
    // Aynı instance olduğunu kontrol et
    cout << "Logger instance'ları aynı mı? " 
         << (&logger1 == &logger2 ? "Evet" : "Hayır") << endl;
    
    logger1.setLogLevel("DEBUG");
    logger1.log("İlk mesaj");
    logger2.log("İkinci mesaj");  // Aynı log level'ı kullanır
    
    // DatabaseManager singleton
    DatabaseManager& db = DatabaseManager::getInstance();
    db.connect();
    cout << "Bağlantı durumu: " << (db.isConnected() ? "Bağlı" : "Bağlı değil") << endl;
    
    return 0;
}
```

### CRTP ile Policy-Based Design

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Storage policy'leri
template<typename T>
class VectorStorage {
protected:
    vector<T> data;
    
public:
    void add(const T& item) { data.push_back(item); }
    T& get(size_t index) { return data[index]; }
    size_t size() const { return data.size(); }
    
    typename vector<T>::iterator begin() { return data.begin(); }
    typename vector<T>::iterator end() { return data.end(); }
};

template<typename T>
class ArrayStorage {
protected:
    static constexpr size_t MAX_SIZE = 100;
    T data[MAX_SIZE];
    size_t currentSize = 0;
    
public:
    void add(const T& item) {
        if (currentSize < MAX_SIZE) {
            data[currentSize++] = item;
        }
    }
    
    T& get(size_t index) { return data[index]; }
    size_t size() const { return currentSize; }
    
    T* begin() { return data; }
    T* end() { return data + currentSize; }
};

// Sorting policy'leri
class AscendingSort {
public:
    template<typename Iterator>
    static void sort(Iterator begin, Iterator end) {
        std::sort(begin, end);
    }
};

class DescendingSort {
public:
    template<typename Iterator>
    static void sort(Iterator begin, Iterator end) {
        std::sort(begin, end, greater<typename Iterator::value_type>());
    }
};

// CRTP ile policy-based container
template<typename T, template<typename> class StoragePolicy, typename SortPolicy>
class Container : private StoragePolicy<T> {
public:
    using StoragePolicy<T>::add;
    using StoragePolicy<T>::get;
    using StoragePolicy<T>::size;
    using StoragePolicy<T>::begin;
    using StoragePolicy<T>::end;
    
    void sort() {
        SortPolicy::sort(begin(), end());
    }
    
    void display() {
        cout << "Container içeriği: ";
        for (const auto& item : *this) {
            cout << item << " ";
        }
        cout << endl;
    }
};

int main() {
    // Farklı storage ve sorting policy kombinasyonları
    Container<int, VectorStorage, AscendingSort> vecAsc;
    Container<int, VectorStorage, DescendingSort> vecDesc;
    Container<int, ArrayStorage, AscendingSort> arrAsc;
    
    // Veri ekleme
    vector<int> testData = {5, 2, 8, 1, 9, 3};
    for (int val : testData) {
        vecAsc.add(val);
        vecDesc.add(val);
        arrAsc.add(val);
    }
    
    cout << "Sıralamadan önce:" << endl;
    vecAsc.display();
    
    // Farklı şekillerde sıralama
    vecAsc.sort();
    vecDesc.sort();
    arrAsc.sort();
    
    cout << "Vector + Ascending:" << endl;
    vecAsc.display();
    
    cout << "Vector + Descending:" << endl;
    vecDesc.display();
    
    cout << "Array + Ascending:" << endl;
    arrAsc.display();
    
    return 0;
}
```

## Performans Karşılaştırması

Statik vs dinamik polimorfizm performans farkı:

```cpp
#include <iostream>
#include <chrono>
#include <vector>
using namespace std;
using namespace chrono;

// Dinamik polimorfizm (virtual functions)
class DynamicBase {
public:
    virtual ~DynamicBase() = default;
    virtual int process(int x) = 0;
};

class DynamicDerived : public DynamicBase {
public:
    int process(int x) override {
        return x * x;
    }
};

// Statik polimorfizm (CRTP)
template<typename Derived>
class StaticBase {
public:
    int process(int x) {
        return static_cast<Derived*>(this)->process(x);
    }
};

class StaticDerived : public StaticBase<StaticDerived> {
public:
    int process(int x) {
        return x * x;
    }
};

// Template fonksiyon (en hızlı)
template<typename T>
int templateProcess(T processor, int x) {
    return processor.process(x);
}

int main() {
    const int ITERATIONS = 1000000;
    
    // Dinamik polimorfizm test
    vector<unique_ptr<DynamicBase>> dynamicObjects;
    for (int i = 0; i < 1000; i++) {
        dynamicObjects.push_back(make_unique<DynamicDerived>());
    }
    
    auto start = high_resolution_clock::now();
    long long sum1 = 0;
    for (int i = 0; i < ITERATIONS; i++) {
        sum1 += dynamicObjects[i % dynamicObjects.size()]->process(i);
    }
    auto end = high_resolution_clock::now();
    auto dynamicTime = duration_cast<microseconds>(end - start);
    
    // Statik polimorfizm test
    vector<StaticDerived> staticObjects(1000);
    
    start = high_resolution_clock::now();
    long long sum2 = 0;
    for (int i = 0; i < ITERATIONS; i++) {
        sum2 += staticObjects[i % staticObjects.size()].process(i);
    }
    end = high_resolution_clock::now();
    auto staticTime = duration_cast<microseconds>(end - start);
    
    // Template test
    StaticDerived templateObj;
    
    start = high_resolution_clock::now();
    long long sum3 = 0;
    for (int i = 0; i < ITERATIONS; i++) {
        sum3 += templateProcess(templateObj, i);
    }
    end = high_resolution_clock::now();
    auto templateTime = duration_cast<microseconds>(end - start);
    
    cout << "Sonuçlar (" << ITERATIONS << " iterasyon):" << endl;
    cout << "Dinamik polimorfizm: " << dynamicTime.count() << " mikrosaniye" << endl;
    cout << "Statik polimorfizm:  " << staticTime.count() << " mikrosaniye" << endl;
    cout << "Template:            " << templateTime.count() << " mikrosaniye" << endl;
    
    cout << "\nPerformans oranları:" << endl;
    cout << "Statik/Dinamik: " << (double)staticTime.count() / dynamicTime.count() << endl;
    cout << "Template/Dinamik: " << (double)templateTime.count() / dynamicTime.count() << endl;
    
    // Sonuçları doğrula
    cout << "\nSonuçlar doğru mu? " << (sum1 == sum2 && sum2 == sum3 ? "Evet" : "Hayır") << endl;
    
    return 0;
}
```

## En İyi Uygulamalar

### 1. Statik vs Dinamik Polimorfizm Seçimi

```cpp
// Statik polimorfizm kullanın:
// - Performans kritikse
// - Türler derleme zamanında biliniyorsa
// - Polimorfik davranış sık çağrılıyorsa

template<typename T>
void processMany(const vector<T>& objects) {
    for (const auto& obj : objects) {
        obj.process();  // Inline optimizasyonu mümkün
    }
}

// Dinamik polimorfizm kullanın:
// - Çalışma zamanında tür belirsizliği varsa
// - Plugin sistemi gibi runtime loading gerekiyorsa
// - Heterogen koleksiyonlar kullanıyorsanız

void processMixed(const vector<unique_ptr<Base>>& objects) {
    for (const auto& obj : objects) {
        obj->process();  // Virtual function call
    }
}
```

### 2. Compile-Time vs Runtime Hata Yakalama

```cpp
#include <type_traits>

// Compile-time constraint
template<typename T>
void processNumeric(T value) {
    static_assert(is_arithmetic_v<T>, "T must be numeric type");
    // Implementation
}

// SFINAE ile type checking
template<typename T>
enable_if_t<is_integral_v<T>, void>
processInteger(T value) {
    // Sadece integer türleri için
}

template<typename T>
enable_if_t<is_floating_point_v<T>, void>
processFloat(T value) {
    // Sadece floating point türleri için
}
```

Statik polimorfizm, C++'ın en güçlü özelliklerinden biridir. Doğru kullanıldığında, hem performans hem de type safety açısından büyük avantajlar sağlar. Özellikle library design ve generic programming alanlarında vazgeçilmez bir araçtır.
