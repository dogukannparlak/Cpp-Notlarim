# Fonksiyon Overloading (Aşırı Yükleme)

Fonksiyon overloading (aşırı yükleme), C++'da aynı isme sahip ancak farklı parametrelere sahip birden fazla fonksiyon tanımlamaya olanak sağlar. Bu özellik, benzer işlevleri yerine getiren ancak farklı veri türleri veya parametre sayıları ile çalışan fonksiyonlar için kod okunabilirliğini ve kullanım kolaylığını artırır.

## Temel Kavramlar

Fonksiyon overloading, **derleyici zamanında (compile-time)** gerçekleşen bir polimorfizm türüdür. Derleyici, fonksiyon çağrısı sırasında parametrelere bakarak hangi fonksiyonun çağrılacağına karar verir.

### Overloading Nedir?

Fonksiyon overloading, **aynı isimde ancak farklı parametre imzalarına sahip** birden fazla fonksiyon tanımlama yeteneğidir. Bu özellik sayesinde:

- **Tek bir fonksiyon ismi** ile farklı veri türlerini işleyebiliriz
- **Parametre sayısı** veya **türlerine göre** uygun fonksiyon otomatik seçilir
- **Kod tekrarı azalır** ve API kullanımı kolaylaşır
- **Compile-time** (derleme zamanında) fonksiyon seçimi yapılır

#### Basit Örnek
```cpp
void yazdir(int sayi);          // int için
void yazdir(double sayi);       // double için
void yazdir(string metin);      // string için

// Kullanım:
yazdir(42);        // int versiyonu çağrılır
yazdir(3.14);      // double versiyonu çağrılır
yazdir("Merhaba"); // string versiyonu çağrılır
```

Derleyici, fonksiyon çağrısında verilen argumentlerin türüne bakarak hangi versiyonun çalıştırılacağına **otomatik olarak** karar verir.

### Overloading Kuralları

Fonksiyonlar aşağıdaki durumlarda overload edilebilir:

1. **Parametre sayısı farklı** olmalı
2. **Parametre türleri farklı** olmalı  
3. **Parametre sırası farklı** olmalı

**ÖNEMLİ:** Sadece **dönüş türü** farklı olan fonksiyonlar overload edilemez!

## Temel Örnekler

### 1. Parametre Sayısına Göre Overloading

```cpp
#include <iostream>
using namespace std;

// Farklı parametre sayıları ile overloading
// Bu örnekte aynı isimde (topla) 3 farklı fonksiyon tanımlanmış
// Derleyici, fonksiyon çağrısında verilen parametre sayısına bakarak
// hangi fonksiyonun çağrılacağına karar verir

// İlk overload: 2 parametre alan versiyon
int topla(int a, int b) {
    cout << "İki sayı toplamı: ";
    return a + b;  // İki sayının toplamını döndürür
}

// İkinci overload: 3 parametre alan versiyon
int topla(int a, int b, int c) {
    cout << "Üç sayı toplamı: ";
    return a + b + c;  // Üç sayının toplamını döndürür
}

// Üçüncü overload: 4 parametre alan versiyon
int topla(int a, int b, int c, int d) {
    cout << "Dört sayı toplamı: ";
    return a + b + c + d;  // Dört sayının toplamını döndürür
}

int main() {
    // Derleyici parametre sayısına göre uygun fonksiyonu seçer
    cout << topla(5, 3) << endl;           // 2 parametre -> ilk fonksiyon çağrılır
    cout << topla(5, 3, 2) << endl;        // 3 parametre -> ikinci fonksiyon çağrılır
    cout << topla(5, 3, 2, 1) << endl;     // 4 parametre -> üçüncü fonksiyon çağrılır
    
    // Çıktı:
    // İki sayı toplamı: 8
    // Üç sayı toplamı: 10
    // Dört sayı toplamı: 11
    
    return 0;
}
```

### 2. Parametre Türüne Göre Overloading

```cpp
#include <iostream>
#include <string>
using namespace std;

// Farklı veri türleri ile overloading
// Bu örnekte yazdir fonksiyonu farklı veri türleri için overload edilmiş
// Her bir fonksiyon, farklı bir veri türü için özelleştirilmiş işlem yapar

// int türü için overload
void yazdir(int sayi) {
    cout << "Tam sayı: " << sayi << endl;
    // int türündeki değerleri "Tam sayı:" prefixi ile yazdırır
}

// double türü için overload
void yazdir(double sayi) {
    cout << "Ondalık sayı: " << sayi << endl;
    // double türündeki değerleri "Ondalık sayı:" prefixi ile yazdırır
}

// char türü için overload
void yazdir(char karakter) {
    cout << "Karakter: " << karakter << endl;
    // char türündeki değerleri "Karakter:" prefixi ile yazdırır
}

// string türü için overload
void yazdir(string metin) {
    cout << "Metin: " << metin << endl;
    // string türündeki değerleri "Metin:" prefixi ile yazdırır
}

int main() {
    // Derleyici, argümanın türüne bakarak hangi fonksiyonun çağrılacağına karar verir
    yazdir(42);           // int literal -> int versiyonu çağrılır
    yazdir(3.14);         // double literal -> double versiyonu çağrılır
    yazdir('A');          // char literal -> char versiyonu çağrılır
    yazdir("Merhaba");    // string literal -> string versiyonu çağrılır
    
    // Çıktı:
    // Tam sayı: 42
    // Ondalık sayı: 3.14
    // Karakter: A
    // Metin: Merhaba
    
    return 0;
}
```

### 3. Parametre Sırasına Göre Overloading

```cpp
#include <iostream>
#include <string>
using namespace std;

// Parametre sırasına göre overloading
// Aynı türde parametreler olsa bile, sıraları farklıysa overloading mümkündür
// Bu durum genellikle fonksiyonun mantığı farklı olduğunda kullanılır

// İlk versiyon: string ilk, int ikinci parametre
void bilgiYazdir(string isim, int yas) {
    cout << "İsim: " << isim << ", Yaş: " << yas << endl;
    // İsmi önce, yaşı sonra yazdıran format
}

// İkinci versiyon: int ilk, string ikinci parametre
void bilgiYazdir(int yas, string isim) {
    cout << "Yaş: " << yas << ", İsim: " << isim << endl;
    // Yaşı önce, ismi sonra yazdıran format
}

int main() {
    // Derleyici parametre sırasına bakarak hangi fonksiyonun çağrılacağına karar verir
    bilgiYazdir("Ali", 25);    // string, int sırası -> ilk fonksiyon çağrılır
    bilgiYazdir(30, "Ayşe");   // int, string sırası -> ikinci fonksiyon çağrılır
    
    // Çıktı:
    // İsim: Ali, Yaş: 25
    // Yaş: 30, İsim: Ayşe
    
    // NOT: Parametre türleri aynı olsa bile sıraları farklı olduğu için
    // derleyici bunları farklı fonksiyonlar olarak görür ve overloading mümkün olur
    
    return 0;
}
```

## Gelişmiş Örnekler

### Matematiksel İşlemler

```cpp
#include <iostream>
#include <vector>
using namespace std;

class MathUtils {
public:
    // KARE FONKSİYONLARI - Farklı parametre türleri ve sayıları ile overload
    
    // Tek sayının karesi - En basit versiyon
    static double kare(double x) {
        return x * x;  // x'in karesini hesaplar ve döndürür
    }
    
    // İki sayının toplamının karesi - Bileşik işlem
    static double kare(double x, double y) {
        double toplam = x + y;     // Önce iki sayıyı toplar
        return toplam * toplam;    // Sonra toplamın karesini alır
    }
    
    // Dizideki tüm elemanların kareleri toplamı - Koleksiyon işlemi
    static double kare(const vector<double>& sayilar) {
        double toplam = 0;
        // Her elemanın karesini alıp toplama ekler
        for (double sayi : sayilar) {
            toplam += sayi * sayi;  // sayi² değerini toplama ekle
        }
        return toplam;  // Tüm karelerin toplamını döndür
    }
    
    // MAXIMUM BULMA FONKSİYONLARI - Farklı veri yapıları için overload
    
    // İki sayı arasından maksimum - Temel versiyon
    static int max(int a, int b) {
        return (a > b) ? a : b;  // Ternary operator ile karşılaştırma
    }
    
    // Üç sayı arasından maksimum - Recursive approach
    static int max(int a, int b, int c) {
        // İlk iki sayının maksimumunu bulup, üçüncü sayı ile karşılaştır
        return max(max(a, b), c);  // Özyinelemeli olarak iki parametreli max'ı kullanır
    }
    
    // Dizi içinden maksimum - Koleksiyon işlemi
    static int max(const vector<int>& sayilar) {
        if (sayilar.empty()) return 0;  // Boş dizi kontrolü
        
        int maksimum = sayilar[0];  // İlk elemanı maksimum olarak başlat
        // Dizideki her eleman ile karşılaştır
        for (int sayi : sayilar) {
            if (sayi > maksimum) {
                maksimum = sayi;  // Daha büyük değer bulunursa güncelle
            }
        }
        return maksimum;  // En büyük değeri döndür
    }
};

int main() {
    // KARE FONKSİYONLARINI TEST ETME
    cout << "=== KARE FONKSİYONLARI ===" << endl;
    
    // Tek sayının karesi: 5² = 25
    cout << "5'in karesi: " << MathUtils::kare(5.0) << endl;
    
    // İki sayının toplamının karesi: (3+4)² = 7² = 49
    cout << "3+4'ün toplamının karesi: " << MathUtils::kare(3.0, 4.0) << endl;
    
    // Sayıların kareleri toplamı: 1² + 2² + 3² + 4² = 1 + 4 + 9 + 16 = 30
    vector<double> sayilar = {1.0, 2.0, 3.0, 4.0};
    cout << "Sayıların kareleri toplamı: " << MathUtils::kare(sayilar) << endl;
    
    cout << "\n=== MAXIMUM FONKSİYONLARI ===" << endl;
    
    // İki sayı karşılaştırması: max(10, 20) = 20
    cout << "Max(10, 20): " << MathUtils::max(10, 20) << endl;
    
    // Üç sayı karşılaştırması: max(10, 20, 15) = 20
    cout << "Max(10, 20, 15): " << MathUtils::max(10, 20, 15) << endl;
    
    // Dizi içinden maksimum: max{5, 12, 3, 18, 7} = 18
    vector<int> liste = {5, 12, 3, 18, 7};
    cout << "Listedeki maksimum: " << MathUtils::max(liste) << endl;
    
    // Beklenen çıktı:
    // === KARE FONKSİYONLARI ===
    // 5'in karesi: 25
    // 3+4'ün toplamının karesi: 49
    // Sayıların kareleri toplamı: 30
    // 
    // === MAXIMUM FONKSİYONLARI ===
    // Max(10, 20): 20
    // Max(10, 20, 15): 20
    // Listedeki maksimum: 18
    
    return 0;
}
```

### String İşlemleri

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class StringUtils {
public:
    // BİRLEŞTİRME FONKSİYONLARI - Farklı parametre kombinasyonları
    
    // İki string'i basit birleştirme - En temel versiyon
    static string birlestir(const string& str1, const string& str2) {
        return str1 + str2;  // + operatörü ile string concatenation
    }
    
    // Üç string'i birleştirme - Genişletilmiş versiyon
    static string birlestir(const string& str1, const string& str2, const string& str3) {
        return str1 + str2 + str3;  // Sırayla üç string'i birleştirir
    }
    
    // Ayırıcı ile iki string birleştirme - Özelleştirilmiş format
    static string birlestir(const string& str1, const string& str2, char ayirici) {
        return str1 + ayirici + str2;  // İki string arasına char ayırıcı ekler
        // Örnek: birlestir("Ali", "Veli", '-') -> "Ali-Veli"
    }
    
    // String dizisini birleştirme - Koleksiyon işlemi
    static string birlestir(const vector<string>& stringler, const string& ayirici = " ") {
        if (stringler.empty()) return "";  // Boş dizi kontrolü
        
        string sonuc = stringler[0];  // İlk elemanla başla
        // Kalan elemanları ayırıcı ile birleştir
        for (size_t i = 1; i < stringler.size(); i++) {
            sonuc += ayirici + stringler[i];  // ayırıcı + sonraki eleman
        }
        return sonuc;
        // Örnek: {"Bu", "bir", "test"} + " " -> "Bu bir test"
    }
    
    // TEKRARLAMA FONKSİYONLARI - Farklı format seçenekleri
    
    // String'i belirtilen sayıda tekrarlama - Basit versiyon
    static string tekrarla(const string& str, int kez) {
        string sonuc;
        for (int i = 0; i < kez; i++) {
            sonuc += str;  // Her döngüde string'i ekle
        }
        return sonuc;
        // Örnek: tekrarla("Ha", 3) -> "HaHaHa"
    }
    
    // Ayırıcı ile string tekrarlama - Formatlı versiyon
    static string tekrarla(const string& str, int kez, const string& ayirici) {
        if (kez <= 0) return "";  // Geçersiz tekrar sayısı kontrolü
        
        string sonuc = str;  // İlk tekrarla başla
        // Kalan tekrarları ayırıcı ile ekle
        for (int i = 1; i < kez; i++) {
            sonuc += ayirici + str;  // ayırıcı + string
        }
        return sonuc;
        // Örnek: tekrarla("C++", 3, " | ") -> "C++ | C++ | C++"
    }
};

int main() {
    cout << "=== BİRLEŞTİRME ÖRNEKLERİ ===" << endl;
    
    // İki string birleştirme: "Merhaba" + "Dünya" = "MerhabaDünya"
    cout << StringUtils::birlestir("Merhaba", "Dünya") << endl;
    
    // Üç string birleştirme: "C" + "++" + "Programming" = "C++Programming"
    cout << StringUtils::birlestir("C", "++", "Programming") << endl;
    
    // Ayırıcı ile birleştirme: "Ali" + '-' + "Veli" = "Ali-Veli"
    cout << StringUtils::birlestir("Ali", "Veli", '-') << endl;
    
    // String dizisi birleştirme (varsayılan ayırıcı: boşluk)
    vector<string> kelimeler = {"Bu", "bir", "test", "metnidir"};
    cout << StringUtils::birlestir(kelimeler) << endl;  // "Bu bir test metnidir"
    
    // String dizisi birleştirme (özel ayırıcı: tire)
    cout << StringUtils::birlestir(kelimeler, "-") << endl;  // "Bu-bir-test-metnidir"
    
    cout << "\n=== TEKRARLAMA ÖRNEKLERİ ===" << endl;
    
    // Basit tekrarlama: "Ha" x 3 = "HaHaHa"
    cout << StringUtils::tekrarla("Ha", 3) << endl;
    
    // Ayırıcı ile tekrarlama: "C++" | "C++" | "C++"
    cout << StringUtils::tekrarla("C++", 3, " | ") << endl;
    
    // Beklenen çıktı:
    // === BİRLEŞTİRME ÖRNEKLERİ ===
    // MerhabaDünya
    // C++Programming
    // Ali-Veli
    // Bu bir test metnidir
    // Bu-bir-test-metnidir
    // 
    // === TEKRARLAMA ÖRNEKLERİ ===
    // HaHaHa
    // C++ | C++ | C++
    
    return 0;
}
```

## Overloading ile Dikkat Edilmesi Gerekenler

### 1. Belirsizlik (Ambiguity) Durumları

```cpp
#include <iostream>
using namespace std;

// PROBLEM: Belirsizlik yaratabilecek overload'lar
// Bu durumda int ve double parametreli fonksiyonlar var
// Bazı veri türleri için derleyici hangisini seçeceğini bilemez

void fonksiyon(int x) {
    cout << "int versiyonu: " << x << endl;
}

void fonksiyon(double x) {
    cout << "double versiyonu: " << x << endl;
}

int main() {
    // NET DURUMLAR - Belirsizlik yok
    fonksiyon(5);      // OK - 5 tam sayı literal'i -> int versiyonu çağrılır
    fonksiyon(5.0);    // OK - 5.0 double literal'i -> double versiyonu çağrılır
    
    // PROBLEMLİ DURUM - Belirsizlik var!
    // fonksiyon(5.5f);   // DERLEME HATASI! 
    // float türü hem int'e hem double'a dönüştürülebilir
    // Derleyici hangisini seçeceğini bilemez ve hata verir
    // Error: ambiguous call to overloaded function
    
    cout << "=== ÇÖZÜM YÖNTEMLERİ ===" << endl;
    
    // ÇÖZÜM 1: Açık tip dönüşümü (static_cast)
    fonksiyon(static_cast<int>(5.5f));     // float'ı int'e zorla dönüştür
    fonksiyon(static_cast<double>(5.5f));  // float'ı double'a zorla dönüştür
    
    // ÇÖZÜM 2: Explicit literal suffix kullanma
    fonksiyon(5);        // int için suffix yok
    fonksiyon(5.0);      // double için .0 suffix
    
    // ÇÖZÜM 3: C-style cast (önerilmez, ama mümkün)
    fonksiyon((int)5.5f);     // C-style cast ile int'e dönüştür
    fonksiyon((double)5.5f);  // C-style cast ile double'a dönüştür
    
    // UYARI: float literal için 'f' suffix'i belirsizlik yaratır
    // float hem int'e hem double'a implicit dönüştürülebilir
    // Bu yüzden derleyici hangi fonksiyonu çağıracağını bilemez
    
    // Çıktı:
    // int versiyonu: 5
    // double versiyonu: 5
    // === ÇÖZÜM YÖNTEMLERİ ===
    // int versiyonu: 5      (5.5f -> 5'e dönüştürüldü)
    // double versiyonu: 5.5 (5.5f -> 5.5'e dönüştürüldü)
    // int versiyonu: 5
    // double versiyonu: 5
    // int versiyonu: 5
    // double versiyonu: 5.5
    
    return 0;
}
```

### 2. Default Parametreler ile Overloading

```cpp
#include <iostream>
using namespace std;

// DİKKATLİ OLUNMASI GEREKEN DURUM: Default parametreler ve overloading
// Bu kombinasyon belirsizlik yaratabilir!

// İlk fonksiyon: Tek parametre alan versiyon
void hesapla(int a) {
    cout << "Tek parametre: " << a << endl;
}

// İkinci fonksiyon: İki parametre alan, ancak ikincisi default değere sahip
void hesapla(int a, int b = 10) {  // b parametresi için default değer: 10
    cout << "İki parametre: " << a << ", " << b << endl;
}

int main() {
    // PROBLEMLİ ÇAĞRI - Belirsizlik!
    // hesapla(5);  // DERLEME HATASI!
    // 
    // NEDEN HATA VERİR?
    // 1. İlk fonksiyon: hesapla(int) -> hesapla(5) şeklinde çağrılabilir
    // 2. İkinci fonksiyon: hesapla(int, int = 10) -> hesapla(5) şeklinde de çağrılabilir
    //    (çünkü ikinci parametre default değere sahip)
    // 
    // Derleyici hangi fonksiyonun çağrılacağına karar veremez!
    // Error: ambiguous call to overloaded function 'hesapla'
    
    cout << "=== GÜVENLİ ÇAĞRILAR ===" << endl;
    
    // GÜVENLİ ÇAĞRI 1: Açık şekilde iki parametre verme
    hesapla(5, 3);   // OK - Açık şekilde iki parametre -> ikinci fonksiyon çağrılır
    
    // GÜVENLİ ÇAĞRI 2: Default değeri kullanma ama açık şekilde belirtme
    hesapla(5, 10);  // OK - Default değeri manuel olarak yazma -> ikinci fonksiyon
    
    // ÇÖZÜM ÖNERİLERİ:
    // 1. Overload edilmiş fonksiyonlarda default parametre kullanmaktan kaçının
    // 2. Eğer kullanacaksanız, parametre sayıları farklı olacak şekilde tasarlayın
    // 3. Fonksiyon isimlerini farklılaştırın (hesaplaTek, hesaplaIki gibi)
    
    cout << "\n=== DAHA İYİ TASARIM ÖRNEĞİ ===" << endl;
    
    // Alternatif çözüm: Farklı isimler kullanmak
    // void hesaplaTek(int a);
    // void hesaplaIki(int a, int b = 10);
    
    // Çıktı:
    // === GÜVENLİ ÇAĞRILAR ===
    // İki parametre: 5, 3
    // İki parametre: 5, 10
    // 
    // === DAHA İYİ TASARIM ÖRNEĞİ ===
    
    return 0;
}

/*
 * ÖNEMLİ NOTLAR:
 * 
 * 1. Default parametreler ile overloading yaparken çok dikkatli olun
 * 2. Belirsizlik durumları compile-time'da yakalanır, runtime'da değil
 * 3. Bu tür hatalar genellikle API tasarımı aşamasında düşünülmelidir
 * 4. Overloading yaparken fonksiyon çağrılarının belirsiz olmadığından emin olun
 */
```

### 3. Const ve Non-const Overloading

```cpp
#include <iostream>
using namespace std;

class MyClass {
private:
    int deger;
    
public:
    // Constructor: Sınıfı başlatır
    MyClass(int d) : deger(d) {}
    
    // NON-CONST VERSİYONU - Değiştirilebilir nesneler için
    // Bu fonksiyon non-const nesnelerde çağrılır ve değeri değiştirmeye izin verir
    int& getValue() {
        cout << "Non-const versiyonu çağrıldı" << endl;
        return deger;  // Referans döndürür, değer değiştirilebilir
        // int& döndürmek, dönen değerin değiştirilebileceği anlamına gelir
        // Örnek: obj.getValue() = 100; // Bu geçerli bir işlemdir
    }
    
    // CONST VERSİYONU - Sabit nesneler için
    // Bu fonksiyon const nesnelerde çağrılır ve değeri sadece okumaya izin verir
    const int& getValue() const {
        cout << "Const versiyonu çağrıldı" << endl;
        return deger;  // Const referans döndürür, değer değiştirilemez
        // const int& döndürmek, dönen değerin değiştirilemeyeceği anlamına gelir
    }
    
    /*
     * OVERLOADING KURALI:
     * - Aynı isme sahip fonksiyonlar
     * - Aynı parametre listesi
     * - Farklı const durumu (birisi const, diğeri değil)
     * 
     * Derleyici, nesnenin const olup olmadığına bakarak
     * hangi versiyonun çağrılacağına karar verir.
     */
};

int main() {
    cout << "=== NESNE ÖRNEKLERİ ===" << endl;
    
    // NON-CONST NESNE: Değiştirilebilir nesne
    MyClass obj(42);
    cout << "Non-const nesne oluşturuldu (değer: 42)" << endl;
    
    // CONST NESNE: Değiştirilemez nesne
    const MyClass constObj(100);
    cout << "Const nesne oluşturuldu (değer: 100)" << endl;
    
    cout << "\n=== FONKSİYON ÇAĞRILARI ===" << endl;
    
    // Non-const nesne üzerinde çağrı
    cout << "obj.getValue() çağrısı: ";
    int deger1 = obj.getValue();       // Non-const versiyonu çağrılır
    cout << "Alınan değer: " << deger1 << endl;
    
    // Const nesne üzerinde çağrı  
    cout << "constObj.getValue() çağrısı: ";
    int deger2 = constObj.getValue();  // Const versiyonu çağrılır
    cout << "Alınan değer: " << deger2 << endl;
    
    cout << "\n=== DEĞİŞTİRME İŞLEMLERİ ===" << endl;
    
    // Non-const nesne: Değer değiştirilebilir
    cout << "obj.getValue() ile değer değiştirme: ";
    obj.getValue() = 999;  // Non-const versiyonu int& döndürür, değiştirme mümkün
    cout << "Yeni değer: " << obj.getValue() << endl;
    
    // Const nesne: Değer değiştirilemez
    // constObj.getValue() = 500;  // DERLEME HATASI!
    // const int& döndürdüğü için değiştirilemez
    cout << "constObj değeri değiştirilemez (const olduğu için)" << endl;
    
    /*
     * ÇALIŞMA PRENSİBİ:
     * 
     * 1. Derleyici, fonksiyon çağrısında nesnenin const olup olmadığını kontrol eder
     * 2. Non-const nesne için non-const versiyonu seçer
     * 3. Const nesne için const versiyonu seçer
     * 4. Bu sayede const-correctness (const doğruluğu) sağlanır
     * 
     * AVANTAJLARI:
     * - Const nesnelerde sadece okuma işlemleri yapılır
     * - Non-const nesnelerde hem okuma hem yazma işlemleri yapılabilir
     * - Kod güvenliği artar
     * - Compiler optimizasyonları mümkün olur
     */
    
    // Beklenen çıktı:
    // === NESNE ÖRNEKLERİ ===
    // Non-const nesne oluşturuldu (değer: 42)
    // Const nesne oluşturuldu (değer: 100)
    // 
    // === FONKSİYON ÇAĞRILARI ===
    // obj.getValue() çağrısı: Non-const versiyonu çağrıldı
    // Alınan değer: 42
    // constObj.getValue() çağrısı: Const versiyonu çağrıldı
    // Alınan değer: 100
    // 
    // === DEĞİŞTİRME İŞLEMLERİ ===
    // obj.getValue() ile değer değiştirme: Non-const versiyonu çağrıldı
    // Non-const versiyonu çağrıldı
    // Yeni değer: 999
    // constObj değeri değiştirilemez (const olduğu için)
    
    return 0;
}
```

## Pratik Kullanım Örnekleri

### Dosya İşlemleri

```cpp
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
using namespace std;

class FileManager {
public:
    // DOSYAYA YAZMA FONKSİYONLARI - Farklı veri türleri ve modlar için overload
    
    // TEK STRING YAZMA - En basit dosya yazma işlemi
    static bool dosyayaYaz(const string& dosyaAdi, const string& icerik) {
        ofstream dosya(dosyaAdi);  // Dosyayı yazma modunda aç
        if (!dosya.is_open()) {    // Dosya açılamadı mı kontrol et
            return false;          // Hata durumunda false döndür
        }
        
        dosya << icerik;  // İçeriği dosyaya yaz
        dosya.close();    // Dosyayı kapat (destructor otomatik kapatır ama açık yazmak iyi)
        return true;      // Başarılı işlem için true döndür
        
        // Kullanım: FileManager::dosyayaYaz("test.txt", "Merhaba Dünya!");
    }
    
    // STRING DİZİSİ YAZMA - Çoklu satır yazma işlemi
    static bool dosyayaYaz(const string& dosyaAdi, const vector<string>& satirlar) {
        ofstream dosya(dosyaAdi);  // Dosyayı yazma modunda aç
        if (!dosya.is_open()) {    // Dosya açılabildi mi kontrol et
            return false;
        }
        
        // Her string'i ayrı satır olarak yaz
        for (const string& satir : satirlar) {
            dosya << satir << "\n";  // Her satırdan sonra newline ekle
        }
        dosya.close();
        return true;
        
        // Kullanım: vector<string> satirlar = {"Satır 1", "Satır 2"};
        //          FileManager::dosyayaYaz("test.txt", satirlar);
    }
    
    // APPEND MODUNDA YAZMA - Mevcut dosyaya ekleme yapma
    static bool dosyayaYaz(const string& dosyaAdi, const string& icerik, bool append) {
        ofstream dosya;
        
        // Append parametresine göre dosya açma modu belirlenir
        if (append) {
            dosya.open(dosyaAdi, ios::app);  // ios::app = append mode (dosyanın sonuna ekle)
        } else {
            dosya.open(dosyaAdi);            // Normal mod (dosyayı sıfırla ve baştan yaz)
        }
        
        if (!dosya.is_open()) {
            return false;
        }
        
        dosya << icerik;  // İçeriği yaz (append ise sona ekler, normal modda üzerine yazar)
        dosya.close();
        return true;
        
        // Kullanım: FileManager::dosyayaYaz("test.txt", "Ek metin", true);  // Append
        //          FileManager::dosyayaYaz("test.txt", "Yeni metin", false); // Overwrite
    }
    
    /*
     * OVERLOADING MANTIGI:
     * 1. dosyayaYaz(string, string) -> Basit string yazma
     * 2. dosyayaYaz(string, vector<string>) -> Çoklu satır yazma
     * 3. dosyayaYaz(string, string, bool) -> Append/overwrite seçenekli yazma
     * 
     * Her fonksiyon farklı parametre kombinasyonuna sahip olduğu için
     * derleyici doğru fonksiyonu seçebilir.
     */
};

int main() {
    cout << "=== DOSYA İŞLEMLERİ ÖRNEKLERİ ===" << endl;
    
    // ÖRNEK 1: Tek string yazma
    cout << "1. Tek string dosyaya yazılıyor..." << endl;
    bool sonuc1 = FileManager::dosyayaYaz("test1.txt", "Merhaba Dünya!");
    if (sonuc1) {
        cout << "   ✓ test1.txt başarıyla oluşturuldu" << endl;
    } else {
        cout << "   ✗ test1.txt oluşturulamadı" << endl;
    }
    
    // ÖRNEK 2: String dizisi yazma
    cout << "\n2. String dizisi dosyaya yazılıyor..." << endl;
    vector<string> satirlar = {"Satır 1: C++ Overloading", "Satır 2: Dosya İşlemleri", "Satır 3: Son satır"};
    bool sonuc2 = FileManager::dosyayaYaz("test2.txt", satirlar);
    if (sonuc2) {
        cout << "   ✓ test2.txt " << satirlar.size() << " satır ile oluşturuldu" << endl;
    }
    
    // ÖRNEK 3: Append mode yazma
    cout << "\n3. Mevcut dosyaya ekleme yapılıyor..." << endl;
    bool sonuc3 = FileManager::dosyayaYaz("test1.txt", "\nEklenen satır (append mode)", true);
    if (sonuc3) {
        cout << "   ✓ test1.txt dosyasına ek metin eklendi" << endl;
    }
    
    // ÖRNEK 4: Overwrite mode yazma
    cout << "\n4. Dosya üzerine yazılıyor..." << endl;
    bool sonuc4 = FileManager::dosyayaYaz("test1.txt", "Yeni içerik (overwrite mode)", false);
    if (sonuc4) {
        cout << "   ✓ test1.txt dosyası yeni içerikle değiştirildi" << endl;
    }
    
    cout << "\n=== İŞLEM SONUÇLARI ===" << endl;
    cout << "Oluşturulan dosyalar:" << endl;
    cout << "- test1.txt: Yeni içerik (overwrite mode)" << endl;
    cout << "- test2.txt: 3 satırlık string dizisi" << endl;
    
    /*
     * DOSYA DURUMU:
     * test1.txt içeriği: "Yeni içerik (overwrite mode)"
     * test2.txt içeriği: "Satır 1: C++ Overloading\nSatır 2: Dosya İşlemleri\nSatır 3: Son satır\n"
     * 
     * OVERLOADING AVANTAJLARI:
     * - Tek bir fonksiyon ismi ile farklı veri türlerini işleyebilme
     * - API kullanımının basitleşmesi
     * - Kod okunabilirliğinin artması
     * - Parametre türüne göre otomatik fonksiyon seçimi
     */
    
    return 0;
}
```

### Veri Dönüştürme

```cpp
#include <iostream>
#include <string>
#include <sstream>
#include <vector>
using namespace std;

class Converter {
public:
    // BASİT TİP DÖNÜŞTÜRMELERİ - Temel veri türlerini string'e çevirme
    
    // INTEGER'ı STRING'e çevirme
    static string toString(int sayi) {
        return to_string(sayi);  // C++11'de gelen hazır fonksiyon
        // Örnek: toString(42) -> "42"
    }
    
    // DOUBLE'ı STRING'e çevirme  
    static string toString(double sayi) {
        return to_string(sayi);  // Ondalık sayıları string'e dönüştürür
        // Örnek: toString(3.14159) -> "3.141590" (varsayılan precision ile)
    }
    
    // BOOLEAN'ı STRING'e çevirme
    static string toString(bool deger) {
        return deger ? "true" : "false";  // Ternary operator ile true/false döndürür
        // Örnek: toString(true) -> "true", toString(false) -> "false"
    }
    
    // FORMATLI DÖNÜŞTÜRMELERİ - Özel biçimlendirme seçenekleri
    
    // INTEGER'ı belirli genişlikte STRING'e çevirme (padding ile)
    static string toString(int sayi, int genislik) {
        ostringstream oss;      // Output string stream oluştur
        oss.width(genislik);    // Çıktı genişliğini ayarla
        oss.fill('0');          // Boş alanları '0' ile doldur
        oss << sayi;            // Sayıyı stream'e yaz
        return oss.str();       // String olarak döndür
        // Örnek: toString(42, 5) -> "00042" (5 karakter genişliğinde, 0 ile doldurulmuş)
    }
    
    // DOUBLE'ı belirli ondalık basamak sayısıyla STRING'e çevirme
    static string toString(double sayi, int ondalikBasamak) {
        ostringstream oss;                    // Output string stream oluştur
        oss.precision(ondalikBasamak);        // Ondalık basamak sayısını ayarla
        oss << fixed << sayi;                 // fixed format ile sayıyı yaz
        return oss.str();
        // Örnek: toString(3.14159, 2) -> "3.14" (2 ondalık basamakla)
        // fixed flag'i kullanarak tam olarak belirtilen basamak sayısını garanti eder
    }
    
    // DİZİ DÖNÜŞTÜRMESİ - Template kullanarak generic dizi işlemi
    template<typename T>
    static string toString(const vector<T>& dizi, const string& ayirici = ", ") {
        if (dizi.empty()) return "[]";  // Boş dizi için özel durum
        
        ostringstream oss;
        oss << "[";                     // Dizi başlangıç karakteri
        oss << toString(dizi[0]);       // İlk elemanı ekle (recursive toString çağrısı)
        
        // Kalan elemanları ayırıcı ile ekle
        for (size_t i = 1; i < dizi.size(); i++) {
            oss << ayirici << toString(dizi[i]);  // ayırıcı + eleman
        }
        oss << "]";                     // Dizi bitiş karakteri
        return oss.str();
        
        // Örnek: vector<int>{1,2,3} -> "[1, 2, 3]"
        // Örnek: vector<double>{1.1,2.2} + " | " -> "[1.1 | 2.2]"
        
        /*
         * TEMPLATE AÇIKLAMASI:
         * template<typename T> sayesinde bu fonksiyon herhangi bir türdeki
         * vector ile çalışabilir (int, double, string, vs.)
         * Derleyici, çağrı sırasında T'nin türünü otomatik olarak belirler
         */
    }
    
    /*
     * OVERLOADING STRATEJİSİ:
     * 1. toString(int) -> Basit int dönüşümü
     * 2. toString(double) -> Basit double dönüşümü  
     * 3. toString(bool) -> Boolean dönüşümü
     * 4. toString(int, int) -> Formatlı int dönüşümü (genişlik ile)
     * 5. toString(double, int) -> Formatlı double dönüşümü (precision ile)
     * 6. toString(vector<T>, string) -> Template ile dizi dönüşümü
     * 
     * Her overload farklı parametre kombinasyonuna sahip olduğu için
     * derleyici doğru versiyonu seçebilir.
     */
};

int main() {
    cout << "=== BASİT DÖNÜŞTÜRMELERİ ===" << endl;
    
    // Temel veri türlerini string'e çevirme
    cout << "Integer: " << Converter::toString(42) << endl;              // "42"
    cout << "Double: " << Converter::toString(3.14159) << endl;          // "3.141590"
    cout << "Boolean (true): " << Converter::toString(true) << endl;     // "true"
    cout << "Boolean (false): " << Converter::toString(false) << endl;   // "false"
    
    cout << "\n=== FORMATLI DÖNÜŞTÜRMELERİ ===" << endl;
    
    // Özel formatlama seçenekleri
    cout << "Padding örneği: " << Converter::toString(42, 5) << endl;        // "00042"
    cout << "Precision örneği: " << Converter::toString(3.14159, 2) << endl; // "3.14"
    cout << "Precision örneği: " << Converter::toString(3.14159, 4) << endl; // "3.1416"
    
    cout << "\n=== DİZİ DÖNÜŞTÜRMELERİ ===" << endl;
    
    // Farklı türlerde diziler
    vector<int> sayilar = {1, 2, 3, 4, 5};
    cout << "Int dizisi (varsayılan ayırıcı): " << Converter::toString(sayilar) << endl;
    cout << "Int dizisi (özel ayırıcı): " << Converter::toString(sayilar, " | ") << endl;
    
    vector<double> ondaliklar = {1.1, 2.2, 3.3};
    cout << "Double dizisi: " << Converter::toString(ondaliklar) << endl;
    cout << "Double dizisi (tire ayırıcı): " << Converter::toString(ondaliklar, " - ") << endl;
    
    // Boş dizi testi
    vector<int> bosDizi;
    cout << "Boş dizi: " << Converter::toString(bosDizi) << endl;          // "[]"
    
    cout << "\n=== OVERLOADING ÇALIŞMA ŞEKLİ ===" << endl;
    cout << "Derleyici, parametre türüne ve sayısına bakarak:" << endl;
    cout << "- toString(42) -> int versiyonunu seçer" << endl;
    cout << "- toString(3.14) -> double versiyonunu seçer" << endl;
    cout << "- toString(42, 5) -> formatlı int versiyonunu seçer" << endl;
    cout << "- toString(vector<int>) -> template versiyonunu seçer" << endl;
    
    /*
     * BEKLENEN ÇIKTI:
     * === BASİT DÖNÜŞTÜRMELERİ ===
     * Integer: 42
     * Double: 3.141590
     * Boolean (true): true
     * Boolean (false): false
     * 
     * === FORMATLI DÖNÜŞTÜRMELERİ ===
     * Padding örneği: 00042
     * Precision örneği: 3.14
     * Precision örneği: 3.1416
     * 
     * === DİZİ DÖNÜŞTÜRMELERİ ===
     * Int dizisi (varsayılan ayırıcı): [1, 2, 3, 4, 5]
     * Int dizisi (özel ayırıcı): [1 | 2 | 3 | 4 | 5]
     * Double dizisi: [1.100000, 2.200000, 3.300000]
     * Double dizisi (tire ayırıcı): [1.100000 - 2.200000 - 3.300000]
     * Boş dizi: []
     */
    
    return 0;
}
```

## En İyi Uygulamalar

### 1. Anlamlı Overloading

```cpp
// İYİ ÖRNEK: Benzer işlevler için overloading
// Aynı kavramsal işlemi (toplama) farklı parametre türleri ile gerçekleştiren fonksiyonlar
class Calculator {
public:
    // İki sayının toplamı - En basit versiyon
    double hesapla(double a, double b) { 
        return a + b;           // İki sayıyı toplar
    }
    
    // Üç sayının toplamı - Genişletilmiş versiyon  
    double hesapla(double a, double b, double c) { 
        return a + b + c;       // Üç sayıyı toplar
    }
    
    // Dizi elemanlarının toplamı - Koleksiyon versiyonu
    double hesapla(const vector<double>& sayilar) {               
        double toplam = 0;
        for (double sayi : sayilar) toplam += sayi;  // Tüm elemanları toplar
        return toplam;
    }
    
    /*
     * NEDEN İYİ?
     * - Tüm fonksiyonlar aynı kavramsal işlemi (toplama) yapar
     * - Sadece girdi formatı farklıdır (2 sayı, 3 sayı, dizi)
     * - Kullanıcı için tutarlı bir API sunar
     * - hesapla() ismi her durumda mantıklıdır
     */
};

// KÖTÜ ÖRNEK: Farklı işlevler için aynı isim
// Aynı isim altında tamamen farklı işlemler yapan fonksiyonlar
class BadExample {
public:
    // Bu fonksiyon toplama yapar
    void islem(int a, int b) { 
        cout << a + b; 
    }
    
    // Bu fonksiyon kare alma yapar - Tamamen farklı bir işlem!
    void islem(double a) { 
        cout << a * a; 
    }
    
    /*
     * NEDEN KÖTÜ?
     * - İlk fonksiyon toplama, ikincisi kare alma yapar
     * - Aynı isim altında farklı kavramsal işlemler
     * - Kullanıcı karışır: islem() ne yapar?
     * - API tutarsızlığı yaratır
     * - Kod okunabilirliğini azaltır
     * 
     * DAHA İYİ ÇÖZÜM:
     * void topla(int a, int b) { cout << a + b; }
     * void kareAl(double a) { cout << a * a; }
     */
};

/*
 * OVERLOADING İÇİN ALTIN KURALLAR:
 * 
 * 1. Aynı kavramsal işlem: Tüm overload'lar aynı amaca hizmet etmeli
 * 2. Tutarlı davranış: Benzer girdi/çıktı davranışı sergilemeli  
 * 3. Anlamlı isim: Fonksiyon ismi tüm overload'lar için anlamlı olmalı
 * 4. Benzer dönüş türü: Mümkünse benzer türde değer döndürmeli
 * 5. Belirgin farklılık: Parametre listelerinde açık farklılık olmalı
 */
```

### 2. Performans Optimizasyonu

```cpp
#include <iostream>
#include <string>
using namespace std;

class OptimizedString {
public:
    // KÜÇÜK STRİNGLER İÇİN - Değer ile geçiş (copy semantics)
    // Küçük objeler için kopyalama maliyeti düşüktür
    static string processSmall(string str) {  // Parametre değer ile geçilir (copy)
        return str + "_processed";
        /*
         * NEDEN DEĞER İLE GEÇİŞ?
         * - Küçük stringler için kopyalama maliyeti minimal
         * - Fonksiyon içinde değişiklik orijinali etkilemez
         * - Basit ve güvenli yaklaşım
         * - String'in kendisi zaten optimize edilmiş (SSO - Small String Optimization)
         */
    }
    
    // BÜYÜK STRİNGLER İÇİN - Referans ile geçiş (reference semantics)
    // Büyük objeler için kopyalama maliyetli olduğundan referans kullanılır
    static string processLarge(const string& str) {  // Parametre const referans ile geçilir
        return str + "_processed";
        /*
         * NEDEN CONST REFERANS?
         * - Büyük stringler için kopyalama maliyeti yüksek
         * - const sayesinde fonksiyon orijinal değeri değiştiremez
         * - Sadece okuma erişimi sağlar
         * - Bellek ve CPU tasarrufu
         * - Modern C++'da tercih edilen yöntem
         */
    }
    
    // C-STYLE STRING İÇİN - Ham pointer ile geçiş
    // Eski kod uyumluluğu ve C interoperability için
    static string process(const char* str) {
        return string(str) + "_processed";
        /*
         * NEDEN CONST CHAR*?
         * - C kodu ile uyumluluk
         * - String literal'leri doğrudan kabul eder
         * - Legacy kodlarla entegrasyon
         * - Null-terminated string'ler için
         * 
         * ÖNEMLİ: const char* -> string dönüşümü bir kopyalama işlemidir
         */
    }
    
    // MOVE SEMANTİKS İÇİN (C++11) - Kaynakların transfer edilmesi
    // Geçici objeler için optimize edilmiş versiyon
    static string process(string&& str) {  // Rvalue reference (move semantics)
        str += "_processed";
        return move(str);  // Kaynakları transfer et, kopyalama
        /*
         * MOVE SEMANTİKS AÇIKLAMASI:
         * - && rvalue reference anlamına gelir
         * - Geçici objeler (temporary) için kullanılır
         * - Kopyalama yerine kaynak transferi yapar
         * - Performans açısından en optimal yöntem
         * - C++11 ile gelen modern özellik
         * 
         * ÇALIŞMA ŞEKLİ:
         * 1. Gelen string geçici bir obje (rvalue)
         * 2. İçeriğini değiştir (kopyalamaya gerek yok)
         * 3. move() ile kaynakları transfer et
         * 4. Orijinal obje "boş" kalır, yeni obje kaynakları alır
         */
    }
    
    /*
     * OVERLOADING STRATEJİSİ:
     * 
     * 1. process(string) -> Küçük stringler için copy
     * 2. process(const string&) -> Büyük stringler için const reference
     * 3. process(const char*) -> C-style stringler için
     * 4. process(string&&) -> Geçici objeler için move semantics
     * 
     * DERLEYICI SEÇİMİ:
     * - Literal string: const char* versiyonu
     * - Mevcut string nesnesi: const string& versiyonu
     * - Geçici string (temp): string&& versiyonu
     * - Explicit copy: string versiyonu
     */
};

// KULLANIM ÖRNEKLERİ
int main() {
    cout << "=== PERFORMANS OPTİMİZASYONU ÖRNEKLERİ ===" << endl;
    
    // 1. C-style string literal
    cout << "C-style literal: " << OptimizedString::process("test") << endl;
    // Derleyici const char* versiyonunu seçer
    
    // 2. Mevcut string objesi
    string mevcut = "existing";
    cout << "Mevcut string: " << OptimizedString::processLarge(mevcut) << endl;
    // Derleyici const string& versiyonunu seçer
    
    // 3. Geçici string objesi (rvalue)
    cout << "Geçici obje: " << OptimizedString::process(string("temp")) << endl;
    // Derleyici string&& versiyonunu seçer (move semantics)
    
    // 4. Fonksiyon dönen geçici obje
    auto getString = []() -> string { return "function_result"; };
    cout << "Fonksiyon sonucu: " << OptimizedString::process(getString()) << endl;
    // Derleyici string&& versiyonunu seçer
    
    cout << "\n=== PERFORMANS KARŞILAŞTIRMASI ===" << endl;
    cout << "const char*     : Minimal maliyet (sadece string oluşturma)" << endl;
    cout << "const string&   : Kopyalama yok, sadece referans" << endl;
    cout << "string&&        : Kaynak transferi, kopyalama yok" << endl;
    cout << "string          : Tam kopyalama (küçük objeler için OK)" << endl;
    
    /*
     * PERFORMANS SIRALAMASI (Hızdan Yavaşa):
     * 1. const string& (referans, kopyalama yok)
     * 2. string&& (move, kaynak transferi)
     * 3. const char* (string oluşturma maliyeti)
     * 4. string (tam kopyalama maliyeti)
     * 
     * MODERN C++ TAVSİYESİ:
     * - Büyük objeler için: const T& kullan
     * - Geçici objeler için: T&& (move semantics) kullan
     * - Küçük objeler için: T kullanabilirsin
     * - C uyumluluğu için: const char* kullan
     */
    
    return 0;
}
```

### 3. Type Safety

```cpp
#include <iostream>
using namespace std;

class SafeCalculator {
public:
    // DOUBLE BÖLME İŞLEMİ - Ondalıklı sonuç için
    // Double türünde tam precision bölme işlemi
    static double divide(double a, double b) {
        if (b == 0.0) {  // Double için 0.0 karşılaştırması
            throw invalid_argument("Sıfıra bölme hatası!");
        }
        return a / b;  // Double bölme: tam precision sonuç
        /*
         * DOUBLE BÖLME ÖZELLİKLERİ:
         * - Sonuç her zaman ondalıklı (floating-point)
         * - Precision kaybı minimal
         * - IEEE 754 standardına uygun
         * - Bilimsel hesaplamalar için ideal
         */
    }
    
    // INTEGER BÖLME İŞLEMİ - Tam sayı sonucu için
    // Integer türünde truncated (kesik) sonuç
    static int divide(int a, int b) {
        if (b == 0) {    // Integer için 0 karşılaştırması
            throw invalid_argument("Sıfıra bölme hatası!");
        }
        return a / b;    // Integer bölme: kesik sonuç (truncation)
        /*
         * INTEGER BÖLME ÖZELLİKLERİ:
         * - Sonuç her zaman tam sayı
         * - Ondalık kısım atılır (truncation)
         * - Örnek: 10/3 = 3 (3.333... değil)
         * - Hızlı işlem
         * - Indeks hesaplamaları için ideal
         */
    }
    
    // KESSİN SONUÇ İÇİN - Integer'ları double olarak böl
    // Integer girdi alır ama double sonuç döndürür
    static double divideExact(int a, int b) {  
        if (b == 0) {
            throw invalid_argument("Sıfıra bölme hatası!");
        }
        return static_cast<double>(a) / b;  // Explicit cast ile exact division
        /*
         * EXACT DIVISION ÖZELLİKLERİ:
         * - Integer girdi alır
         * - Double sonuç döndürür
         * - Precision kaybı olmaz
         * - static_cast ile güvenli dönüşüm
         * - Karışık hesaplamalar için ideal
         * 
         * STATIC_CAST AÇIKLAMASI:
         * static_cast<double>(a) -> int'i double'a güvenli şekilde dönüştürür
         * Bu sayede bölme işlemi double precision ile yapılır
         */
    }
    
    /*
     * TYPE SAFETY AVANTAJLARI:
     * 
     * 1. TÜR GÜVENLİĞİ: Her tür için özel kontroller
     * 2. HATA YÖNETİMİ: Türe özel hata kontrolü
     * 3. PERFORMANS: Türe göre optimize edilmiş işlem
     * 4. AÇIKLIK: Hangi türle çalıştığı belli
     * 5. HATA ÖNLEME: Compile-time'da tür kontrolü
     * 
     * OVERLOADING MANTIGI:
     * - divide(double, double) -> Tam precision işlem
     * - divide(int, int) -> Hızlı integer işlem
     * - divideExact(int, int) -> Integer girdi, double çıktı
     */
};

int main() {
    cout << "=== TYPE SAFETY ÖRNEKLERİ ===" << endl;
    
    try {
        cout << "\n1. DOUBLE BÖLME İŞLEMLERİ:" << endl;
        
        // Double precision bölme
        double sonuc1 = SafeCalculator::divide(10.0, 3.0);
        cout << "10.0 / 3.0 = " << sonuc1 << " (tam precision)" << endl;
        
        double sonuc2 = SafeCalculator::divide(7.5, 2.5);
        cout << "7.5 / 2.5 = " << sonuc2 << " (exact result)" << endl;
        
        cout << "\n2. INTEGER BÖLME İŞLEMLERİ:" << endl;
        
        // Integer bölme (truncation)
        int sonuc3 = SafeCalculator::divide(10, 3);
        cout << "10 / 3 = " << sonuc3 << " (truncated result)" << endl;
        
        int sonuc4 = SafeCalculator::divide(15, 4);
        cout << "15 / 4 = " << sonuc4 << " (integer division)" << endl;
        
        cout << "\n3. EXACT BÖLME İŞLEMLERİ:" << endl;
        
        // Integer input, double output
        double sonuc5 = SafeCalculator::divideExact(10, 3);
        cout << "divideExact(10, 3) = " << sonuc5 << " (exact from integers)" << endl;
        
        double sonuc6 = SafeCalculator::divideExact(22, 7);
        cout << "divideExact(22, 7) = " << sonuc6 << " (pi approximation)" << endl;
        
        cout << "\n4. TÜR GÜVENLİĞİ KARŞILAŞTIRMASI:" << endl;
        cout << "Integer bölme: " << SafeCalculator::divide(10, 3) << " (hızlı ama truncated)" << endl;
        cout << "Double bölme:  " << SafeCalculator::divide(10.0, 3.0) << " (yavaş ama tam)" << endl;
        cout << "Exact bölme:   " << SafeCalculator::divideExact(10, 3) << " (hybrid yaklaşım)" << endl;
        
        cout << "\n5. HATA YÖNETİMİ TESTİ:" << endl;
        
        // Bu satır exception fırlatacak
        cout << "Sıfıra bölme testi..." << endl;
        SafeCalculator::divide(10, 0);  // Exception fırlatır
        
    } catch (const exception& e) {
        cout << "HATA YAKALANDI: " << e.what() << endl;
        cout << "Exception handling başarıyla çalıştı!" << endl;
    }
    
    cout << "\n=== TİP SEÇİMİ REHBERİ ===" << endl;
    cout << "• divide(double, double) -> Bilimsel hesaplamalar için" << endl;
    cout << "• divide(int, int) -> Hızlı indeks hesaplamaları için" << endl;
    cout << "• divideExact(int, int) -> Karışık tür hesaplamaları için" << endl;
    
    /*
     * BEKLENEN ÇIKTI:
     * === TYPE SAFETY ÖRNEKLERİ ===
     * 
     * 1. DOUBLE BÖLME İŞLEMLERİ:
     * 10.0 / 3.0 = 3.33333 (tam precision)
     * 7.5 / 2.5 = 3 (exact result)
     * 
     * 2. INTEGER BÖLME İŞLEMLERİ:
     * 10 / 3 = 3 (truncated result)
     * 15 / 4 = 3 (integer division)
     * 
     * 3. EXACT BÖLME İŞLEMLERİ:
     * divideExact(10, 3) = 3.33333 (exact from integers)
     * divideExact(22, 7) = 3.14286 (pi approximation)
     * 
     * 4. TÜR GÜVENLİĞİ KARŞILAŞTIRMASI:
     * Integer bölme: 3 (hızlı ama truncated)
     * Double bölme:  3.33333 (yavaş ama tam)
     * Exact bölme:   3.33333 (hybrid yaklaşım)
     * 
     * 5. HATA YÖNETİMİ TESTİ:
     * Sıfıra bölme testi...
     * HATA YAKALANDI: Sıfıra bölme hatası!
     * Exception handling başarıyla çalıştı!
     */
    
    return 0;
}
```

Fonksiyon overloading, C++'da kod okunabilirliğini artıran ve aynı kavramsal işlevi farklı parametrelerle gerçekleştiren fonksiyonlar için tutarlı bir arayüz sağlayan güçlü bir özelliktir. Doğru kullanıldığında, API tasarımını basitleştirir ve kullanıcı deneyimini geliştirir.
