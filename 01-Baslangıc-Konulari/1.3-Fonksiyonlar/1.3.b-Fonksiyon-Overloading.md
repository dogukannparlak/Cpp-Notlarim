# Fonksiyon Overloading (Aşırı Yükleme)

Fonksiyon overloading (aşırı yükleme), C++'da aynı isme sahip ancak farklı parametrelere sahip birden fazla fonksiyon tanımlamaya olanak sağlar. Bu özellik, benzer işlevleri yerine getiren ancak farklı veri türleri veya parametre sayıları ile çalışan fonksiyonlar için kod okunabilirliğini ve kullanım kolaylığını artırır.

## Temel Kavramlar

Fonksiyon overloading, **derleyici zamanında (compile-time)** gerçekleşen bir polimorfizm türüdür. Derleyici, fonksiyon çağrısı sırasında parametrelere bakarak hangi fonksiyonun çağrılacağına karar verir.

### Overloading Kuralları

Fonksiyonlar aşağıdaki durumlarda overload edilebilir:

1. **Parametre sayısı farklı** olmalı
2. **Parametre türleri farklı** olmalı  
3. **Parametre sırası farklı** olmalı

**ÖNEMLİ:** Sadece **dönüş türü** farklı olan fonksiyonlar overload edilemez!

## Temel Örnekler

### 1. Parametre Sayısına Göre Overloading

```cpp
#include <iostream>
using namespace std;

// Farklı parametre sayıları ile overloading
int topla(int a, int b) {
    cout << "İki sayı toplamı: ";
    return a + b;
}

int topla(int a, int b, int c) {
    cout << "Üç sayı toplamı: ";
    return a + b + c;
}

int topla(int a, int b, int c, int d) {
    cout << "Dört sayı toplamı: ";
    return a + b + c + d;
}

int main() {
    cout << topla(5, 3) << endl;           // İki parametre
    cout << topla(5, 3, 2) << endl;        // Üç parametre
    cout << topla(5, 3, 2, 1) << endl;     // Dört parametre
    
    return 0;
}
```

### 2. Parametre Türüne Göre Overloading

```cpp
#include <iostream>
#include <string>
using namespace std;

// Farklı veri türleri ile overloading
void yazdir(int sayi) {
    cout << "Tam sayı: " << sayi << endl;
}

void yazdir(double sayi) {
    cout << "Ondalık sayı: " << sayi << endl;
}

void yazdir(char karakter) {
    cout << "Karakter: " << karakter << endl;
}

void yazdir(string metin) {
    cout << "Metin: " << metin << endl;
}

int main() {
    yazdir(42);           // int versiyonu çağrılır
    yazdir(3.14);         // double versiyonu çağrılır
    yazdir('A');          // char versiyonu çağrılır
    yazdir("Merhaba");    // string versiyonu çağrılır
    
    return 0;
}
```

### 3. Parametre Sırasına Göre Overloading

```cpp
#include <iostream>
#include <string>
using namespace std;

// Parametre sırasına göre overloading
void bilgiYazdir(string isim, int yas) {
    cout << "İsim: " << isim << ", Yaş: " << yas << endl;
}

void bilgiYazdir(int yas, string isim) {
    cout << "Yaş: " << yas << ", İsim: " << isim << endl;
}

int main() {
    bilgiYazdir("Ali", 25);    // string, int sırası
    bilgiYazdir(30, "Ayşe");   // int, string sırası
    
    return 0;
}
```

## Gelişmiş Örnekler

### Matematiksel İşlemler

```cpp
#include <iostream>
#include <vector>
using namespace std;

class MathUtils {
public:
    // Tek sayının karesi
    static double kare(double x) {
        return x * x;
    }
    
    // İki sayının toplamının karesi
    static double kare(double x, double y) {
        double toplam = x + y;
        return toplam * toplam;
    }
    
    // Dizideki tüm elemanların kareleri toplamı
    static double kare(const vector<double>& sayilar) {
        double toplam = 0;
        for (double sayi : sayilar) {
            toplam += sayi * sayi;
        }
        return toplam;
    }
    
    // Maximum bulma - iki sayı
    static int max(int a, int b) {
        return (a > b) ? a : b;
    }
    
    // Maximum bulma - üç sayı
    static int max(int a, int b, int c) {
        return max(max(a, b), c);
    }
    
    // Maximum bulma - dizi
    static int max(const vector<int>& sayilar) {
        if (sayilar.empty()) return 0;
        
        int maksimum = sayilar[0];
        for (int sayi : sayilar) {
            if (sayi > maksimum) {
                maksimum = sayi;
            }
        }
        return maksimum;
    }
};

int main() {
    // Kare fonksiyonları
    cout << "5'in karesi: " << MathUtils::kare(5.0) << endl;
    cout << "3+4'ün toplamının karesi: " << MathUtils::kare(3.0, 4.0) << endl;
    
    vector<double> sayilar = {1.0, 2.0, 3.0, 4.0};
    cout << "Sayıların kareleri toplamı: " << MathUtils::kare(sayilar) << endl;
    
    // Maximum fonksiyonları
    cout << "Max(10, 20): " << MathUtils::max(10, 20) << endl;
    cout << "Max(10, 20, 15): " << MathUtils::max(10, 20, 15) << endl;
    
    vector<int> liste = {5, 12, 3, 18, 7};
    cout << "Listedeki maksimum: " << MathUtils::max(liste) << endl;
    
    return 0;
}
```

### String İşlemleri

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class StringUtils {
public:
    // İki string birleştirme
    static string birlestir(const string& str1, const string& str2) {
        return str1 + str2;
    }
    
    // Üç string birleştirme
    static string birlestir(const string& str1, const string& str2, const string& str3) {
        return str1 + str2 + str3;
    }
    
    // Ayırıcı ile iki string birleştirme
    static string birlestir(const string& str1, const string& str2, char ayirici) {
        return str1 + ayirici + str2;
    }
    
    // String dizisini birleştirme
    static string birlestir(const vector<string>& stringler, const string& ayirici = " ") {
        if (stringler.empty()) return "";
        
        string sonuc = stringler[0];
        for (size_t i = 1; i < stringler.size(); i++) {
            sonuc += ayirici + stringler[i];
        }
        return sonuc;
    }
    
    // String tekrarlama - sayı ile
    static string tekrarla(const string& str, int kez) {
        string sonuc;
        for (int i = 0; i < kez; i++) {
            sonuc += str;
        }
        return sonuc;
    }
    
    // String tekrarlama - ayırıcı ile
    static string tekrarla(const string& str, int kez, const string& ayirici) {
        if (kez <= 0) return "";
        
        string sonuc = str;
        for (int i = 1; i < kez; i++) {
            sonuc += ayirici + str;
        }
        return sonuc;
    }
};

int main() {
    // Birleştirme örnekleri
    cout << StringUtils::birlestir("Merhaba", "Dünya") << endl;
    cout << StringUtils::birlestir("C", "++", "Programming") << endl;
    cout << StringUtils::birlestir("Ali", "Veli", '-') << endl;
    
    vector<string> kelimeler = {"Bu", "bir", "test", "metnidir"};
    cout << StringUtils::birlestir(kelimeler) << endl;
    cout << StringUtils::birlestir(kelimeler, "-") << endl;
    
    // Tekrarlama örnekleri
    cout << StringUtils::tekrarla("Ha", 3) << endl;
    cout << StringUtils::tekrarla("C++", 3, " | ") << endl;
    
    return 0;
}
```

## Overloading ile Dikkat Edilmesi Gerekenler

### 1. Belirsizlik (Ambiguity) Durumları

```cpp
#include <iostream>
using namespace std;

// PROBLEM: Belirsizlik yaratır
void fonksiyon(int x) {
    cout << "int versiyonu: " << x << endl;
}

void fonksiyon(double x) {
    cout << "double versiyonu: " << x << endl;
}

int main() {
    fonksiyon(5);      // OK - int
    fonksiyon(5.0);    // OK - double
    // fonksiyon(5.5f);   // HATA! float belirsizlik yaratır
    
    // Çözüm: Açık tip dönüşümü
    fonksiyon(static_cast<int>(5.5f));     // int versiyonu
    fonksiyon(static_cast<double>(5.5f));  // double versiyonu
    
    return 0;
}
```

### 2. Default Parametreler ile Overloading

```cpp
#include <iostream>
using namespace std;

// Dikkatli olunması gereken durum
void hesapla(int a) {
    cout << "Tek parametre: " << a << endl;
}

void hesapla(int a, int b = 10) {  // Default parametre
    cout << "İki parametre: " << a << ", " << b << endl;
}

int main() {
    // hesapla(5);  // HATA! Belirsizlik - hangi fonksiyon çağrılacak?
    
    hesapla(5, 3);   // OK - açık şekilde iki parametre
    
    return 0;
}
```

### 3. Const ve Non-const Overloading

```cpp
#include <iostream>
using namespace std;

class MyClass {
private:
    int deger;
    
public:
    MyClass(int d) : deger(d) {}
    
    // Non-const versiyonu
    int& getValue() {
        cout << "Non-const versiyonu çağrıldı" << endl;
        return deger;
    }
    
    // Const versiyonu
    const int& getValue() const {
        cout << "Const versiyonu çağrıldı" << endl;
        return deger;
    }
};

int main() {
    MyClass obj(42);
    const MyClass constObj(100);
    
    obj.getValue();       // Non-const versiyonu
    constObj.getValue();  // Const versiyonu
    
    return 0;
}
```

## Pratik Kullanım Örnekleri

### Dosya İşlemleri

```cpp
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
using namespace std;

class FileManager {
public:
    // String'i dosyaya yazma
    static bool dosyayaYaz(const string& dosyaAdi, const string& icerik) {
        ofstream dosya(dosyaAdi);
        if (!dosya.is_open()) return false;
        
        dosya << icerik;
        dosya.close();
        return true;
    }
    
    // String dizisini dosyaya yazma
    static bool dosyayaYaz(const string& dosyaAdi, const vector<string>& satirlar) {
        ofstream dosya(dosyaAdi);
        if (!dosya.is_open()) return false;
        
        for (const string& satir : satirlar) {
            dosya << satir << "\n";
        }
        dosya.close();
        return true;
    }
    
    // Append modunda yazma
    static bool dosyayaYaz(const string& dosyaAdi, const string& icerik, bool append) {
        ofstream dosya;
        if (append) {
            dosya.open(dosyaAdi, ios::app);
        } else {
            dosya.open(dosyaAdi);
        }
        
        if (!dosya.is_open()) return false;
        
        dosya << icerik;
        dosya.close();
        return true;
    }
};

int main() {
    // Tek string yazma
    FileManager::dosyayaYaz("test1.txt", "Merhaba Dünya!");
    
    // String dizisi yazma
    vector<string> satirlar = {"Satır 1", "Satır 2", "Satır 3"};
    FileManager::dosyayaYaz("test2.txt", satirlar);
    
    // Append mode yazma
    FileManager::dosyayaYaz("test1.txt", "\nEklenen satır", true);
    
    return 0;
}
```

### Veri Dönüştürme

```cpp
#include <iostream>
#include <string>
#include <sstream>
#include <vector>
using namespace std;

class Converter {
public:
    // Sayıyı string'e çevirme
    static string toString(int sayi) {
        return to_string(sayi);
    }
    
    static string toString(double sayi) {
        return to_string(sayi);
    }
    
    static string toString(bool deger) {
        return deger ? "true" : "false";
    }
    
    // Özel formatlama ile string'e çevirme
    static string toString(int sayi, int genislik) {
        ostringstream oss;
        oss.width(genislik);
        oss.fill('0');
        oss << sayi;
        return oss.str();
    }
    
    static string toString(double sayi, int ondalikBasamak) {
        ostringstream oss;
        oss.precision(ondalikBasamak);
        oss << fixed << sayi;
        return oss.str();
    }
    
    // Dizi elemanlarını string'e çevirme
    template<typename T>
    static string toString(const vector<T>& dizi, const string& ayirici = ", ") {
        if (dizi.empty()) return "[]";
        
        ostringstream oss;
        oss << "[";
        oss << toString(dizi[0]);
        
        for (size_t i = 1; i < dizi.size(); i++) {
            oss << ayirici << toString(dizi[i]);
        }
        oss << "]";
        return oss.str();
    }
};

int main() {
    // Basit dönüştürmeler
    cout << Converter::toString(42) << endl;
    cout << Converter::toString(3.14159) << endl;
    cout << Converter::toString(true) << endl;
    
    // Formatlı dönüştürmeler
    cout << Converter::toString(42, 5) << endl;        // "00042"
    cout << Converter::toString(3.14159, 2) << endl;   // "3.14"
    
    // Dizi dönüştürme
    vector<int> sayilar = {1, 2, 3, 4, 5};
    cout << Converter::toString(sayilar) << endl;
    cout << Converter::toString(sayilar, " | ") << endl;
    
    return 0;
}
```

## En İyi Uygulamalar

### 1. Anlamlı Overloading

```cpp
// İYİ: Benzer işlevler için overloading
class Calculator {
public:
    double hesapla(double a, double b) { return a + b; }           // Toplama
    double hesapla(double a, double b, double c) { return a + b + c; } // Toplama
    double hesapla(const vector<double>& sayilar) {               // Toplama
        double toplam = 0;
        for (double sayi : sayilar) toplam += sayi;
        return toplam;
    }
};

// KÖTÜ: Farklı işlevler için aynı isim
class BadExample {
public:
    void islem(int a, int b) { cout << a + b; }      // Toplama
    void islem(double a) { cout << a * a; }          // Kare alma - kafayı karıştırır
};
```

### 2. Performans Optimizasyonu

```cpp
#include <iostream>
#include <string>
using namespace std;

class OptimizedString {
public:
    // Küçük stringler için değer ile geçiş
    static string processSmall(string str) {  // Copy semantics
        return str + "_processed";
    }
    
    // Büyük stringler için referans ile geçiş
    static string processLarge(const string& str) {  // Reference semantics
        return str + "_processed";
    }
    
    // C-style string için
    static string process(const char* str) {
        return string(str) + "_processed";
    }
    
    // Move semantics için (C++11)
    static string process(string&& str) {  // Move constructor
        str += "_processed";
        return move(str);
    }
};
```

### 3. Type Safety

```cpp
#include <iostream>
using namespace std;

class SafeCalculator {
public:
    // Güvenli bölme işlemleri
    static double divide(double a, double b) {
        if (b == 0.0) {
            throw invalid_argument("Sıfıra bölme hatası!");
        }
        return a / b;
    }
    
    static int divide(int a, int b) {
        if (b == 0) {
            throw invalid_argument("Sıfıra bölme hatası!");
        }
        return a / b;  // Integer division
    }
    
    static double divideExact(int a, int b) {  // Kesin sonuç için
        if (b == 0) {
            throw invalid_argument("Sıfıra bölme hatası!");
        }
        return static_cast<double>(a) / b;
    }
};

int main() {
    try {
        cout << SafeCalculator::divide(10.0, 3.0) << endl;  // 3.33333
        cout << SafeCalculator::divide(10, 3) << endl;      // 3
        cout << SafeCalculator::divideExact(10, 3) << endl; // 3.33333
        
        // SafeCalculator::divide(10, 0);  // Exception fırlatır
    } catch (const exception& e) {
        cout << "Hata: " << e.what() << endl;
    }
    
    return 0;
}
```

Fonksiyon overloading, C++'da kod okunabilirliğini artıran ve aynı kavramsal işlevi farklı parametrelerle gerçekleştiren fonksiyonlar için tutarlı bir arayüz sağlayan güçlü bir özelliktir. Doğru kullanıldığında, API tasarımını basitleştirir ve kullanıcı deneyimini geliştirir.
