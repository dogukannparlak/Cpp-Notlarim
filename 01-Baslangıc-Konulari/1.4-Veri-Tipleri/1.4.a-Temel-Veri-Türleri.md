# Temel Veri TÃ¼rleri

C++'da veri tÃ¼rleri, deÄŸiÅŸkenlerin hangi tÃ¼r veriyi saklayabileceÄŸini belirler. DoÄŸru veri tÃ¼rÃ¼ seÃ§imi, programÄ±n performansÄ±, bellek kullanÄ±mÄ± ve gÃ¼venliÄŸi aÃ§Ä±sÄ±ndan kritik Ã¶neme sahiptir. Bu bÃ¶lÃ¼mde C++'Ä±n temel veri tÃ¼rlerini, Ã¶zelliklerini ve kullanÄ±m alanlarÄ±nÄ± detaylÄ± olarak inceleyeceÄŸiz.

## Temel SayÄ±sal Veri TÃ¼rleri

### Tam SayÄ± TÃ¼rleri (Integer Types)

```cpp
#include <iostream>
#include <climits>
#include <cstdint>

void demonstrateIntegerTypes() {
    std::cout << "=== Tam SayÄ± Veri TÃ¼rleri ===" << std::endl;
    
    // Temel tam sayÄ± tÃ¼rleri
    char c = 'A';                    // 1 byte (8 bit)
    signed char sc = -100;           // 1 byte, iÅŸaretli
    unsigned char uc = 200;          // 1 byte, iÅŸaretsiz
    
    short s = -1000;                 // En az 2 byte
    unsigned short us = 50000;       // En az 2 byte, iÅŸaretsiz
    
    int i = -2000000;                // En az 2 byte (genellikle 4)
    unsigned int ui = 4000000000U;   // En az 2 byte, iÅŸaretsiz
    
    long l = -3000000000L;           // En az 4 byte
    unsigned long ul = 6000000000UL; // En az 4 byte, iÅŸaretsiz
    
    long long ll = -9000000000000LL; // En az 8 byte
    unsigned long long ull = 18000000000000000000ULL; // En az 8 byte, iÅŸaretsiz
    
    // BoyutlarÄ± ve deÄŸer aralÄ±klarÄ±nÄ± yazdÄ±rma
    std::cout << "\n--- Boyutlar ve DeÄŸer AralÄ±klarÄ± ---" << std::endl;
    
    std::cout << "char: " << sizeof(char) << " byte, ";
    std::cout << "aralÄ±k: " << static_cast<int>(CHAR_MIN) << " ~ " << static_cast<int>(CHAR_MAX) << std::endl;
    
    std::cout << "signed char: " << sizeof(signed char) << " byte, ";
    std::cout << "aralÄ±k: " << static_cast<int>(SCHAR_MIN) << " ~ " << static_cast<int>(SCHAR_MAX) << std::endl;
    
    std::cout << "unsigned char: " << sizeof(unsigned char) << " byte, ";
    std::cout << "aralÄ±k: 0 ~ " << static_cast<int>(UCHAR_MAX) << std::endl;
    
    std::cout << "short: " << sizeof(short) << " byte, ";
    std::cout << "aralÄ±k: " << SHRT_MIN << " ~ " << SHRT_MAX << std::endl;
    
    std::cout << "unsigned short: " << sizeof(unsigned short) << " byte, ";
    std::cout << "aralÄ±k: 0 ~ " << USHRT_MAX << std::endl;
    
    std::cout << "int: " << sizeof(int) << " byte, ";
    std::cout << "aralÄ±k: " << INT_MIN << " ~ " << INT_MAX << std::endl;
    
    std::cout << "unsigned int: " << sizeof(unsigned int) << " byte, ";
    std::cout << "aralÄ±k: 0 ~ " << UINT_MAX << std::endl;
    
    std::cout << "long: " << sizeof(long) << " byte, ";
    std::cout << "aralÄ±k: " << LONG_MIN << " ~ " << LONG_MAX << std::endl;
    
    std::cout << "unsigned long: " << sizeof(unsigned long) << " byte, ";
    std::cout << "aralÄ±k: 0 ~ " << ULONG_MAX << std::endl;
    
    std::cout << "long long: " << sizeof(long long) << " byte, ";
    std::cout << "aralÄ±k: " << LLONG_MIN << " ~ " << LLONG_MAX << std::endl;
    
    std::cout << "unsigned long long: " << sizeof(unsigned long long) << " byte, ";
    std::cout << "aralÄ±k: 0 ~ " << ULLONG_MAX << std::endl;
    
    // DeÄŸerleri yazdÄ±rma
    std::cout << "\n--- Ã–rnek DeÄŸerler ---" << std::endl;
    std::cout << "char c = '" << c << "' (ASCII: " << static_cast<int>(c) << ")" << std::endl;
    std::cout << "signed char sc = " << static_cast<int>(sc) << std::endl;
    std::cout << "unsigned char uc = " << static_cast<int>(uc) << std::endl;
    std::cout << "short s = " << s << std::endl;
    std::cout << "unsigned short us = " << us << std::endl;
    std::cout << "int i = " << i << std::endl;
    std::cout << "unsigned int ui = " << ui << std::endl;
    std::cout << "long l = " << l << std::endl;
    std::cout << "unsigned long ul = " << ul << std::endl;
    std::cout << "long long ll = " << ll << std::endl;
    std::cout << "unsigned long long ull = " << ull << std::endl;
}

// Sabit boyutlu tam sayÄ± tÃ¼rleri (C++11)
void demonstrateFixedSizeIntegers() {
    std::cout << "\n=== Sabit Boyutlu Tam SayÄ± TÃ¼rleri ===" << std::endl;
    
    // Kesin boyutlu tÃ¼rler
    std::int8_t i8 = -128;
    std::uint8_t ui8 = 255;
    
    std::int16_t i16 = -32768;
    std::uint16_t ui16 = 65535;
    
    std::int32_t i32 = -2147483648;
    std::uint32_t ui32 = 4294967295U;
    
    std::int64_t i64 = -9223372036854775807LL - 1; // LLONG_MIN
    std::uint64_t ui64 = 18446744073709551615ULL;
    
    std::cout << "int8_t: " << sizeof(i8) << " byte, deÄŸer: " << static_cast<int>(i8) << std::endl;
    std::cout << "uint8_t: " << sizeof(ui8) << " byte, deÄŸer: " << static_cast<int>(ui8) << std::endl;
    std::cout << "int16_t: " << sizeof(i16) << " byte, deÄŸer: " << i16 << std::endl;
    std::cout << "uint16_t: " << sizeof(ui16) << " byte, deÄŸer: " << ui16 << std::endl;
    std::cout << "int32_t: " << sizeof(i32) << " byte, deÄŸer: " << i32 << std::endl;
    std::cout << "uint32_t: " << sizeof(ui32) << " byte, deÄŸer: " << ui32 << std::endl;
    std::cout << "int64_t: " << sizeof(i64) << " byte, deÄŸer: " << i64 << std::endl;
    std::cout << "uint64_t: " << sizeof(ui64) << " byte, deÄŸer: " << ui64 << std::endl;
    
    // En hÄ±zlÄ± ve en kÃ¼Ã§Ã¼k tÃ¼rler
    std::cout << "\n--- Ã–zel Performans TÃ¼rleri ---" << std::endl;
    
    std::int_fast8_t fast8 = 100;
    std::int_least8_t least8 = 50;
    std::intmax_t maxint = 999999999999999999LL;
    std::uintmax_t maxuint = 18446744073709551615ULL;
    
    std::cout << "int_fast8_t boyutu: " << sizeof(fast8) << " byte" << std::endl;
    std::cout << "int_least8_t boyutu: " << sizeof(least8) << " byte" << std::endl;
    std::cout << "intmax_t boyutu: " << sizeof(maxint) << " byte" << std::endl;
    std::cout << "uintmax_t boyutu: " << sizeof(maxuint) << " byte" << std::endl;
}

int main() {
    demonstrateIntegerTypes();
    demonstrateFixedSizeIntegers();
    return 0;
}
```

### OndalÄ±k SayÄ± TÃ¼rleri (Floating-Point Types)

```cpp
#include <iostream>
#include <iomanip>
#include <cfloat>
#include <cmath>
#include <limits>

void demonstrateFloatingPointTypes() {
    std::cout << "\n=== OndalÄ±k SayÄ± Veri TÃ¼rleri ===" << std::endl;
    
    // Temel ondalÄ±k tÃ¼rler
    float f = 3.14159f;              // Tek duyarlÄ±klÄ± (genellikle 4 byte)
    double d = 3.141592653589793;    // Ã‡ift duyarlÄ±klÄ± (genellikle 8 byte)
    long double ld = 3.1415926535897932384626433832795L; // GeniÅŸletilmiÅŸ duyarlÄ±k
    
    // Boyutlar ve duyarlÄ±k bilgileri
    std::cout << "\n--- Boyutlar ve DuyarlÄ±k ---" << std::endl;
    std::cout << "float: " << sizeof(float) << " byte" << std::endl;
    std::cout << "double: " << sizeof(double) << " byte" << std::endl;
    std::cout << "long double: " << sizeof(long double) << " byte" << std::endl;
    
    std::cout << "\nFloat duyarlÄ±ÄŸÄ±: " << FLT_DIG << " ondalÄ±k basamak" << std::endl;
    std::cout << "Double duyarlÄ±ÄŸÄ±: " << DBL_DIG << " ondalÄ±k basamak" << std::endl;
    std::cout << "Long double duyarlÄ±ÄŸÄ±: " << LDBL_DIG << " ondalÄ±k basamak" << std::endl;
    
    // DeÄŸer aralÄ±klarÄ±
    std::cout << "\n--- DeÄŸer AralÄ±klarÄ± ---" << std::endl;
    std::cout << "Float min: " << FLT_MIN << std::endl;
    std::cout << "Float max: " << FLT_MAX << std::endl;
    std::cout << "Double min: " << DBL_MIN << std::endl;
    std::cout << "Double max: " << DBL_MAX << std::endl;
    std::cout << "Long double min: " << LDBL_MIN << std::endl;
    std::cout << "Long double max: " << LDBL_MAX << std::endl;
    
    // DuyarlÄ±k karÅŸÄ±laÅŸtÄ±rmasÄ±
    std::cout << "\n--- DuyarlÄ±k KarÅŸÄ±laÅŸtÄ±rmasÄ± ---" << std::endl;
    std::cout << std::fixed << std::setprecision(20);
    std::cout << "float deÄŸeri:       " << f << std::endl;
    std::cout << "double deÄŸeri:      " << d << std::endl;
    std::cout << "long double deÄŸeri: " << ld << std::endl;
    
    // Ã–zel deÄŸerler
    std::cout << "\n--- Ã–zel DeÄŸerler ---" << std::endl;
    std::cout << std::defaultfloat;
    
    double positive_infinity = std::numeric_limits<double>::infinity();
    double negative_infinity = -std::numeric_limits<double>::infinity();
    double not_a_number = std::numeric_limits<double>::quiet_NaN();
    
    std::cout << "Pozitif sonsuz: " << positive_infinity << std::endl;
    std::cout << "Negatif sonsuz: " << negative_infinity << std::endl;
    std::cout << "NaN (Not a Number): " << not_a_number << std::endl;
    
    // NaN ve sonsuzluk kontrolleri
    std::cout << "\n--- Ã–zel DeÄŸer Kontrolleri ---" << std::endl;
    std::cout << "positive_infinity sonsuz mu? " << std::isinf(positive_infinity) << std::endl;
    std::cout << "not_a_number NaN mÄ±? " << std::isnan(not_a_number) << std::endl;
    std::cout << "normal sayÄ± sonlu mu? " << std::isfinite(3.14) << std::endl;
    
    // OndalÄ±k sayÄ± iÅŸlemleri ve duyarlÄ±k sorunlarÄ±
    std::cout << "\n--- DuyarlÄ±k SorunlarÄ± ---" << std::endl;
    
    float f1 = 0.1f;
    float f2 = 0.2f;
    float sum = f1 + f2;
    
    std::cout << std::fixed << std::setprecision(10);
    std::cout << "0.1f + 0.2f = " << sum << std::endl;
    std::cout << "Bu 0.3f'ye eÅŸit mi? " << (sum == 0.3f) << std::endl;
    
    // GÃ¼venli karÅŸÄ±laÅŸtÄ±rma
    const float epsilon = 1e-7f;
    bool isEqual = std::abs(sum - 0.3f) < epsilon;
    std::cout << "Epsilon ile karÅŸÄ±laÅŸtÄ±rma: " << isEqual << std::endl;
}

// Bilimsel notasyon ve hexadecimal float literaller
void demonstrateFloatLiterals() {
    std::cout << "\n=== Float Literal FormatlarÄ± ===" << std::endl;
    
    // FarklÄ± literal formatlarÄ±
    double d1 = 123.456;           // Normal notasyon
    double d2 = 1.23456e2;         // Bilimsel notasyon
    double d3 = 1.23456E2;         // BÃ¼yÃ¼k E ile bilimsel notasyon
    double d4 = 0x1.921fb54442d18p+1; // Hexadecimal float (C++17)
    
    std::cout << "Normal: " << d1 << std::endl;
    std::cout << "Bilimsel (e): " << d2 << std::endl;
    std::cout << "Bilimsel (E): " << d3 << std::endl;
    std::cout << "Hexadecimal: " << d4 << " (Ï€)" << std::endl;
    
    // Ã‡ok bÃ¼yÃ¼k ve Ã§ok kÃ¼Ã§Ã¼k sayÄ±lar
    double large = 1.5e308;        // Ã‡ok bÃ¼yÃ¼k sayÄ±
    double small = 1.5e-308;       // Ã‡ok kÃ¼Ã§Ã¼k sayÄ±
    
    std::cout << "\nÃ‡ok bÃ¼yÃ¼k sayÄ±: " << large << std::endl;
    std::cout << "Ã‡ok kÃ¼Ã§Ã¼k sayÄ±: " << small << std::endl;
}

int main() {
    demonstrateFloatingPointTypes();
    demonstrateFloatLiterals();
    return 0;
}
```

## Karakter ve String TÃ¼rleri

### Karakter TÃ¼rleri

```cpp
#include <iostream>
#include <string>
#include <locale>
#include <codecvt>

void demonstrateCharacterTypes() {
    std::cout << "\n=== Karakter Veri TÃ¼rleri ===" << std::endl;
    
    // Temel karakter tÃ¼rleri
    char c = 'A';                    // ASCII karakter (1 byte)
    wchar_t wc = L'Î©';              // GeniÅŸ karakter (2 veya 4 byte)
    char16_t c16 = u'Î±';            // UTF-16 karakter (2 byte) - C++11
    char32_t c32 = U'ğŸŒŸ';           // UTF-32 karakter (4 byte) - C++11
    char8_t c8 = u8'â‚¬';             // UTF-8 karakter (1 byte) - C++20
    
    std::cout << "char boyutu: " << sizeof(char) << " byte" << std::endl;
    std::cout << "wchar_t boyutu: " << sizeof(wchar_t) << " byte" << std::endl;
    std::cout << "char16_t boyutu: " << sizeof(char16_t) << " byte" << std::endl;
    std::cout << "char32_t boyutu: " << sizeof(char32_t) << " byte" << std::endl;
    std::cout << "char8_t boyutu: " << sizeof(char8_t) << " byte" << std::endl;
    
    // Karakter deÄŸerleri
    std::cout << "\n--- Karakter DeÄŸerleri ---" << std::endl;
    std::cout << "char: '" << c << "' (ASCII kodu: " << static_cast<int>(c) << ")" << std::endl;
    std::wcout << L"wchar_t: '" << wc << L"' (kod: " << static_cast<int>(wc) << L")" << std::endl;
    
    // Ã–zel karakter escape dizileri
    std::cout << "\n--- Escape Dizileri ---" << std::endl;
    char newline = '\n';
    char tab = '\t';
    char backslash = '\\';
    char quote = '\'';
    char doublequote = '\"';
    char null_char = '\0';
    
    std::cout << "Yeni satÄ±r: ASCII " << static_cast<int>(newline) << std::endl;
    std::cout << "Tab: ASCII " << static_cast<int>(tab) << std::endl;
    std::cout << "Backslash: '" << backslash << "'" << std::endl;
    std::cout << "Tek tÄ±rnak: '" << quote << "'" << std::endl;
    std::cout << "Ã‡ift tÄ±rnak: '" << doublequote << "'" << std::endl;
    std::cout << "Null karakter: ASCII " << static_cast<int>(null_char) << std::endl;
    
    // Hexadecimal ve octal karakter literalleri
    char hex_char = '\x41';         // Hexadecimal 'A'
    char octal_char = '\101';       // Octal 'A'
    
    std::cout << "\nHex karakter \\x41: '" << hex_char << "'" << std::endl;
    std::cout << "Octal karakter \\101: '" << octal_char << "'" << std::endl;
}

// String tÃ¼rleri ve literal formatlarÄ±
void demonstrateStringTypes() {
    std::cout << "\n=== String TÃ¼rleri ===" << std::endl;
    
    // C-style string (char array)
    char cstring[] = "Merhaba C++";
    char* cstring_ptr = "Bu bir C string";
    
    // C++ string sÄ±nÄ±fÄ±
    std::string cpp_string = "Modern C++ String";
    std::string empty_string;
    std::string initialized_string(10, 'X'); // 10 tane 'X' karakteri
    
    std::cout << "C-style string: " << cstring << std::endl;
    std::cout << "C string pointer: " << cstring_ptr << std::endl;
    std::cout << "C++ string: " << cpp_string << std::endl;
    std::cout << "BoÅŸ string uzunluÄŸu: " << empty_string.length() << std::endl;
    std::cout << "BaÅŸlatÄ±lmÄ±ÅŸ string: " << initialized_string << std::endl;
    
    // GeniÅŸ karakter stringleri
    std::wstring wide_string = L"GeniÅŸ karakter string";
    std::u16string utf16_string = u"UTF-16 string";
    std::u32string utf32_string = U"UTF-32 string";
    
    std::wcout << L"Wide string: " << wide_string << std::endl;
    std::cout << "UTF-16 string uzunluÄŸu: " << utf16_string.length() << std::endl;
    std::cout << "UTF-32 string uzunluÄŸu: " << utf32_string.length() << std::endl;
    
    // String literal suffixleri
    auto raw_string = R"(Bu bir "raw" string literal'dir.
Ã‡ok satÄ±rlÄ± olabilir ve escape karakterlere ihtiyaÃ§ duymaz: \ / " ')";
    
    std::cout << "\nRaw string:\n" << raw_string << std::endl;
    
    // String concatenation
    std::string first_name = "Ahmet";
    std::string last_name = "YÄ±lmaz";
    std::string full_name = first_name + " " + last_name;
    
    std::cout << "\nString birleÅŸtirme: " << full_name << std::endl;
    
    // String uzunluk ve boyut
    std::cout << "String uzunluÄŸu: " << full_name.length() << std::endl;
    std::cout << "String boyutu: " << full_name.size() << std::endl;
    std::cout << "String kapasitesi: " << full_name.capacity() << std::endl;
}

// Karakter kontrol fonksiyonlarÄ±
void demonstrateCharacterFunctions() {
    std::cout << "\n=== Karakter Kontrol FonksiyonlarÄ± ===" << std::endl;
    
    char test_chars[] = {'A', 'z', '5', ' ', '@', '\n'};
    int num_chars = sizeof(test_chars) / sizeof(test_chars[0]);
    
    for (int i = 0; i < num_chars; ++i) {
        char ch = test_chars[i];
        
        std::cout << "\nKarakter: ";
        if (ch == '\n') {
            std::cout << "'\\n'";
        } else if (ch == ' ') {
            std::cout << "' '";
        } else {
            std::cout << "'" << ch << "'";
        }
        std::cout << " (ASCII: " << static_cast<int>(ch) << ")" << std::endl;
        
        std::cout << "  Harf mi? " << std::isalpha(ch) << std::endl;
        std::cout << "  Rakam mÄ±? " << std::isdigit(ch) << std::endl;
        std::cout << "  Alfanumerik mi? " << std::isalnum(ch) << std::endl;
        std::cout << "  BÃ¼yÃ¼k harf mi? " << std::isupper(ch) << std::endl;
        std::cout << "  KÃ¼Ã§Ã¼k harf mi? " << std::islower(ch) << std::endl;
        std::cout << "  BoÅŸluk mu? " << std::isspace(ch) << std::endl;
        std::cout << "  Noktalama mÄ±? " << std::ispunct(ch) << std::endl;
        
        if (std::isalpha(ch)) {
            std::cout << "  BÃ¼yÃ¼k harfe Ã§evrilmiÅŸ: '" << static_cast<char>(std::toupper(ch)) << "'" << std::endl;
            std::cout << "  KÃ¼Ã§Ã¼k harfe Ã§evrilmiÅŸ: '" << static_cast<char>(std::tolower(ch)) << "'" << std::endl;
        }
    }
}

int main() {
    demonstrateCharacterTypes();
    demonstrateStringTypes();
    demonstrateCharacterFunctions();
    return 0;
}
```

## Boolean ve Void TÃ¼rleri

### Boolean TÃ¼rÃ¼

```cpp
#include <iostream>
#include <string>

void demonstrateBooleanType() {
    std::cout << "\n=== Boolean Veri TÃ¼rÃ¼ ===" << std::endl;
    
    // Boolean deÄŸiÅŸkenler
    bool is_true = true;
    bool is_false = false;
    bool default_bool;              // VarsayÄ±lan deÄŸer (false)
    
    std::cout << "bool boyutu: " << sizeof(bool) << " byte" << std::endl;
    std::cout << "true deÄŸeri: " << is_true << std::endl;
    std::cout << "false deÄŸeri: " << is_false << std::endl;
    std::cout << "BaÅŸlatÄ±lmamÄ±ÅŸ bool: " << default_bool << std::endl;
    
    // Boolean literal'lar ve dÃ¶nÃ¼ÅŸÃ¼mler
    std::cout << "\n--- Boolean DÃ¶nÃ¼ÅŸÃ¼mler ---" << std::endl;
    
    // SayÄ±lardan boolean'a dÃ¶nÃ¼ÅŸÃ¼m
    bool from_zero = 0;             // false
    bool from_nonzero = 42;         // true
    bool from_negative = -1;        // true
    
    std::cout << "0'dan bool: " << from_zero << std::endl;
    std::cout << "42'den bool: " << from_nonzero << std::endl;
    std::cout << "-1'den bool: " << from_negative << std::endl;
    
    // Pointer'dan boolean'a dÃ¶nÃ¼ÅŸÃ¼m
    int* null_ptr = nullptr;
    int* valid_ptr = &from_zero;
    
    bool bool_from_null = null_ptr;
    bool bool_from_valid = valid_ptr;
    
    std::cout << "nullptr'dan bool: " << bool_from_null << std::endl;
    std::cout << "GeÃ§erli pointer'dan bool: " << bool_from_valid << std::endl;
    
    // String'den boolean kontrolÃ¼
    std::string empty_string = "";
    std::string non_empty_string = "Merhaba";
    
    bool bool_from_empty = !empty_string.empty();
    bool bool_from_non_empty = !non_empty_string.empty();
    
    std::cout << "BoÅŸ string'den bool: " << bool_from_empty << std::endl;
    std::cout << "Dolu string'den bool: " << bool_from_non_empty << std::endl;
    
    // Boolean operatÃ¶rleri
    std::cout << "\n--- Boolean OperatÃ¶rleri ---" << std::endl;
    
    bool a = true;
    bool b = false;
    
    std::cout << "a = " << a << ", b = " << b << std::endl;
    std::cout << "a && b (VE): " << (a && b) << std::endl;
    std::cout << "a || b (VEYA): " << (a || b) << std::endl;
    std::cout << "!a (DEÄÄ°L): " << (!a) << std::endl;
    std::cout << "!b (DEÄÄ°L): " << (!b) << std::endl;
    std::cout << "a == b (EÅÄ°T): " << (a == b) << std::endl;
    std::cout << "a != b (EÅÄ°T DEÄÄ°L): " << (a != b) << std::endl;
    
    // KÄ±sa devre deÄŸerlendirme (short-circuit evaluation)
    std::cout << "\n--- KÄ±sa Devre DeÄŸerlendirme ---" << std::endl;
    
    int counter = 0;
    auto increment_counter = [&counter]() -> bool {
        counter++;
        std::cout << "Counter arttÄ±rÄ±ldÄ±: " << counter << std::endl;
        return true;
    };
    
    std::cout << "false && increment_counter(): ";
    bool result1 = false && increment_counter(); // increment_counter Ã§aÄŸrÄ±lmaz
    std::cout << result1 << std::endl;
    std::cout << "Counter deÄŸeri: " << counter << std::endl;
    
    std::cout << "true || increment_counter(): ";
    bool result2 = true || increment_counter(); // increment_counter Ã§aÄŸrÄ±lmaz
    std::cout << result2 << std::endl;
    std::cout << "Counter deÄŸeri: " << counter << std::endl;
    
    std::cout << "false || increment_counter(): ";
    bool result3 = false || increment_counter(); // increment_counter Ã§aÄŸrÄ±lÄ±r
    std::cout << result3 << std::endl;
    std::cout << "Counter deÄŸeri: " << counter << std::endl;
}

// Boolean kullanÄ±m Ã¶rnekleri
void demonstrateBooleanUsage() {
    std::cout << "\n=== Boolean KullanÄ±m Ã–rnekleri ===" << std::endl;
    
    // Kontrol yapÄ±larÄ±
    bool is_student = true;
    bool has_scholarship = false;
    int age = 20;
    
    if (is_student) {
        std::cout << "Bu kiÅŸi Ã¶ÄŸrenci" << std::endl;
        
        if (has_scholarship) {
            std::cout << "Ve burslu" << std::endl;
        } else {
            std::cout << "Ama burssuz" << std::endl;
        }
    }
    
    // Ternary operator ile boolean kullanÄ±mÄ±
    std::string status = (age >= 18) ? "YetiÅŸkin" : "Ã‡ocuk";
    std::cout << "YaÅŸ durumu: " << status << std::endl;
    
    // Boolean deÄŸer dÃ¶ndÃ¼ren fonksiyonlar
    auto isEven = [](int number) -> bool {
        return number % 2 == 0;
    };
    
    auto isPrime = [](int number) -> bool {
        if (number < 2) return false;
        if (number == 2) return true;
        if (number % 2 == 0) return false;
        
        for (int i = 3; i * i <= number; i += 2) {
            if (number % i == 0) return false;
        }
        return true;
    };
    
    std::cout << "\n--- Boolean Fonksiyon Ã–rnekleri ---" << std::endl;
    for (int i = 1; i <= 10; ++i) {
        std::cout << i << ": ";
        std::cout << "Ã§ift=" << isEven(i) << ", ";
        std::cout << "asal=" << isPrime(i) << std::endl;
    }
    
    // Boolean bayraklar (flags)
    bool is_debug_mode = true;
    bool is_verbose = false;
    bool is_testing = true;
    
    if (is_debug_mode && is_verbose) {
        std::cout << "Debug: DetaylÄ± Ã§Ä±ktÄ± modu" << std::endl;
    } else if (is_debug_mode) {
        std::cout << "Debug: Normal Ã§Ä±ktÄ± modu" << std::endl;
    }
    
    if (is_testing) {
        std::cout << "Test modu aktif" << std::endl;
    }
}

int main() {
    demonstrateBooleanType();
    demonstrateBooleanUsage();
    return 0;
}
```

### Void TÃ¼rÃ¼

```cpp
#include <iostream>
#include <memory>

// Void fonksiyonlar
void printMessage() {
    std::cout << "Bu fonksiyon void tÃ¼rÃ¼nde - deÄŸer dÃ¶ndÃ¼rmez" << std::endl;
}

void printNumber(int number) {
    std::cout << "SayÄ±: " << number << std::endl;
    // return statement'a gerek yok
}

// Void pointer kullanÄ±mÄ±
void demonstrateVoidPointers() {
    std::cout << "\n=== Void Pointer KullanÄ±mÄ± ===" << std::endl;
    
    int integer_value = 42;
    double double_value = 3.14159;
    char char_value = 'A';
    
    // Void pointer - herhangi bir tÃ¼re iÅŸaret edebilir
    void* void_ptr;
    
    // FarklÄ± tÃ¼rlere iÅŸaret etme
    void_ptr = &integer_value;
    std::cout << "Void pointer integer'a iÅŸaret ediyor" << std::endl;
    std::cout << "Adres: " << void_ptr << std::endl;
    
    // Void pointer'dan veri okumak iÃ§in cast gerekli
    int* int_ptr = static_cast<int*>(void_ptr);
    std::cout << "Integer deÄŸeri: " << *int_ptr << std::endl;
    
    // BaÅŸka bir tÃ¼re iÅŸaret etme
    void_ptr = &double_value;
    double* double_ptr = static_cast<double*>(void_ptr);
    std::cout << "Double deÄŸeri: " << *double_ptr << std::endl;
    
    void_ptr = &char_value;
    char* char_ptr = static_cast<char*>(void_ptr);
    std::cout << "Char deÄŸeri: " << *char_ptr << std::endl;
    
    // Void pointer aritmetiÄŸi yapÄ±lamaz
    // void_ptr++; // HATA: void pointer arithmetic
    
    // Void pointer boyutu
    std::cout << "Void pointer boyutu: " << sizeof(void*) << " byte" << std::endl;
}

// Generic veri iÅŸleme fonksiyonu
void printData(void* data, char type) {
    switch (type) {
        case 'i': // integer
            std::cout << "Integer: " << *static_cast<int*>(data) << std::endl;
            break;
        case 'd': // double
            std::cout << "Double: " << *static_cast<double*>(data) << std::endl;
            break;
        case 'c': // char
            std::cout << "Char: " << *static_cast<char*>(data) << std::endl;
            break;
        case 's': // string
            std::cout << "String: " << static_cast<char*>(data) << std::endl;
            break;
        default:
            std::cout << "Bilinmeyen tÃ¼r" << std::endl;
    }
}

// Memory allocation Ã¶rneÄŸi
void demonstrateVoidInMemoryAllocation() {
    std::cout << "\n=== Void ve Memory Allocation ===" << std::endl;
    
    // malloc void* dÃ¶ndÃ¼rÃ¼r
    void* raw_memory = std::malloc(sizeof(int) * 10);
    
    if (raw_memory != nullptr) {
        // void*'dan int*'a cast
        int* int_array = static_cast<int*>(raw_memory);
        
        // Array'i doldur
        for (int i = 0; i < 10; ++i) {
            int_array[i] = i * i;
        }
        
        // Array'i yazdÄ±r
        std::cout << "Dinamik array: ";
        for (int i = 0; i < 10; ++i) {
            std::cout << int_array[i] << " ";
        }
        std::cout << std::endl;
        
        // BelleÄŸi serbest bÄ±rak
        std::free(raw_memory);
        raw_memory = nullptr;
    }
    
    // Modern C++ ile void* kullanÄ±mÄ±
    std::cout << "\n--- Modern C++ YaklaÅŸÄ±mÄ± ---" << std::endl;
    
    // unique_ptr ile otomatik bellek yÃ¶netimi
    auto smart_memory = std::make_unique<int[]>(10);
    
    for (int i = 0; i < 10; ++i) {
        smart_memory[i] = i * 2;
    }
    
    std::cout << "Smart pointer array: ";
    for (int i = 0; i < 10; ++i) {
        std::cout << smart_memory[i] << " ";
    }
    std::cout << std::endl;
    
    // Otomatik olarak temizlenir
}

void demonstrateVoidType() {
    std::cout << "\n=== Void Veri TÃ¼rÃ¼ ===" << std::endl;
    
    // Void fonksiyon Ã§aÄŸÄ±rma
    printMessage();
    printNumber(100);
    
    // Void pointer demonstrasyonu
    demonstrateVoidPointers();
    
    // Generic veri iÅŸleme
    std::cout << "\n--- Generic Veri Ä°ÅŸleme ---" << std::endl;
    
    int i = 42;
    double d = 3.14159;
    char c = 'X';
    char str[] = "Merhaba";
    
    printData(&i, 'i');
    printData(&d, 'd');
    printData(&c, 'c');
    printData(str, 's');
    
    // Memory allocation
    demonstrateVoidInMemoryAllocation();
    
    // Void tÃ¼rÃ¼nÃ¼n sÄ±nÄ±rlamalarÄ±
    std::cout << "\n--- Void TÃ¼rÃ¼ SÄ±nÄ±rlamalarÄ± ---" << std::endl;
    std::cout << "â€¢ Void tÃ¼rÃ¼nde deÄŸiÅŸken tanÄ±mlanamaz" << std::endl;
    std::cout << "â€¢ Void pointer'lar doÄŸrudan eriÅŸilemez" << std::endl;
    std::cout << "â€¢ Void pointer aritmetiÄŸi yapÄ±lamaz" << std::endl;
    std::cout << "â€¢ Cast iÅŸlemi gerektirir" << std::endl;
    
    // sizeof(void) tanÄ±msÄ±zdÄ±r
    // std::cout << sizeof(void) << std::endl; // HATA
    
    std::cout << "â€¢ sizeof(void) tanÄ±msÄ±zdÄ±r" << std::endl;
    std::cout << "â€¢ Void fonksiyonlar deÄŸer dÃ¶ndÃ¼rmez" << std::endl;
}

int main() {
    demonstrateVoidType();
    return 0;
}
```

## TÃ¼r DÃ¶nÃ¼ÅŸÃ¼mleri ve Type Safety

### Implicit ve Explicit Conversions

```cpp
#include <iostream>
#include <limits>
#include <string>

void demonstrateImplicitConversions() {
    std::cout << "\n=== Ã–rtÃ¼k TÃ¼r DÃ¶nÃ¼ÅŸÃ¼mleri (Implicit) ===" << std::endl;
    
    // SayÄ±sal tÃ¼rler arasÄ± dÃ¶nÃ¼ÅŸÃ¼mler
    std::cout << "--- SayÄ±sal DÃ¶nÃ¼ÅŸÃ¼mler ---" << std::endl;
    
    // KÃ¼Ã§Ã¼k tÃ¼rden bÃ¼yÃ¼k tÃ¼re (gÃ¼venli)
    char c = 100;
    int i = c;           // char -> int (gÃ¼venli)
    long l = i;          // int -> long (gÃ¼venli)
    float f = l;         // long -> float (duyarlÄ±k kaybÄ± olabilir)
    double d = f;        // float -> double (gÃ¼venli)
    
    std::cout << "char: " << static_cast<int>(c) << " -> int: " << i << std::endl;
    std::cout << "int: " << i << " -> long: " << l << std::endl;
    std::cout << "long: " << l << " -> float: " << f << std::endl;
    std::cout << "float: " << f << " -> double: " << d << std::endl;
    
    // BÃ¼yÃ¼k tÃ¼rden kÃ¼Ã§Ã¼k tÃ¼re (riskli)
    std::cout << "\n--- Riskli DÃ¶nÃ¼ÅŸÃ¼mler ---" << std::endl;
    
    int large_int = 300;
    char small_char = large_int;  // Veri kaybÄ±!
    
    std::cout << "int 300 -> char: " << static_cast<int>(small_char) << std::endl;
    
    double large_double = 3.14159;
    int truncated_int = large_double;  // OndalÄ±k kÄ±sÄ±m kaybÄ±
    
    std::cout << "double 3.14159 -> int: " << truncated_int << std::endl;
    
    // Boolean dÃ¶nÃ¼ÅŸÃ¼mler
    std::cout << "\n--- Boolean DÃ¶nÃ¼ÅŸÃ¼mler ---" << std::endl;
    
    bool b1 = 5;         // SÄ±fÄ±r olmayan -> true
    bool b2 = 0;         // SÄ±fÄ±r -> false
    bool b3 = -1;        // SÄ±fÄ±r olmayan -> true
    
    int i1 = true;       // true -> 1
    int i2 = false;      // false -> 0
    
    std::cout << "5 -> bool: " << b1 << std::endl;
    std::cout << "0 -> bool: " << b2 << std::endl;
    std::cout << "-1 -> bool: " << b3 << std::endl;
    std::cout << "true -> int: " << i1 << std::endl;
    std::cout << "false -> int: " << i2 << std::endl;
    
    // Pointer dÃ¶nÃ¼ÅŸÃ¼mler
    std::cout << "\n--- Pointer DÃ¶nÃ¼ÅŸÃ¼mler ---" << std::endl;
    
    int* ptr = nullptr;
    bool null_check = ptr;          // nullptr -> false
    
    int value = 42;
    int* valid_ptr = &value;
    bool valid_check = valid_ptr;   // geÃ§erli pointer -> true
    
    std::cout << "nullptr -> bool: " << null_check << std::endl;
    std::cout << "geÃ§erli pointer -> bool: " << valid_check << std::endl;
}

void demonstrateExplicitConversions() {
    std::cout << "\n=== AÃ§Ä±k TÃ¼r DÃ¶nÃ¼ÅŸÃ¼mleri (Explicit) ===" << std::endl;
    
    // C-style cast (Ã¶nerilmez)
    std::cout << "--- C-Style Cast ---" << std::endl;
    
    double d = 3.14159;
    int i = (int)d;              // C-style cast
    char* str = (char*)"Merhaba"; // C-style cast
    
    std::cout << "C-style cast double->int: " << i << std::endl;
    
    // Static cast (compile-time, gÃ¼venli)
    std::cout << "\n--- Static Cast ---" << std::endl;
    
    double d2 = 2.71828;
    int i2 = static_cast<int>(d2);
    float f2 = static_cast<float>(d2);
    
    std::cout << "static_cast double->int: " << i2 << std::endl;
    std::cout << "static_cast double->float: " << f2 << std::endl;
    
    // Enum dÃ¶nÃ¼ÅŸÃ¼mler
    enum Color { RED = 1, GREEN = 2, BLUE = 3 };
    
    int color_value = static_cast<int>(RED);
    Color color_enum = static_cast<Color>(2);
    
    std::cout << "enum->int: " << color_value << std::endl;
    std::cout << "int->enum: " << color_enum << std::endl;
    
    // Dynamic cast (runtime, polymorphic tÃ¼rler iÃ§in)
    std::cout << "\n--- Dynamic Cast ---" << std::endl;
    std::cout << "Dynamic cast polimorfik sÄ±nÄ±flarla kullanÄ±lÄ±r" << std::endl;
    
    // Const cast (const'luÄŸu kaldÄ±rÄ±r/ekler)
    std::cout << "\n--- Const Cast ---" << std::endl;
    
    const int const_value = 100;
    int* mutable_ptr = const_cast<int*>(&const_value);
    
    std::cout << "const_cast kullanÄ±ldÄ± (dikkatli olun!)" << std::endl;
    std::cout << "Orijinal const deÄŸer: " << const_value << std::endl;
    std::cout << "Mutable pointer ile: " << *mutable_ptr << std::endl;
    
    // Reinterpret cast (bit dÃ¼zeyinde dÃ¶nÃ¼ÅŸÃ¼m, Ã§ok riskli)
    std::cout << "\n--- Reinterpret Cast ---" << std::endl;
    
    int int_value = 0x41424344;  // "ABCD" in hex
    char* char_ptr = reinterpret_cast<char*>(&int_value);
    
    std::cout << "reinterpret_cast int->char*: ";
    for (int i = 0; i < 4; ++i) {
        std::cout << char_ptr[i];
    }
    std::cout << std::endl;
}

// Type safety ve modern C++ yaklaÅŸÄ±mlarÄ±
void demonstrateTypeSafety() {
    std::cout << "\n=== Type Safety ve Modern YaklaÅŸÄ±mlar ===" << std::endl;
    
    // auto keyword ile tÃ¼r Ã§Ä±karÄ±mÄ±
    std::cout << "--- Auto Keyword ---" << std::endl;
    
    auto automatic_int = 42;           // int
    auto automatic_double = 3.14;      // double
    auto automatic_string = "Merhaba"; // const char*
    auto automatic_bool = true;        // bool
    
    std::cout << "auto int: " << automatic_int << std::endl;
    std::cout << "auto double: " << automatic_double << std::endl;
    std::cout << "auto string: " << automatic_string << std::endl;
    std::cout << "auto bool: " << automatic_bool << std::endl;
    
    // decltype ile tÃ¼r belirleme
    std::cout << "\n--- Decltype ---" << std::endl;
    
    int x = 10;
    decltype(x) y = 20;              // y de int tÃ¼rÃ¼nde
    decltype(x + y) z = x + y;       // z da int tÃ¼rÃ¼nde
    
    std::cout << "decltype ile: x=" << x << ", y=" << y << ", z=" << z << std::endl;
    
    // Uniform initialization (brace initialization)
    std::cout << "\n--- Uniform Initialization ---" << std::endl;
    
    int brace_int{42};               // GÃ¼venli baÅŸlatma
    double brace_double{3.14159};    // GÃ¼venli baÅŸlatma
    
    // DaraltÄ±cÄ± dÃ¶nÃ¼ÅŸÃ¼mler Ã¶nlenir
    // int narrow{3.14};             // HATA: narrowing conversion
    
    std::cout << "Brace init int: " << brace_int << std::endl;
    std::cout << "Brace init double: " << brace_double << std::endl;
    
    // std::numeric_limits ile gÃ¼venli aralÄ±k kontrolÃ¼
    std::cout << "\n--- GÃ¼venli AralÄ±k KontrolÃ¼ ---" << std::endl;
    
    if (automatic_int <= std::numeric_limits<char>::max()) {
        char safe_char = static_cast<char>(automatic_int);
        std::cout << "GÃ¼venli char dÃ¶nÃ¼ÅŸÃ¼mÃ¼: " << static_cast<int>(safe_char) << std::endl;
    } else {
        std::cout << "char aralÄ±ÄŸÄ±nÄ± aÅŸÄ±yor, dÃ¶nÃ¼ÅŸÃ¼m gÃ¼venli deÄŸil" << std::endl;
    }
    
    // Type traits ile compile-time kontroller
    std::cout << "\n--- Type Traits ---" << std::endl;
    
    std::cout << "int integral mi? " << std::is_integral_v<int> << std::endl;
    std::cout << "double floating mi? " << std::is_floating_point_v<double> << std::endl;
    std::cout << "int ve double aynÄ± mÄ±? " << std::is_same_v<int, double> << std::endl;
    std::cout << "int ve int aynÄ± mÄ±? " << std::is_same_v<int, int> << std::endl;
}

int main() {
    demonstrateImplicitConversions();
    demonstrateExplicitConversions();
    demonstrateTypeSafety();
    
    std::cout << "\n=== TÃ¼r GÃ¼venliÄŸi Best Practices ===" << std::endl;
    std::cout << "âœ“ Ã–rtÃ¼k dÃ¶nÃ¼ÅŸÃ¼mlere dikkat edin" << std::endl;
    std::cout << "âœ“ static_cast kullanÄ±n, C-style cast'tan kaÃ§Ä±nÄ±n" << std::endl;
    std::cout << "âœ“ Brace initialization tercih edin" << std::endl;
    std::cout << "âœ“ auto keyword'Ã¼ akÄ±llÄ±ca kullanÄ±n" << std::endl;
    std::cout << "âœ“ AralÄ±k kontrolÃ¼ yapÄ±n" << std::endl;
    std::cout << "âœ“ Type traits ile compile-time kontroller" << std::endl;
    std::cout << "âœ“ const correctness'Ä± koruyun" << std::endl;
    
    return 0;
}
```

Temel veri tÃ¼rleri, C++ programlamanÄ±n temeli olup doÄŸru seÃ§im ve kullanÄ±m programÄ±n performansÄ±nÄ±, gÃ¼venliÄŸini ve okunabilirliÄŸini doÄŸrudan etkiler. Modern C++ Ã¶zellikleri ile birlikte type safety ve verimlilik saÄŸlanabilir. 